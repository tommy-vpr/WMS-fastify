
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductVariant
 * 
 */
export type ProductVariant = $Result.DefaultSelection<Prisma.$ProductVariantPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model InventoryUnit
 * 
 */
export type InventoryUnit = $Result.DefaultSelection<Prisma.$InventoryUnitPayload>
/**
 * Model Allocation
 * 
 */
export type Allocation = $Result.DefaultSelection<Prisma.$AllocationPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model WorkTask
 * 
 */
export type WorkTask = $Result.DefaultSelection<Prisma.$WorkTaskPayload>
/**
 * Model TaskItem
 * 
 */
export type TaskItem = $Result.DefaultSelection<Prisma.$TaskItemPayload>
/**
 * Model TaskEvent
 * 
 */
export type TaskEvent = $Result.DefaultSelection<Prisma.$TaskEventPayload>
/**
 * Model JobRecord
 * 
 */
export type JobRecord = $Result.DefaultSelection<Prisma.$JobRecordPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  STAFF: 'STAFF',
  READONLY: 'READONLY'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const InventoryStatus: {
  AVAILABLE: 'AVAILABLE',
  RESERVED: 'RESERVED',
  PICKED: 'PICKED',
  DAMAGED: 'DAMAGED',
  IN_TRANSIT: 'IN_TRANSIT',
  QUARANTINE: 'QUARANTINE'
};

export type InventoryStatus = (typeof InventoryStatus)[keyof typeof InventoryStatus]


export const AllocationStatus: {
  PENDING: 'PENDING',
  ALLOCATED: 'ALLOCATED',
  PARTIALLY_PICKED: 'PARTIALLY_PICKED',
  PICKED: 'PICKED',
  RELEASED: 'RELEASED',
  CANCELLED: 'CANCELLED'
};

export type AllocationStatus = (typeof AllocationStatus)[keyof typeof AllocationStatus]


export const OrderStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  READY_TO_PICK: 'READY_TO_PICK',
  ALLOCATED: 'ALLOCATED',
  PARTIALLY_ALLOCATED: 'PARTIALLY_ALLOCATED',
  BACKORDERED: 'BACKORDERED',
  PICKING: 'PICKING',
  PICKED: 'PICKED',
  PACKING: 'PACKING',
  PACKED: 'PACKED',
  SHIPPED: 'SHIPPED',
  DELIVERED: 'DELIVERED',
  CANCELLED: 'CANCELLED',
  ON_HOLD: 'ON_HOLD'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  AUTHORIZED: 'AUTHORIZED',
  PAID: 'PAID',
  PARTIALLY_REFUNDED: 'PARTIALLY_REFUNDED',
  REFUNDED: 'REFUNDED',
  FAILED: 'FAILED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const Priority: {
  STANDARD: 'STANDARD',
  RUSH: 'RUSH',
  EXPRESS: 'EXPRESS'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const LocationType: {
  RECEIVING: 'RECEIVING',
  STORAGE: 'STORAGE',
  PICKING: 'PICKING',
  PACKING: 'PACKING',
  SHIPPING: 'SHIPPING',
  RETURNS: 'RETURNS',
  QUARANTINE: 'QUARANTINE',
  GENERAL: 'GENERAL'
};

export type LocationType = (typeof LocationType)[keyof typeof LocationType]


export const WorkTaskType: {
  PICKING: 'PICKING',
  PACKING: 'PACKING',
  SHIPPING: 'SHIPPING',
  RECEIVING: 'RECEIVING',
  PUTAWAY: 'PUTAWAY',
  CYCLE_COUNT: 'CYCLE_COUNT',
  REPLENISHMENT: 'REPLENISHMENT',
  QC: 'QC'
};

export type WorkTaskType = (typeof WorkTaskType)[keyof typeof WorkTaskType]


export const WorkTaskStatus: {
  PENDING: 'PENDING',
  ASSIGNED: 'ASSIGNED',
  IN_PROGRESS: 'IN_PROGRESS',
  BLOCKED: 'BLOCKED',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type WorkTaskStatus = (typeof WorkTaskStatus)[keyof typeof WorkTaskStatus]


export const WorkTaskItemStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  SKIPPED: 'SKIPPED',
  SHORT: 'SHORT'
};

export type WorkTaskItemStatus = (typeof WorkTaskItemStatus)[keyof typeof WorkTaskItemStatus]


export const WorkTaskBlockReason: {
  SHORT_PICK: 'SHORT_PICK',
  LOCATION_EMPTY: 'LOCATION_EMPTY',
  DAMAGED_INVENTORY: 'DAMAGED_INVENTORY',
  PICKER_TIMEOUT: 'PICKER_TIMEOUT',
  SUPERVISOR_HOLD: 'SUPERVISOR_HOLD',
  EQUIPMENT_ISSUE: 'EQUIPMENT_ISSUE',
  SYSTEM_ERROR: 'SYSTEM_ERROR'
};

export type WorkTaskBlockReason = (typeof WorkTaskBlockReason)[keyof typeof WorkTaskBlockReason]


export const WorkTaskEventType: {
  TASK_CREATED: 'TASK_CREATED',
  TASK_ASSIGNED: 'TASK_ASSIGNED',
  TASK_STARTED: 'TASK_STARTED',
  TASK_PAUSED: 'TASK_PAUSED',
  TASK_RESUMED: 'TASK_RESUMED',
  TASK_BLOCKED: 'TASK_BLOCKED',
  TASK_UNBLOCKED: 'TASK_UNBLOCKED',
  TASK_COMPLETED: 'TASK_COMPLETED',
  TASK_CANCELLED: 'TASK_CANCELLED',
  ITEM_SCANNED: 'ITEM_SCANNED',
  ITEM_COMPLETED: 'ITEM_COMPLETED',
  ITEM_SKIPPED: 'ITEM_SKIPPED',
  ITEM_SHORT: 'ITEM_SHORT',
  LOCATION_VERIFIED: 'LOCATION_VERIFIED'
};

export type WorkTaskEventType = (typeof WorkTaskEventType)[keyof typeof WorkTaskEventType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type InventoryStatus = $Enums.InventoryStatus

export const InventoryStatus: typeof $Enums.InventoryStatus

export type AllocationStatus = $Enums.AllocationStatus

export const AllocationStatus: typeof $Enums.AllocationStatus

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type LocationType = $Enums.LocationType

export const LocationType: typeof $Enums.LocationType

export type WorkTaskType = $Enums.WorkTaskType

export const WorkTaskType: typeof $Enums.WorkTaskType

export type WorkTaskStatus = $Enums.WorkTaskStatus

export const WorkTaskStatus: typeof $Enums.WorkTaskStatus

export type WorkTaskItemStatus = $Enums.WorkTaskItemStatus

export const WorkTaskItemStatus: typeof $Enums.WorkTaskItemStatus

export type WorkTaskBlockReason = $Enums.WorkTaskBlockReason

export const WorkTaskBlockReason: typeof $Enums.WorkTaskBlockReason

export type WorkTaskEventType = $Enums.WorkTaskEventType

export const WorkTaskEventType: typeof $Enums.WorkTaskEventType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productVariant`: Exposes CRUD operations for the **ProductVariant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductVariants
    * const productVariants = await prisma.productVariant.findMany()
    * ```
    */
  get productVariant(): Prisma.ProductVariantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryUnit`: Exposes CRUD operations for the **InventoryUnit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryUnits
    * const inventoryUnits = await prisma.inventoryUnit.findMany()
    * ```
    */
  get inventoryUnit(): Prisma.InventoryUnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.allocation`: Exposes CRUD operations for the **Allocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Allocations
    * const allocations = await prisma.allocation.findMany()
    * ```
    */
  get allocation(): Prisma.AllocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workTask`: Exposes CRUD operations for the **WorkTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkTasks
    * const workTasks = await prisma.workTask.findMany()
    * ```
    */
  get workTask(): Prisma.WorkTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskItem`: Exposes CRUD operations for the **TaskItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskItems
    * const taskItems = await prisma.taskItem.findMany()
    * ```
    */
  get taskItem(): Prisma.TaskItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskEvent`: Exposes CRUD operations for the **TaskEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskEvents
    * const taskEvents = await prisma.taskEvent.findMany()
    * ```
    */
  get taskEvent(): Prisma.TaskEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobRecord`: Exposes CRUD operations for the **JobRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobRecords
    * const jobRecords = await prisma.jobRecord.findMany()
    * ```
    */
  get jobRecord(): Prisma.JobRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    RefreshToken: 'RefreshToken',
    PasswordResetToken: 'PasswordResetToken',
    Product: 'Product',
    ProductVariant: 'ProductVariant',
    Location: 'Location',
    InventoryUnit: 'InventoryUnit',
    Allocation: 'Allocation',
    Order: 'Order',
    OrderItem: 'OrderItem',
    WorkTask: 'WorkTask',
    TaskItem: 'TaskItem',
    TaskEvent: 'TaskEvent',
    JobRecord: 'JobRecord',
    AuditLog: 'AuditLog',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "refreshToken" | "passwordResetToken" | "product" | "productVariant" | "location" | "inventoryUnit" | "allocation" | "order" | "orderItem" | "workTask" | "taskItem" | "taskEvent" | "jobRecord" | "auditLog" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductVariant: {
        payload: Prisma.$ProductVariantPayload<ExtArgs>
        fields: Prisma.ProductVariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductVariantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductVariantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          findFirst: {
            args: Prisma.ProductVariantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductVariantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          findMany: {
            args: Prisma.ProductVariantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
          }
          create: {
            args: Prisma.ProductVariantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          createMany: {
            args: Prisma.ProductVariantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductVariantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
          }
          delete: {
            args: Prisma.ProductVariantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          update: {
            args: Prisma.ProductVariantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          deleteMany: {
            args: Prisma.ProductVariantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductVariantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductVariantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
          }
          upsert: {
            args: Prisma.ProductVariantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          aggregate: {
            args: Prisma.ProductVariantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductVariant>
          }
          groupBy: {
            args: Prisma.ProductVariantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductVariantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductVariantCountArgs<ExtArgs>
            result: $Utils.Optional<ProductVariantCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      InventoryUnit: {
        payload: Prisma.$InventoryUnitPayload<ExtArgs>
        fields: Prisma.InventoryUnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryUnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryUnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUnitPayload>
          }
          findFirst: {
            args: Prisma.InventoryUnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryUnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUnitPayload>
          }
          findMany: {
            args: Prisma.InventoryUnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUnitPayload>[]
          }
          create: {
            args: Prisma.InventoryUnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUnitPayload>
          }
          createMany: {
            args: Prisma.InventoryUnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryUnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUnitPayload>[]
          }
          delete: {
            args: Prisma.InventoryUnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUnitPayload>
          }
          update: {
            args: Prisma.InventoryUnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUnitPayload>
          }
          deleteMany: {
            args: Prisma.InventoryUnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryUnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUnitPayload>[]
          }
          upsert: {
            args: Prisma.InventoryUnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUnitPayload>
          }
          aggregate: {
            args: Prisma.InventoryUnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryUnit>
          }
          groupBy: {
            args: Prisma.InventoryUnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryUnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryUnitCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryUnitCountAggregateOutputType> | number
          }
        }
      }
      Allocation: {
        payload: Prisma.$AllocationPayload<ExtArgs>
        fields: Prisma.AllocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AllocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AllocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationPayload>
          }
          findFirst: {
            args: Prisma.AllocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AllocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationPayload>
          }
          findMany: {
            args: Prisma.AllocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationPayload>[]
          }
          create: {
            args: Prisma.AllocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationPayload>
          }
          createMany: {
            args: Prisma.AllocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AllocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationPayload>[]
          }
          delete: {
            args: Prisma.AllocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationPayload>
          }
          update: {
            args: Prisma.AllocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationPayload>
          }
          deleteMany: {
            args: Prisma.AllocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AllocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AllocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationPayload>[]
          }
          upsert: {
            args: Prisma.AllocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationPayload>
          }
          aggregate: {
            args: Prisma.AllocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAllocation>
          }
          groupBy: {
            args: Prisma.AllocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AllocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AllocationCountArgs<ExtArgs>
            result: $Utils.Optional<AllocationCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      WorkTask: {
        payload: Prisma.$WorkTaskPayload<ExtArgs>
        fields: Prisma.WorkTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTaskPayload>
          }
          findFirst: {
            args: Prisma.WorkTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTaskPayload>
          }
          findMany: {
            args: Prisma.WorkTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTaskPayload>[]
          }
          create: {
            args: Prisma.WorkTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTaskPayload>
          }
          createMany: {
            args: Prisma.WorkTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTaskPayload>[]
          }
          delete: {
            args: Prisma.WorkTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTaskPayload>
          }
          update: {
            args: Prisma.WorkTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTaskPayload>
          }
          deleteMany: {
            args: Prisma.WorkTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTaskPayload>[]
          }
          upsert: {
            args: Prisma.WorkTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTaskPayload>
          }
          aggregate: {
            args: Prisma.WorkTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkTask>
          }
          groupBy: {
            args: Prisma.WorkTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkTaskCountArgs<ExtArgs>
            result: $Utils.Optional<WorkTaskCountAggregateOutputType> | number
          }
        }
      }
      TaskItem: {
        payload: Prisma.$TaskItemPayload<ExtArgs>
        fields: Prisma.TaskItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskItemPayload>
          }
          findFirst: {
            args: Prisma.TaskItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskItemPayload>
          }
          findMany: {
            args: Prisma.TaskItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskItemPayload>[]
          }
          create: {
            args: Prisma.TaskItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskItemPayload>
          }
          createMany: {
            args: Prisma.TaskItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskItemPayload>[]
          }
          delete: {
            args: Prisma.TaskItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskItemPayload>
          }
          update: {
            args: Prisma.TaskItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskItemPayload>
          }
          deleteMany: {
            args: Prisma.TaskItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskItemPayload>[]
          }
          upsert: {
            args: Prisma.TaskItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskItemPayload>
          }
          aggregate: {
            args: Prisma.TaskItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskItem>
          }
          groupBy: {
            args: Prisma.TaskItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskItemCountArgs<ExtArgs>
            result: $Utils.Optional<TaskItemCountAggregateOutputType> | number
          }
        }
      }
      TaskEvent: {
        payload: Prisma.$TaskEventPayload<ExtArgs>
        fields: Prisma.TaskEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload>
          }
          findFirst: {
            args: Prisma.TaskEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload>
          }
          findMany: {
            args: Prisma.TaskEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload>[]
          }
          create: {
            args: Prisma.TaskEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload>
          }
          createMany: {
            args: Prisma.TaskEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload>[]
          }
          delete: {
            args: Prisma.TaskEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload>
          }
          update: {
            args: Prisma.TaskEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload>
          }
          deleteMany: {
            args: Prisma.TaskEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload>[]
          }
          upsert: {
            args: Prisma.TaskEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload>
          }
          aggregate: {
            args: Prisma.TaskEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskEvent>
          }
          groupBy: {
            args: Prisma.TaskEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskEventCountArgs<ExtArgs>
            result: $Utils.Optional<TaskEventCountAggregateOutputType> | number
          }
        }
      }
      JobRecord: {
        payload: Prisma.$JobRecordPayload<ExtArgs>
        fields: Prisma.JobRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRecordPayload>
          }
          findFirst: {
            args: Prisma.JobRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRecordPayload>
          }
          findMany: {
            args: Prisma.JobRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRecordPayload>[]
          }
          create: {
            args: Prisma.JobRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRecordPayload>
          }
          createMany: {
            args: Prisma.JobRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRecordPayload>[]
          }
          delete: {
            args: Prisma.JobRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRecordPayload>
          }
          update: {
            args: Prisma.JobRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRecordPayload>
          }
          deleteMany: {
            args: Prisma.JobRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRecordPayload>[]
          }
          upsert: {
            args: Prisma.JobRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRecordPayload>
          }
          aggregate: {
            args: Prisma.JobRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobRecord>
          }
          groupBy: {
            args: Prisma.JobRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobRecordCountArgs<ExtArgs>
            result: $Utils.Optional<JobRecordCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    refreshToken?: RefreshTokenOmit
    passwordResetToken?: PasswordResetTokenOmit
    product?: ProductOmit
    productVariant?: ProductVariantOmit
    location?: LocationOmit
    inventoryUnit?: InventoryUnitOmit
    allocation?: AllocationOmit
    order?: OrderOmit
    orderItem?: OrderItemOmit
    workTask?: WorkTaskOmit
    taskItem?: TaskItemOmit
    taskEvent?: TaskEventOmit
    jobRecord?: JobRecordOmit
    auditLog?: AuditLogOmit
    notification?: NotificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    refreshTokens: number
    passwordResetTokens: number
    assignedTasks: number
    taskEvents: number
    completedTaskItems: number
    auditLogs: number
    notifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    passwordResetTokens?: boolean | UserCountOutputTypeCountPasswordResetTokensArgs
    assignedTasks?: boolean | UserCountOutputTypeCountAssignedTasksArgs
    taskEvents?: boolean | UserCountOutputTypeCountTaskEventsArgs
    completedTaskItems?: boolean | UserCountOutputTypeCountCompletedTaskItemsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkTaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaskEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCompletedTaskItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    variants: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variants?: boolean | ProductCountOutputTypeCountVariantsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariantWhereInput
  }


  /**
   * Count Type ProductVariantCountOutputType
   */

  export type ProductVariantCountOutputType = {
    orderItems: number
    inventoryUnits: number
    taskItems: number
    allocations: number
  }

  export type ProductVariantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | ProductVariantCountOutputTypeCountOrderItemsArgs
    inventoryUnits?: boolean | ProductVariantCountOutputTypeCountInventoryUnitsArgs
    taskItems?: boolean | ProductVariantCountOutputTypeCountTaskItemsArgs
    allocations?: boolean | ProductVariantCountOutputTypeCountAllocationsArgs
  }

  // Custom InputTypes
  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantCountOutputType
     */
    select?: ProductVariantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeCountInventoryUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryUnitWhereInput
  }

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeCountTaskItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskItemWhereInput
  }

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeCountAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllocationWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    inventoryUnits: number
    taskItems: number
    allocations: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryUnits?: boolean | LocationCountOutputTypeCountInventoryUnitsArgs
    taskItems?: boolean | LocationCountOutputTypeCountTaskItemsArgs
    allocations?: boolean | LocationCountOutputTypeCountAllocationsArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountInventoryUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryUnitWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountTaskItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskItemWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllocationWhereInput
  }


  /**
   * Count Type InventoryUnitCountOutputType
   */

  export type InventoryUnitCountOutputType = {
    allocations: number
  }

  export type InventoryUnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    allocations?: boolean | InventoryUnitCountOutputTypeCountAllocationsArgs
  }

  // Custom InputTypes
  /**
   * InventoryUnitCountOutputType without action
   */
  export type InventoryUnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUnitCountOutputType
     */
    select?: InventoryUnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryUnitCountOutputType without action
   */
  export type InventoryUnitCountOutputTypeCountAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllocationWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
    taskItems: number
    allocations: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
    taskItems?: boolean | OrderCountOutputTypeCountTaskItemsArgs
    allocations?: boolean | OrderCountOutputTypeCountAllocationsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountTaskItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskItemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllocationWhereInput
  }


  /**
   * Count Type OrderItemCountOutputType
   */

  export type OrderItemCountOutputType = {
    taskItems: number
    allocations: number
  }

  export type OrderItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taskItems?: boolean | OrderItemCountOutputTypeCountTaskItemsArgs
    allocations?: boolean | OrderItemCountOutputTypeCountAllocationsArgs
  }

  // Custom InputTypes
  /**
   * OrderItemCountOutputType without action
   */
  export type OrderItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemCountOutputType
     */
    select?: OrderItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderItemCountOutputType without action
   */
  export type OrderItemCountOutputTypeCountTaskItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskItemWhereInput
  }

  /**
   * OrderItemCountOutputType without action
   */
  export type OrderItemCountOutputTypeCountAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllocationWhereInput
  }


  /**
   * Count Type WorkTaskCountOutputType
   */

  export type WorkTaskCountOutputType = {
    taskItems: number
    events: number
  }

  export type WorkTaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taskItems?: boolean | WorkTaskCountOutputTypeCountTaskItemsArgs
    events?: boolean | WorkTaskCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * WorkTaskCountOutputType without action
   */
  export type WorkTaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTaskCountOutputType
     */
    select?: WorkTaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkTaskCountOutputType without action
   */
  export type WorkTaskCountOutputTypeCountTaskItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskItemWhereInput
  }

  /**
   * WorkTaskCountOutputType without action
   */
  export type WorkTaskCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskEventWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    image: string | null
    role: $Enums.UserRole | null
    active: boolean | null
    emailVerified: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    image: string | null
    role: $Enums.UserRole | null
    active: boolean | null
    emailVerified: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    image: number
    role: number
    active: number
    emailVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    image?: true
    role?: true
    active?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    image?: true
    role?: true
    active?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    image?: true
    role?: true
    active?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string | null
    name: string | null
    image: string | null
    role: $Enums.UserRole
    active: boolean
    emailVerified: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    image?: boolean
    role?: boolean
    active?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    assignedTasks?: boolean | User$assignedTasksArgs<ExtArgs>
    taskEvents?: boolean | User$taskEventsArgs<ExtArgs>
    completedTaskItems?: boolean | User$completedTaskItemsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    image?: boolean
    role?: boolean
    active?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    image?: boolean
    role?: boolean
    active?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    image?: boolean
    role?: boolean
    active?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "image" | "role" | "active" | "emailVerified" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    assignedTasks?: boolean | User$assignedTasksArgs<ExtArgs>
    taskEvents?: boolean | User$taskEventsArgs<ExtArgs>
    completedTaskItems?: boolean | User$completedTaskItemsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      passwordResetTokens: Prisma.$PasswordResetTokenPayload<ExtArgs>[]
      assignedTasks: Prisma.$WorkTaskPayload<ExtArgs>[]
      taskEvents: Prisma.$TaskEventPayload<ExtArgs>[]
      completedTaskItems: Prisma.$TaskItemPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string | null
      name: string | null
      image: string | null
      role: $Enums.UserRole
      active: boolean
      emailVerified: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordResetTokens<T extends User$passwordResetTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedTasks<T extends User$assignedTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskEvents<T extends User$taskEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$taskEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    completedTaskItems<T extends User$completedTaskItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$completedTaskItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly active: FieldRef<"User", 'Boolean'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.passwordResetTokens
   */
  export type User$passwordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    cursor?: PasswordResetTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * User.assignedTasks
   */
  export type User$assignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTask
     */
    select?: WorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTask
     */
    omit?: WorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTaskInclude<ExtArgs> | null
    where?: WorkTaskWhereInput
    orderBy?: WorkTaskOrderByWithRelationInput | WorkTaskOrderByWithRelationInput[]
    cursor?: WorkTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkTaskScalarFieldEnum | WorkTaskScalarFieldEnum[]
  }

  /**
   * User.taskEvents
   */
  export type User$taskEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
    where?: TaskEventWhereInput
    orderBy?: TaskEventOrderByWithRelationInput | TaskEventOrderByWithRelationInput[]
    cursor?: TaskEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskEventScalarFieldEnum | TaskEventScalarFieldEnum[]
  }

  /**
   * User.completedTaskItems
   */
  export type User$completedTaskItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskItem
     */
    select?: TaskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskItem
     */
    omit?: TaskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskItemInclude<ExtArgs> | null
    where?: TaskItemWhereInput
    orderBy?: TaskItemOrderByWithRelationInput | TaskItemOrderByWithRelationInput[]
    cursor?: TaskItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskItemScalarFieldEnum | TaskItemScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    revokedAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    revokedAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    expiresAt: number
    createdAt: number
    revokedAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    revokedAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    revokedAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    revokedAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    expiresAt: Date
    createdAt: Date
    revokedAt: Date | null
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "expiresAt" | "createdAt" | "revokedAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      expiresAt: Date
      createdAt: Date
      revokedAt: Date | null
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly revokedAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    expiresAt: Date
    createdAt: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "expiresAt" | "createdAt", ExtArgs["result"]["passwordResetToken"]>
  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens and returns the data updated in the database.
     * @param {PasswordResetTokenUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetTokens.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly userId: FieldRef<"PasswordResetToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly createdAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken updateManyAndReturn
   */
  export type PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    sku: string | null
    name: string | null
    description: string | null
    brand: string | null
    category: string | null
    shopifyProductId: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    sku: string | null
    name: string | null
    description: string | null
    brand: string | null
    category: string | null
    shopifyProductId: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    sku: number
    name: number
    description: number
    brand: number
    category: number
    shopifyProductId: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductMinAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    brand?: true
    category?: true
    shopifyProductId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    brand?: true
    category?: true
    shopifyProductId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    brand?: true
    category?: true
    shopifyProductId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    sku: string
    name: string
    description: string | null
    brand: string | null
    category: string | null
    shopifyProductId: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    brand?: boolean
    category?: boolean
    shopifyProductId?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variants?: boolean | Product$variantsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    brand?: boolean
    category?: boolean
    shopifyProductId?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    brand?: boolean
    category?: boolean
    shopifyProductId?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    brand?: boolean
    category?: boolean
    shopifyProductId?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sku" | "name" | "description" | "brand" | "category" | "shopifyProductId" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variants?: boolean | Product$variantsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      variants: Prisma.$ProductVariantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sku: string
      name: string
      description: string | null
      brand: string | null
      category: string | null
      shopifyProductId: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variants<T extends Product$variantsArgs<ExtArgs> = {}>(args?: Subset<T, Product$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly brand: FieldRef<"Product", 'String'>
    readonly category: FieldRef<"Product", 'String'>
    readonly shopifyProductId: FieldRef<"Product", 'String'>
    readonly active: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.variants
   */
  export type Product$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    where?: ProductVariantWhereInput
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    cursor?: ProductVariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductVariant
   */

  export type AggregateProductVariant = {
    _count: ProductVariantCountAggregateOutputType | null
    _avg: ProductVariantAvgAggregateOutputType | null
    _sum: ProductVariantSumAggregateOutputType | null
    _min: ProductVariantMinAggregateOutputType | null
    _max: ProductVariantMaxAggregateOutputType | null
  }

  export type ProductVariantAvgAggregateOutputType = {
    costPrice: Decimal | null
    sellingPrice: Decimal | null
    weight: Decimal | null
  }

  export type ProductVariantSumAggregateOutputType = {
    costPrice: Decimal | null
    sellingPrice: Decimal | null
    weight: Decimal | null
  }

  export type ProductVariantMinAggregateOutputType = {
    id: string | null
    productId: string | null
    sku: string | null
    upc: string | null
    barcode: string | null
    name: string | null
    imageUrl: string | null
    shopifyVariantId: string | null
    costPrice: Decimal | null
    sellingPrice: Decimal | null
    weight: Decimal | null
    trackLots: boolean | null
    trackExpiry: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariantMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    sku: string | null
    upc: string | null
    barcode: string | null
    name: string | null
    imageUrl: string | null
    shopifyVariantId: string | null
    costPrice: Decimal | null
    sellingPrice: Decimal | null
    weight: Decimal | null
    trackLots: boolean | null
    trackExpiry: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariantCountAggregateOutputType = {
    id: number
    productId: number
    sku: number
    upc: number
    barcode: number
    name: number
    imageUrl: number
    shopifyVariantId: number
    costPrice: number
    sellingPrice: number
    weight: number
    trackLots: number
    trackExpiry: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductVariantAvgAggregateInputType = {
    costPrice?: true
    sellingPrice?: true
    weight?: true
  }

  export type ProductVariantSumAggregateInputType = {
    costPrice?: true
    sellingPrice?: true
    weight?: true
  }

  export type ProductVariantMinAggregateInputType = {
    id?: true
    productId?: true
    sku?: true
    upc?: true
    barcode?: true
    name?: true
    imageUrl?: true
    shopifyVariantId?: true
    costPrice?: true
    sellingPrice?: true
    weight?: true
    trackLots?: true
    trackExpiry?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariantMaxAggregateInputType = {
    id?: true
    productId?: true
    sku?: true
    upc?: true
    barcode?: true
    name?: true
    imageUrl?: true
    shopifyVariantId?: true
    costPrice?: true
    sellingPrice?: true
    weight?: true
    trackLots?: true
    trackExpiry?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariantCountAggregateInputType = {
    id?: true
    productId?: true
    sku?: true
    upc?: true
    barcode?: true
    name?: true
    imageUrl?: true
    shopifyVariantId?: true
    costPrice?: true
    sellingPrice?: true
    weight?: true
    trackLots?: true
    trackExpiry?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductVariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariant to aggregate.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductVariants
    **/
    _count?: true | ProductVariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductVariantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductVariantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductVariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductVariantMaxAggregateInputType
  }

  export type GetProductVariantAggregateType<T extends ProductVariantAggregateArgs> = {
        [P in keyof T & keyof AggregateProductVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductVariant[P]>
      : GetScalarType<T[P], AggregateProductVariant[P]>
  }




  export type ProductVariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariantWhereInput
    orderBy?: ProductVariantOrderByWithAggregationInput | ProductVariantOrderByWithAggregationInput[]
    by: ProductVariantScalarFieldEnum[] | ProductVariantScalarFieldEnum
    having?: ProductVariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductVariantCountAggregateInputType | true
    _avg?: ProductVariantAvgAggregateInputType
    _sum?: ProductVariantSumAggregateInputType
    _min?: ProductVariantMinAggregateInputType
    _max?: ProductVariantMaxAggregateInputType
  }

  export type ProductVariantGroupByOutputType = {
    id: string
    productId: string
    sku: string
    upc: string | null
    barcode: string | null
    name: string
    imageUrl: string | null
    shopifyVariantId: string | null
    costPrice: Decimal | null
    sellingPrice: Decimal | null
    weight: Decimal | null
    trackLots: boolean
    trackExpiry: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductVariantCountAggregateOutputType | null
    _avg: ProductVariantAvgAggregateOutputType | null
    _sum: ProductVariantSumAggregateOutputType | null
    _min: ProductVariantMinAggregateOutputType | null
    _max: ProductVariantMaxAggregateOutputType | null
  }

  type GetProductVariantGroupByPayload<T extends ProductVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductVariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductVariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductVariantGroupByOutputType[P]>
            : GetScalarType<T[P], ProductVariantGroupByOutputType[P]>
        }
      >
    >


  export type ProductVariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    sku?: boolean
    upc?: boolean
    barcode?: boolean
    name?: boolean
    imageUrl?: boolean
    shopifyVariantId?: boolean
    costPrice?: boolean
    sellingPrice?: boolean
    weight?: boolean
    trackLots?: boolean
    trackExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    orderItems?: boolean | ProductVariant$orderItemsArgs<ExtArgs>
    inventoryUnits?: boolean | ProductVariant$inventoryUnitsArgs<ExtArgs>
    taskItems?: boolean | ProductVariant$taskItemsArgs<ExtArgs>
    allocations?: boolean | ProductVariant$allocationsArgs<ExtArgs>
    _count?: boolean | ProductVariantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariant"]>

  export type ProductVariantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    sku?: boolean
    upc?: boolean
    barcode?: boolean
    name?: boolean
    imageUrl?: boolean
    shopifyVariantId?: boolean
    costPrice?: boolean
    sellingPrice?: boolean
    weight?: boolean
    trackLots?: boolean
    trackExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariant"]>

  export type ProductVariantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    sku?: boolean
    upc?: boolean
    barcode?: boolean
    name?: boolean
    imageUrl?: boolean
    shopifyVariantId?: boolean
    costPrice?: boolean
    sellingPrice?: boolean
    weight?: boolean
    trackLots?: boolean
    trackExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariant"]>

  export type ProductVariantSelectScalar = {
    id?: boolean
    productId?: boolean
    sku?: boolean
    upc?: boolean
    barcode?: boolean
    name?: boolean
    imageUrl?: boolean
    shopifyVariantId?: boolean
    costPrice?: boolean
    sellingPrice?: boolean
    weight?: boolean
    trackLots?: boolean
    trackExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductVariantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "sku" | "upc" | "barcode" | "name" | "imageUrl" | "shopifyVariantId" | "costPrice" | "sellingPrice" | "weight" | "trackLots" | "trackExpiry" | "createdAt" | "updatedAt", ExtArgs["result"]["productVariant"]>
  export type ProductVariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    orderItems?: boolean | ProductVariant$orderItemsArgs<ExtArgs>
    inventoryUnits?: boolean | ProductVariant$inventoryUnitsArgs<ExtArgs>
    taskItems?: boolean | ProductVariant$taskItemsArgs<ExtArgs>
    allocations?: boolean | ProductVariant$allocationsArgs<ExtArgs>
    _count?: boolean | ProductVariantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductVariantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductVariantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductVariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductVariant"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      inventoryUnits: Prisma.$InventoryUnitPayload<ExtArgs>[]
      taskItems: Prisma.$TaskItemPayload<ExtArgs>[]
      allocations: Prisma.$AllocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      sku: string
      upc: string | null
      barcode: string | null
      name: string
      imageUrl: string | null
      shopifyVariantId: string | null
      costPrice: Prisma.Decimal | null
      sellingPrice: Prisma.Decimal | null
      weight: Prisma.Decimal | null
      trackLots: boolean
      trackExpiry: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productVariant"]>
    composites: {}
  }

  type ProductVariantGetPayload<S extends boolean | null | undefined | ProductVariantDefaultArgs> = $Result.GetResult<Prisma.$ProductVariantPayload, S>

  type ProductVariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductVariantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductVariantCountAggregateInputType | true
    }

  export interface ProductVariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductVariant'], meta: { name: 'ProductVariant' } }
    /**
     * Find zero or one ProductVariant that matches the filter.
     * @param {ProductVariantFindUniqueArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductVariantFindUniqueArgs>(args: SelectSubset<T, ProductVariantFindUniqueArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductVariant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductVariantFindUniqueOrThrowArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductVariantFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductVariantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindFirstArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductVariantFindFirstArgs>(args?: SelectSubset<T, ProductVariantFindFirstArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindFirstOrThrowArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductVariantFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductVariantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductVariants
     * const productVariants = await prisma.productVariant.findMany()
     * 
     * // Get first 10 ProductVariants
     * const productVariants = await prisma.productVariant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductVariantFindManyArgs>(args?: SelectSubset<T, ProductVariantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductVariant.
     * @param {ProductVariantCreateArgs} args - Arguments to create a ProductVariant.
     * @example
     * // Create one ProductVariant
     * const ProductVariant = await prisma.productVariant.create({
     *   data: {
     *     // ... data to create a ProductVariant
     *   }
     * })
     * 
     */
    create<T extends ProductVariantCreateArgs>(args: SelectSubset<T, ProductVariantCreateArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductVariants.
     * @param {ProductVariantCreateManyArgs} args - Arguments to create many ProductVariants.
     * @example
     * // Create many ProductVariants
     * const productVariant = await prisma.productVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductVariantCreateManyArgs>(args?: SelectSubset<T, ProductVariantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductVariants and returns the data saved in the database.
     * @param {ProductVariantCreateManyAndReturnArgs} args - Arguments to create many ProductVariants.
     * @example
     * // Create many ProductVariants
     * const productVariant = await prisma.productVariant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductVariants and only return the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductVariantCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductVariantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductVariant.
     * @param {ProductVariantDeleteArgs} args - Arguments to delete one ProductVariant.
     * @example
     * // Delete one ProductVariant
     * const ProductVariant = await prisma.productVariant.delete({
     *   where: {
     *     // ... filter to delete one ProductVariant
     *   }
     * })
     * 
     */
    delete<T extends ProductVariantDeleteArgs>(args: SelectSubset<T, ProductVariantDeleteArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductVariant.
     * @param {ProductVariantUpdateArgs} args - Arguments to update one ProductVariant.
     * @example
     * // Update one ProductVariant
     * const productVariant = await prisma.productVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductVariantUpdateArgs>(args: SelectSubset<T, ProductVariantUpdateArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductVariants.
     * @param {ProductVariantDeleteManyArgs} args - Arguments to filter ProductVariants to delete.
     * @example
     * // Delete a few ProductVariants
     * const { count } = await prisma.productVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductVariantDeleteManyArgs>(args?: SelectSubset<T, ProductVariantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductVariants
     * const productVariant = await prisma.productVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductVariantUpdateManyArgs>(args: SelectSubset<T, ProductVariantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariants and returns the data updated in the database.
     * @param {ProductVariantUpdateManyAndReturnArgs} args - Arguments to update many ProductVariants.
     * @example
     * // Update many ProductVariants
     * const productVariant = await prisma.productVariant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductVariants and only return the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductVariantUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductVariantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductVariant.
     * @param {ProductVariantUpsertArgs} args - Arguments to update or create a ProductVariant.
     * @example
     * // Update or create a ProductVariant
     * const productVariant = await prisma.productVariant.upsert({
     *   create: {
     *     // ... data to create a ProductVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductVariant we want to update
     *   }
     * })
     */
    upsert<T extends ProductVariantUpsertArgs>(args: SelectSubset<T, ProductVariantUpsertArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantCountArgs} args - Arguments to filter ProductVariants to count.
     * @example
     * // Count the number of ProductVariants
     * const count = await prisma.productVariant.count({
     *   where: {
     *     // ... the filter for the ProductVariants we want to count
     *   }
     * })
    **/
    count<T extends ProductVariantCountArgs>(
      args?: Subset<T, ProductVariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductVariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductVariantAggregateArgs>(args: Subset<T, ProductVariantAggregateArgs>): Prisma.PrismaPromise<GetProductVariantAggregateType<T>>

    /**
     * Group by ProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductVariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductVariantGroupByArgs['orderBy'] }
        : { orderBy?: ProductVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductVariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductVariant model
   */
  readonly fields: ProductVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductVariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orderItems<T extends ProductVariant$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariant$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryUnits<T extends ProductVariant$inventoryUnitsArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariant$inventoryUnitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryUnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskItems<T extends ProductVariant$taskItemsArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariant$taskItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    allocations<T extends ProductVariant$allocationsArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariant$allocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductVariant model
   */
  interface ProductVariantFieldRefs {
    readonly id: FieldRef<"ProductVariant", 'String'>
    readonly productId: FieldRef<"ProductVariant", 'String'>
    readonly sku: FieldRef<"ProductVariant", 'String'>
    readonly upc: FieldRef<"ProductVariant", 'String'>
    readonly barcode: FieldRef<"ProductVariant", 'String'>
    readonly name: FieldRef<"ProductVariant", 'String'>
    readonly imageUrl: FieldRef<"ProductVariant", 'String'>
    readonly shopifyVariantId: FieldRef<"ProductVariant", 'String'>
    readonly costPrice: FieldRef<"ProductVariant", 'Decimal'>
    readonly sellingPrice: FieldRef<"ProductVariant", 'Decimal'>
    readonly weight: FieldRef<"ProductVariant", 'Decimal'>
    readonly trackLots: FieldRef<"ProductVariant", 'Boolean'>
    readonly trackExpiry: FieldRef<"ProductVariant", 'Boolean'>
    readonly createdAt: FieldRef<"ProductVariant", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductVariant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductVariant findUnique
   */
  export type ProductVariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant findUniqueOrThrow
   */
  export type ProductVariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant findFirst
   */
  export type ProductVariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariants.
     */
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant findFirstOrThrow
   */
  export type ProductVariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariants.
     */
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant findMany
   */
  export type ProductVariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariants to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant create
   */
  export type ProductVariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductVariant.
     */
    data: XOR<ProductVariantCreateInput, ProductVariantUncheckedCreateInput>
  }

  /**
   * ProductVariant createMany
   */
  export type ProductVariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductVariants.
     */
    data: ProductVariantCreateManyInput | ProductVariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductVariant createManyAndReturn
   */
  export type ProductVariantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * The data used to create many ProductVariants.
     */
    data: ProductVariantCreateManyInput | ProductVariantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductVariant update
   */
  export type ProductVariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductVariant.
     */
    data: XOR<ProductVariantUpdateInput, ProductVariantUncheckedUpdateInput>
    /**
     * Choose, which ProductVariant to update.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant updateMany
   */
  export type ProductVariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductVariants.
     */
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariants to update
     */
    where?: ProductVariantWhereInput
    /**
     * Limit how many ProductVariants to update.
     */
    limit?: number
  }

  /**
   * ProductVariant updateManyAndReturn
   */
  export type ProductVariantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * The data used to update ProductVariants.
     */
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariants to update
     */
    where?: ProductVariantWhereInput
    /**
     * Limit how many ProductVariants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductVariant upsert
   */
  export type ProductVariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductVariant to update in case it exists.
     */
    where: ProductVariantWhereUniqueInput
    /**
     * In case the ProductVariant found by the `where` argument doesn't exist, create a new ProductVariant with this data.
     */
    create: XOR<ProductVariantCreateInput, ProductVariantUncheckedCreateInput>
    /**
     * In case the ProductVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductVariantUpdateInput, ProductVariantUncheckedUpdateInput>
  }

  /**
   * ProductVariant delete
   */
  export type ProductVariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter which ProductVariant to delete.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant deleteMany
   */
  export type ProductVariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariants to delete
     */
    where?: ProductVariantWhereInput
    /**
     * Limit how many ProductVariants to delete.
     */
    limit?: number
  }

  /**
   * ProductVariant.orderItems
   */
  export type ProductVariant$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * ProductVariant.inventoryUnits
   */
  export type ProductVariant$inventoryUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUnit
     */
    select?: InventoryUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUnit
     */
    omit?: InventoryUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUnitInclude<ExtArgs> | null
    where?: InventoryUnitWhereInput
    orderBy?: InventoryUnitOrderByWithRelationInput | InventoryUnitOrderByWithRelationInput[]
    cursor?: InventoryUnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryUnitScalarFieldEnum | InventoryUnitScalarFieldEnum[]
  }

  /**
   * ProductVariant.taskItems
   */
  export type ProductVariant$taskItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskItem
     */
    select?: TaskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskItem
     */
    omit?: TaskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskItemInclude<ExtArgs> | null
    where?: TaskItemWhereInput
    orderBy?: TaskItemOrderByWithRelationInput | TaskItemOrderByWithRelationInput[]
    cursor?: TaskItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskItemScalarFieldEnum | TaskItemScalarFieldEnum[]
  }

  /**
   * ProductVariant.allocations
   */
  export type ProductVariant$allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allocation
     */
    omit?: AllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    where?: AllocationWhereInput
    orderBy?: AllocationOrderByWithRelationInput | AllocationOrderByWithRelationInput[]
    cursor?: AllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AllocationScalarFieldEnum | AllocationScalarFieldEnum[]
  }

  /**
   * ProductVariant without action
   */
  export type ProductVariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    pickSequence: number | null
  }

  export type LocationSumAggregateOutputType = {
    pickSequence: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    name: string | null
    barcode: string | null
    type: $Enums.LocationType | null
    zone: string | null
    aisle: string | null
    rack: string | null
    shelf: string | null
    bin: string | null
    pickSequence: number | null
    isPickable: boolean | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    barcode: string | null
    type: $Enums.LocationType | null
    zone: string | null
    aisle: string | null
    rack: string | null
    shelf: string | null
    bin: string | null
    pickSequence: number | null
    isPickable: boolean | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    name: number
    barcode: number
    type: number
    zone: number
    aisle: number
    rack: number
    shelf: number
    bin: number
    pickSequence: number
    isPickable: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    pickSequence?: true
  }

  export type LocationSumAggregateInputType = {
    pickSequence?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    name?: true
    barcode?: true
    type?: true
    zone?: true
    aisle?: true
    rack?: true
    shelf?: true
    bin?: true
    pickSequence?: true
    isPickable?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    name?: true
    barcode?: true
    type?: true
    zone?: true
    aisle?: true
    rack?: true
    shelf?: true
    bin?: true
    pickSequence?: true
    isPickable?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    name?: true
    barcode?: true
    type?: true
    zone?: true
    aisle?: true
    rack?: true
    shelf?: true
    bin?: true
    pickSequence?: true
    isPickable?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    name: string
    barcode: string | null
    type: $Enums.LocationType
    zone: string | null
    aisle: string | null
    rack: string | null
    shelf: string | null
    bin: string | null
    pickSequence: number | null
    isPickable: boolean
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    barcode?: boolean
    type?: boolean
    zone?: boolean
    aisle?: boolean
    rack?: boolean
    shelf?: boolean
    bin?: boolean
    pickSequence?: boolean
    isPickable?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inventoryUnits?: boolean | Location$inventoryUnitsArgs<ExtArgs>
    taskItems?: boolean | Location$taskItemsArgs<ExtArgs>
    allocations?: boolean | Location$allocationsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    barcode?: boolean
    type?: boolean
    zone?: boolean
    aisle?: boolean
    rack?: boolean
    shelf?: boolean
    bin?: boolean
    pickSequence?: boolean
    isPickable?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    barcode?: boolean
    type?: boolean
    zone?: boolean
    aisle?: boolean
    rack?: boolean
    shelf?: boolean
    bin?: boolean
    pickSequence?: boolean
    isPickable?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    name?: boolean
    barcode?: boolean
    type?: boolean
    zone?: boolean
    aisle?: boolean
    rack?: boolean
    shelf?: boolean
    bin?: boolean
    pickSequence?: boolean
    isPickable?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "barcode" | "type" | "zone" | "aisle" | "rack" | "shelf" | "bin" | "pickSequence" | "isPickable" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryUnits?: boolean | Location$inventoryUnitsArgs<ExtArgs>
    taskItems?: boolean | Location$taskItemsArgs<ExtArgs>
    allocations?: boolean | Location$allocationsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      inventoryUnits: Prisma.$InventoryUnitPayload<ExtArgs>[]
      taskItems: Prisma.$TaskItemPayload<ExtArgs>[]
      allocations: Prisma.$AllocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      barcode: string | null
      type: $Enums.LocationType
      zone: string | null
      aisle: string | null
      rack: string | null
      shelf: string | null
      bin: string | null
      pickSequence: number | null
      isPickable: boolean
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventoryUnits<T extends Location$inventoryUnitsArgs<ExtArgs> = {}>(args?: Subset<T, Location$inventoryUnitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryUnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskItems<T extends Location$taskItemsArgs<ExtArgs> = {}>(args?: Subset<T, Location$taskItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    allocations<T extends Location$allocationsArgs<ExtArgs> = {}>(args?: Subset<T, Location$allocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
    readonly barcode: FieldRef<"Location", 'String'>
    readonly type: FieldRef<"Location", 'LocationType'>
    readonly zone: FieldRef<"Location", 'String'>
    readonly aisle: FieldRef<"Location", 'String'>
    readonly rack: FieldRef<"Location", 'String'>
    readonly shelf: FieldRef<"Location", 'String'>
    readonly bin: FieldRef<"Location", 'String'>
    readonly pickSequence: FieldRef<"Location", 'Int'>
    readonly isPickable: FieldRef<"Location", 'Boolean'>
    readonly active: FieldRef<"Location", 'Boolean'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.inventoryUnits
   */
  export type Location$inventoryUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUnit
     */
    select?: InventoryUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUnit
     */
    omit?: InventoryUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUnitInclude<ExtArgs> | null
    where?: InventoryUnitWhereInput
    orderBy?: InventoryUnitOrderByWithRelationInput | InventoryUnitOrderByWithRelationInput[]
    cursor?: InventoryUnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryUnitScalarFieldEnum | InventoryUnitScalarFieldEnum[]
  }

  /**
   * Location.taskItems
   */
  export type Location$taskItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskItem
     */
    select?: TaskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskItem
     */
    omit?: TaskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskItemInclude<ExtArgs> | null
    where?: TaskItemWhereInput
    orderBy?: TaskItemOrderByWithRelationInput | TaskItemOrderByWithRelationInput[]
    cursor?: TaskItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskItemScalarFieldEnum | TaskItemScalarFieldEnum[]
  }

  /**
   * Location.allocations
   */
  export type Location$allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allocation
     */
    omit?: AllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    where?: AllocationWhereInput
    orderBy?: AllocationOrderByWithRelationInput | AllocationOrderByWithRelationInput[]
    cursor?: AllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AllocationScalarFieldEnum | AllocationScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model InventoryUnit
   */

  export type AggregateInventoryUnit = {
    _count: InventoryUnitCountAggregateOutputType | null
    _avg: InventoryUnitAvgAggregateOutputType | null
    _sum: InventoryUnitSumAggregateOutputType | null
    _min: InventoryUnitMinAggregateOutputType | null
    _max: InventoryUnitMaxAggregateOutputType | null
  }

  export type InventoryUnitAvgAggregateOutputType = {
    quantity: number | null
    unitCost: Decimal | null
  }

  export type InventoryUnitSumAggregateOutputType = {
    quantity: number | null
    unitCost: Decimal | null
  }

  export type InventoryUnitMinAggregateOutputType = {
    id: string | null
    productVariantId: string | null
    locationId: string | null
    quantity: number | null
    status: $Enums.InventoryStatus | null
    lotNumber: string | null
    expiryDate: Date | null
    receivedAt: Date | null
    receivedFrom: string | null
    unitCost: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryUnitMaxAggregateOutputType = {
    id: string | null
    productVariantId: string | null
    locationId: string | null
    quantity: number | null
    status: $Enums.InventoryStatus | null
    lotNumber: string | null
    expiryDate: Date | null
    receivedAt: Date | null
    receivedFrom: string | null
    unitCost: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryUnitCountAggregateOutputType = {
    id: number
    productVariantId: number
    locationId: number
    quantity: number
    status: number
    lotNumber: number
    expiryDate: number
    receivedAt: number
    receivedFrom: number
    unitCost: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryUnitAvgAggregateInputType = {
    quantity?: true
    unitCost?: true
  }

  export type InventoryUnitSumAggregateInputType = {
    quantity?: true
    unitCost?: true
  }

  export type InventoryUnitMinAggregateInputType = {
    id?: true
    productVariantId?: true
    locationId?: true
    quantity?: true
    status?: true
    lotNumber?: true
    expiryDate?: true
    receivedAt?: true
    receivedFrom?: true
    unitCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryUnitMaxAggregateInputType = {
    id?: true
    productVariantId?: true
    locationId?: true
    quantity?: true
    status?: true
    lotNumber?: true
    expiryDate?: true
    receivedAt?: true
    receivedFrom?: true
    unitCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryUnitCountAggregateInputType = {
    id?: true
    productVariantId?: true
    locationId?: true
    quantity?: true
    status?: true
    lotNumber?: true
    expiryDate?: true
    receivedAt?: true
    receivedFrom?: true
    unitCost?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryUnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryUnit to aggregate.
     */
    where?: InventoryUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUnits to fetch.
     */
    orderBy?: InventoryUnitOrderByWithRelationInput | InventoryUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryUnits
    **/
    _count?: true | InventoryUnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryUnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryUnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryUnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryUnitMaxAggregateInputType
  }

  export type GetInventoryUnitAggregateType<T extends InventoryUnitAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryUnit[P]>
      : GetScalarType<T[P], AggregateInventoryUnit[P]>
  }




  export type InventoryUnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryUnitWhereInput
    orderBy?: InventoryUnitOrderByWithAggregationInput | InventoryUnitOrderByWithAggregationInput[]
    by: InventoryUnitScalarFieldEnum[] | InventoryUnitScalarFieldEnum
    having?: InventoryUnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryUnitCountAggregateInputType | true
    _avg?: InventoryUnitAvgAggregateInputType
    _sum?: InventoryUnitSumAggregateInputType
    _min?: InventoryUnitMinAggregateInputType
    _max?: InventoryUnitMaxAggregateInputType
  }

  export type InventoryUnitGroupByOutputType = {
    id: string
    productVariantId: string
    locationId: string
    quantity: number
    status: $Enums.InventoryStatus
    lotNumber: string | null
    expiryDate: Date | null
    receivedAt: Date
    receivedFrom: string | null
    unitCost: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: InventoryUnitCountAggregateOutputType | null
    _avg: InventoryUnitAvgAggregateOutputType | null
    _sum: InventoryUnitSumAggregateOutputType | null
    _min: InventoryUnitMinAggregateOutputType | null
    _max: InventoryUnitMaxAggregateOutputType | null
  }

  type GetInventoryUnitGroupByPayload<T extends InventoryUnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryUnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryUnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryUnitGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryUnitGroupByOutputType[P]>
        }
      >
    >


  export type InventoryUnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productVariantId?: boolean
    locationId?: boolean
    quantity?: boolean
    status?: boolean
    lotNumber?: boolean
    expiryDate?: boolean
    receivedAt?: boolean
    receivedFrom?: boolean
    unitCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productVariant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    allocations?: boolean | InventoryUnit$allocationsArgs<ExtArgs>
    _count?: boolean | InventoryUnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryUnit"]>

  export type InventoryUnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productVariantId?: boolean
    locationId?: boolean
    quantity?: boolean
    status?: boolean
    lotNumber?: boolean
    expiryDate?: boolean
    receivedAt?: boolean
    receivedFrom?: boolean
    unitCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productVariant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryUnit"]>

  export type InventoryUnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productVariantId?: boolean
    locationId?: boolean
    quantity?: boolean
    status?: boolean
    lotNumber?: boolean
    expiryDate?: boolean
    receivedAt?: boolean
    receivedFrom?: boolean
    unitCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productVariant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryUnit"]>

  export type InventoryUnitSelectScalar = {
    id?: boolean
    productVariantId?: boolean
    locationId?: boolean
    quantity?: boolean
    status?: boolean
    lotNumber?: boolean
    expiryDate?: boolean
    receivedAt?: boolean
    receivedFrom?: boolean
    unitCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryUnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productVariantId" | "locationId" | "quantity" | "status" | "lotNumber" | "expiryDate" | "receivedAt" | "receivedFrom" | "unitCost" | "createdAt" | "updatedAt", ExtArgs["result"]["inventoryUnit"]>
  export type InventoryUnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productVariant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    allocations?: boolean | InventoryUnit$allocationsArgs<ExtArgs>
    _count?: boolean | InventoryUnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InventoryUnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productVariant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type InventoryUnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productVariant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $InventoryUnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryUnit"
    objects: {
      productVariant: Prisma.$ProductVariantPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
      allocations: Prisma.$AllocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productVariantId: string
      locationId: string
      quantity: number
      status: $Enums.InventoryStatus
      lotNumber: string | null
      expiryDate: Date | null
      receivedAt: Date
      receivedFrom: string | null
      unitCost: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventoryUnit"]>
    composites: {}
  }

  type InventoryUnitGetPayload<S extends boolean | null | undefined | InventoryUnitDefaultArgs> = $Result.GetResult<Prisma.$InventoryUnitPayload, S>

  type InventoryUnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryUnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryUnitCountAggregateInputType | true
    }

  export interface InventoryUnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryUnit'], meta: { name: 'InventoryUnit' } }
    /**
     * Find zero or one InventoryUnit that matches the filter.
     * @param {InventoryUnitFindUniqueArgs} args - Arguments to find a InventoryUnit
     * @example
     * // Get one InventoryUnit
     * const inventoryUnit = await prisma.inventoryUnit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryUnitFindUniqueArgs>(args: SelectSubset<T, InventoryUnitFindUniqueArgs<ExtArgs>>): Prisma__InventoryUnitClient<$Result.GetResult<Prisma.$InventoryUnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryUnit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryUnitFindUniqueOrThrowArgs} args - Arguments to find a InventoryUnit
     * @example
     * // Get one InventoryUnit
     * const inventoryUnit = await prisma.inventoryUnit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryUnitFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryUnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryUnitClient<$Result.GetResult<Prisma.$InventoryUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryUnit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUnitFindFirstArgs} args - Arguments to find a InventoryUnit
     * @example
     * // Get one InventoryUnit
     * const inventoryUnit = await prisma.inventoryUnit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryUnitFindFirstArgs>(args?: SelectSubset<T, InventoryUnitFindFirstArgs<ExtArgs>>): Prisma__InventoryUnitClient<$Result.GetResult<Prisma.$InventoryUnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryUnit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUnitFindFirstOrThrowArgs} args - Arguments to find a InventoryUnit
     * @example
     * // Get one InventoryUnit
     * const inventoryUnit = await prisma.inventoryUnit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryUnitFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryUnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryUnitClient<$Result.GetResult<Prisma.$InventoryUnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryUnits
     * const inventoryUnits = await prisma.inventoryUnit.findMany()
     * 
     * // Get first 10 InventoryUnits
     * const inventoryUnits = await prisma.inventoryUnit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryUnitWithIdOnly = await prisma.inventoryUnit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryUnitFindManyArgs>(args?: SelectSubset<T, InventoryUnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryUnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryUnit.
     * @param {InventoryUnitCreateArgs} args - Arguments to create a InventoryUnit.
     * @example
     * // Create one InventoryUnit
     * const InventoryUnit = await prisma.inventoryUnit.create({
     *   data: {
     *     // ... data to create a InventoryUnit
     *   }
     * })
     * 
     */
    create<T extends InventoryUnitCreateArgs>(args: SelectSubset<T, InventoryUnitCreateArgs<ExtArgs>>): Prisma__InventoryUnitClient<$Result.GetResult<Prisma.$InventoryUnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryUnits.
     * @param {InventoryUnitCreateManyArgs} args - Arguments to create many InventoryUnits.
     * @example
     * // Create many InventoryUnits
     * const inventoryUnit = await prisma.inventoryUnit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryUnitCreateManyArgs>(args?: SelectSubset<T, InventoryUnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryUnits and returns the data saved in the database.
     * @param {InventoryUnitCreateManyAndReturnArgs} args - Arguments to create many InventoryUnits.
     * @example
     * // Create many InventoryUnits
     * const inventoryUnit = await prisma.inventoryUnit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryUnits and only return the `id`
     * const inventoryUnitWithIdOnly = await prisma.inventoryUnit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryUnitCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryUnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryUnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryUnit.
     * @param {InventoryUnitDeleteArgs} args - Arguments to delete one InventoryUnit.
     * @example
     * // Delete one InventoryUnit
     * const InventoryUnit = await prisma.inventoryUnit.delete({
     *   where: {
     *     // ... filter to delete one InventoryUnit
     *   }
     * })
     * 
     */
    delete<T extends InventoryUnitDeleteArgs>(args: SelectSubset<T, InventoryUnitDeleteArgs<ExtArgs>>): Prisma__InventoryUnitClient<$Result.GetResult<Prisma.$InventoryUnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryUnit.
     * @param {InventoryUnitUpdateArgs} args - Arguments to update one InventoryUnit.
     * @example
     * // Update one InventoryUnit
     * const inventoryUnit = await prisma.inventoryUnit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryUnitUpdateArgs>(args: SelectSubset<T, InventoryUnitUpdateArgs<ExtArgs>>): Prisma__InventoryUnitClient<$Result.GetResult<Prisma.$InventoryUnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryUnits.
     * @param {InventoryUnitDeleteManyArgs} args - Arguments to filter InventoryUnits to delete.
     * @example
     * // Delete a few InventoryUnits
     * const { count } = await prisma.inventoryUnit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryUnitDeleteManyArgs>(args?: SelectSubset<T, InventoryUnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryUnits
     * const inventoryUnit = await prisma.inventoryUnit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryUnitUpdateManyArgs>(args: SelectSubset<T, InventoryUnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryUnits and returns the data updated in the database.
     * @param {InventoryUnitUpdateManyAndReturnArgs} args - Arguments to update many InventoryUnits.
     * @example
     * // Update many InventoryUnits
     * const inventoryUnit = await prisma.inventoryUnit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryUnits and only return the `id`
     * const inventoryUnitWithIdOnly = await prisma.inventoryUnit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryUnitUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryUnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryUnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryUnit.
     * @param {InventoryUnitUpsertArgs} args - Arguments to update or create a InventoryUnit.
     * @example
     * // Update or create a InventoryUnit
     * const inventoryUnit = await prisma.inventoryUnit.upsert({
     *   create: {
     *     // ... data to create a InventoryUnit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryUnit we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUnitUpsertArgs>(args: SelectSubset<T, InventoryUnitUpsertArgs<ExtArgs>>): Prisma__InventoryUnitClient<$Result.GetResult<Prisma.$InventoryUnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUnitCountArgs} args - Arguments to filter InventoryUnits to count.
     * @example
     * // Count the number of InventoryUnits
     * const count = await prisma.inventoryUnit.count({
     *   where: {
     *     // ... the filter for the InventoryUnits we want to count
     *   }
     * })
    **/
    count<T extends InventoryUnitCountArgs>(
      args?: Subset<T, InventoryUnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryUnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryUnitAggregateArgs>(args: Subset<T, InventoryUnitAggregateArgs>): Prisma.PrismaPromise<GetInventoryUnitAggregateType<T>>

    /**
     * Group by InventoryUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryUnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryUnitGroupByArgs['orderBy'] }
        : { orderBy?: InventoryUnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryUnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryUnit model
   */
  readonly fields: InventoryUnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryUnit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryUnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productVariant<T extends ProductVariantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariantDefaultArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    allocations<T extends InventoryUnit$allocationsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryUnit$allocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryUnit model
   */
  interface InventoryUnitFieldRefs {
    readonly id: FieldRef<"InventoryUnit", 'String'>
    readonly productVariantId: FieldRef<"InventoryUnit", 'String'>
    readonly locationId: FieldRef<"InventoryUnit", 'String'>
    readonly quantity: FieldRef<"InventoryUnit", 'Int'>
    readonly status: FieldRef<"InventoryUnit", 'InventoryStatus'>
    readonly lotNumber: FieldRef<"InventoryUnit", 'String'>
    readonly expiryDate: FieldRef<"InventoryUnit", 'DateTime'>
    readonly receivedAt: FieldRef<"InventoryUnit", 'DateTime'>
    readonly receivedFrom: FieldRef<"InventoryUnit", 'String'>
    readonly unitCost: FieldRef<"InventoryUnit", 'Decimal'>
    readonly createdAt: FieldRef<"InventoryUnit", 'DateTime'>
    readonly updatedAt: FieldRef<"InventoryUnit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryUnit findUnique
   */
  export type InventoryUnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUnit
     */
    select?: InventoryUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUnit
     */
    omit?: InventoryUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUnitInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUnit to fetch.
     */
    where: InventoryUnitWhereUniqueInput
  }

  /**
   * InventoryUnit findUniqueOrThrow
   */
  export type InventoryUnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUnit
     */
    select?: InventoryUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUnit
     */
    omit?: InventoryUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUnitInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUnit to fetch.
     */
    where: InventoryUnitWhereUniqueInput
  }

  /**
   * InventoryUnit findFirst
   */
  export type InventoryUnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUnit
     */
    select?: InventoryUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUnit
     */
    omit?: InventoryUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUnitInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUnit to fetch.
     */
    where?: InventoryUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUnits to fetch.
     */
    orderBy?: InventoryUnitOrderByWithRelationInput | InventoryUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryUnits.
     */
    cursor?: InventoryUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryUnits.
     */
    distinct?: InventoryUnitScalarFieldEnum | InventoryUnitScalarFieldEnum[]
  }

  /**
   * InventoryUnit findFirstOrThrow
   */
  export type InventoryUnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUnit
     */
    select?: InventoryUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUnit
     */
    omit?: InventoryUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUnitInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUnit to fetch.
     */
    where?: InventoryUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUnits to fetch.
     */
    orderBy?: InventoryUnitOrderByWithRelationInput | InventoryUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryUnits.
     */
    cursor?: InventoryUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryUnits.
     */
    distinct?: InventoryUnitScalarFieldEnum | InventoryUnitScalarFieldEnum[]
  }

  /**
   * InventoryUnit findMany
   */
  export type InventoryUnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUnit
     */
    select?: InventoryUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUnit
     */
    omit?: InventoryUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUnitInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUnits to fetch.
     */
    where?: InventoryUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUnits to fetch.
     */
    orderBy?: InventoryUnitOrderByWithRelationInput | InventoryUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryUnits.
     */
    cursor?: InventoryUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUnits.
     */
    skip?: number
    distinct?: InventoryUnitScalarFieldEnum | InventoryUnitScalarFieldEnum[]
  }

  /**
   * InventoryUnit create
   */
  export type InventoryUnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUnit
     */
    select?: InventoryUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUnit
     */
    omit?: InventoryUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUnitInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryUnit.
     */
    data: XOR<InventoryUnitCreateInput, InventoryUnitUncheckedCreateInput>
  }

  /**
   * InventoryUnit createMany
   */
  export type InventoryUnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryUnits.
     */
    data: InventoryUnitCreateManyInput | InventoryUnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryUnit createManyAndReturn
   */
  export type InventoryUnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUnit
     */
    select?: InventoryUnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUnit
     */
    omit?: InventoryUnitOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryUnits.
     */
    data: InventoryUnitCreateManyInput | InventoryUnitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUnitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryUnit update
   */
  export type InventoryUnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUnit
     */
    select?: InventoryUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUnit
     */
    omit?: InventoryUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUnitInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryUnit.
     */
    data: XOR<InventoryUnitUpdateInput, InventoryUnitUncheckedUpdateInput>
    /**
     * Choose, which InventoryUnit to update.
     */
    where: InventoryUnitWhereUniqueInput
  }

  /**
   * InventoryUnit updateMany
   */
  export type InventoryUnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryUnits.
     */
    data: XOR<InventoryUnitUpdateManyMutationInput, InventoryUnitUncheckedUpdateManyInput>
    /**
     * Filter which InventoryUnits to update
     */
    where?: InventoryUnitWhereInput
    /**
     * Limit how many InventoryUnits to update.
     */
    limit?: number
  }

  /**
   * InventoryUnit updateManyAndReturn
   */
  export type InventoryUnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUnit
     */
    select?: InventoryUnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUnit
     */
    omit?: InventoryUnitOmit<ExtArgs> | null
    /**
     * The data used to update InventoryUnits.
     */
    data: XOR<InventoryUnitUpdateManyMutationInput, InventoryUnitUncheckedUpdateManyInput>
    /**
     * Filter which InventoryUnits to update
     */
    where?: InventoryUnitWhereInput
    /**
     * Limit how many InventoryUnits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUnitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryUnit upsert
   */
  export type InventoryUnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUnit
     */
    select?: InventoryUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUnit
     */
    omit?: InventoryUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUnitInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryUnit to update in case it exists.
     */
    where: InventoryUnitWhereUniqueInput
    /**
     * In case the InventoryUnit found by the `where` argument doesn't exist, create a new InventoryUnit with this data.
     */
    create: XOR<InventoryUnitCreateInput, InventoryUnitUncheckedCreateInput>
    /**
     * In case the InventoryUnit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUnitUpdateInput, InventoryUnitUncheckedUpdateInput>
  }

  /**
   * InventoryUnit delete
   */
  export type InventoryUnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUnit
     */
    select?: InventoryUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUnit
     */
    omit?: InventoryUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUnitInclude<ExtArgs> | null
    /**
     * Filter which InventoryUnit to delete.
     */
    where: InventoryUnitWhereUniqueInput
  }

  /**
   * InventoryUnit deleteMany
   */
  export type InventoryUnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryUnits to delete
     */
    where?: InventoryUnitWhereInput
    /**
     * Limit how many InventoryUnits to delete.
     */
    limit?: number
  }

  /**
   * InventoryUnit.allocations
   */
  export type InventoryUnit$allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allocation
     */
    omit?: AllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    where?: AllocationWhereInput
    orderBy?: AllocationOrderByWithRelationInput | AllocationOrderByWithRelationInput[]
    cursor?: AllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AllocationScalarFieldEnum | AllocationScalarFieldEnum[]
  }

  /**
   * InventoryUnit without action
   */
  export type InventoryUnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUnit
     */
    select?: InventoryUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUnit
     */
    omit?: InventoryUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUnitInclude<ExtArgs> | null
  }


  /**
   * Model Allocation
   */

  export type AggregateAllocation = {
    _count: AllocationCountAggregateOutputType | null
    _avg: AllocationAvgAggregateOutputType | null
    _sum: AllocationSumAggregateOutputType | null
    _min: AllocationMinAggregateOutputType | null
    _max: AllocationMaxAggregateOutputType | null
  }

  export type AllocationAvgAggregateOutputType = {
    quantity: number | null
  }

  export type AllocationSumAggregateOutputType = {
    quantity: number | null
  }

  export type AllocationMinAggregateOutputType = {
    id: string | null
    inventoryUnitId: string | null
    orderId: string | null
    orderItemId: string | null
    productVariantId: string | null
    locationId: string | null
    quantity: number | null
    lotNumber: string | null
    status: $Enums.AllocationStatus | null
    allocatedAt: Date | null
    releasedAt: Date | null
    pickedAt: Date | null
    taskItemId: string | null
  }

  export type AllocationMaxAggregateOutputType = {
    id: string | null
    inventoryUnitId: string | null
    orderId: string | null
    orderItemId: string | null
    productVariantId: string | null
    locationId: string | null
    quantity: number | null
    lotNumber: string | null
    status: $Enums.AllocationStatus | null
    allocatedAt: Date | null
    releasedAt: Date | null
    pickedAt: Date | null
    taskItemId: string | null
  }

  export type AllocationCountAggregateOutputType = {
    id: number
    inventoryUnitId: number
    orderId: number
    orderItemId: number
    productVariantId: number
    locationId: number
    quantity: number
    lotNumber: number
    status: number
    allocatedAt: number
    releasedAt: number
    pickedAt: number
    taskItemId: number
    _all: number
  }


  export type AllocationAvgAggregateInputType = {
    quantity?: true
  }

  export type AllocationSumAggregateInputType = {
    quantity?: true
  }

  export type AllocationMinAggregateInputType = {
    id?: true
    inventoryUnitId?: true
    orderId?: true
    orderItemId?: true
    productVariantId?: true
    locationId?: true
    quantity?: true
    lotNumber?: true
    status?: true
    allocatedAt?: true
    releasedAt?: true
    pickedAt?: true
    taskItemId?: true
  }

  export type AllocationMaxAggregateInputType = {
    id?: true
    inventoryUnitId?: true
    orderId?: true
    orderItemId?: true
    productVariantId?: true
    locationId?: true
    quantity?: true
    lotNumber?: true
    status?: true
    allocatedAt?: true
    releasedAt?: true
    pickedAt?: true
    taskItemId?: true
  }

  export type AllocationCountAggregateInputType = {
    id?: true
    inventoryUnitId?: true
    orderId?: true
    orderItemId?: true
    productVariantId?: true
    locationId?: true
    quantity?: true
    lotNumber?: true
    status?: true
    allocatedAt?: true
    releasedAt?: true
    pickedAt?: true
    taskItemId?: true
    _all?: true
  }

  export type AllocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Allocation to aggregate.
     */
    where?: AllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allocations to fetch.
     */
    orderBy?: AllocationOrderByWithRelationInput | AllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Allocations
    **/
    _count?: true | AllocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AllocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AllocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AllocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AllocationMaxAggregateInputType
  }

  export type GetAllocationAggregateType<T extends AllocationAggregateArgs> = {
        [P in keyof T & keyof AggregateAllocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAllocation[P]>
      : GetScalarType<T[P], AggregateAllocation[P]>
  }




  export type AllocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllocationWhereInput
    orderBy?: AllocationOrderByWithAggregationInput | AllocationOrderByWithAggregationInput[]
    by: AllocationScalarFieldEnum[] | AllocationScalarFieldEnum
    having?: AllocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AllocationCountAggregateInputType | true
    _avg?: AllocationAvgAggregateInputType
    _sum?: AllocationSumAggregateInputType
    _min?: AllocationMinAggregateInputType
    _max?: AllocationMaxAggregateInputType
  }

  export type AllocationGroupByOutputType = {
    id: string
    inventoryUnitId: string
    orderId: string
    orderItemId: string | null
    productVariantId: string
    locationId: string
    quantity: number
    lotNumber: string | null
    status: $Enums.AllocationStatus
    allocatedAt: Date
    releasedAt: Date | null
    pickedAt: Date | null
    taskItemId: string | null
    _count: AllocationCountAggregateOutputType | null
    _avg: AllocationAvgAggregateOutputType | null
    _sum: AllocationSumAggregateOutputType | null
    _min: AllocationMinAggregateOutputType | null
    _max: AllocationMaxAggregateOutputType | null
  }

  type GetAllocationGroupByPayload<T extends AllocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AllocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AllocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AllocationGroupByOutputType[P]>
            : GetScalarType<T[P], AllocationGroupByOutputType[P]>
        }
      >
    >


  export type AllocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inventoryUnitId?: boolean
    orderId?: boolean
    orderItemId?: boolean
    productVariantId?: boolean
    locationId?: boolean
    quantity?: boolean
    lotNumber?: boolean
    status?: boolean
    allocatedAt?: boolean
    releasedAt?: boolean
    pickedAt?: boolean
    taskItemId?: boolean
    inventoryUnit?: boolean | InventoryUnitDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    orderItem?: boolean | Allocation$orderItemArgs<ExtArgs>
    productVariant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    taskItem?: boolean | Allocation$taskItemArgs<ExtArgs>
  }, ExtArgs["result"]["allocation"]>

  export type AllocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inventoryUnitId?: boolean
    orderId?: boolean
    orderItemId?: boolean
    productVariantId?: boolean
    locationId?: boolean
    quantity?: boolean
    lotNumber?: boolean
    status?: boolean
    allocatedAt?: boolean
    releasedAt?: boolean
    pickedAt?: boolean
    taskItemId?: boolean
    inventoryUnit?: boolean | InventoryUnitDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    orderItem?: boolean | Allocation$orderItemArgs<ExtArgs>
    productVariant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    taskItem?: boolean | Allocation$taskItemArgs<ExtArgs>
  }, ExtArgs["result"]["allocation"]>

  export type AllocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inventoryUnitId?: boolean
    orderId?: boolean
    orderItemId?: boolean
    productVariantId?: boolean
    locationId?: boolean
    quantity?: boolean
    lotNumber?: boolean
    status?: boolean
    allocatedAt?: boolean
    releasedAt?: boolean
    pickedAt?: boolean
    taskItemId?: boolean
    inventoryUnit?: boolean | InventoryUnitDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    orderItem?: boolean | Allocation$orderItemArgs<ExtArgs>
    productVariant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    taskItem?: boolean | Allocation$taskItemArgs<ExtArgs>
  }, ExtArgs["result"]["allocation"]>

  export type AllocationSelectScalar = {
    id?: boolean
    inventoryUnitId?: boolean
    orderId?: boolean
    orderItemId?: boolean
    productVariantId?: boolean
    locationId?: boolean
    quantity?: boolean
    lotNumber?: boolean
    status?: boolean
    allocatedAt?: boolean
    releasedAt?: boolean
    pickedAt?: boolean
    taskItemId?: boolean
  }

  export type AllocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inventoryUnitId" | "orderId" | "orderItemId" | "productVariantId" | "locationId" | "quantity" | "lotNumber" | "status" | "allocatedAt" | "releasedAt" | "pickedAt" | "taskItemId", ExtArgs["result"]["allocation"]>
  export type AllocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryUnit?: boolean | InventoryUnitDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    orderItem?: boolean | Allocation$orderItemArgs<ExtArgs>
    productVariant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    taskItem?: boolean | Allocation$taskItemArgs<ExtArgs>
  }
  export type AllocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryUnit?: boolean | InventoryUnitDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    orderItem?: boolean | Allocation$orderItemArgs<ExtArgs>
    productVariant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    taskItem?: boolean | Allocation$taskItemArgs<ExtArgs>
  }
  export type AllocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryUnit?: boolean | InventoryUnitDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    orderItem?: boolean | Allocation$orderItemArgs<ExtArgs>
    productVariant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    taskItem?: boolean | Allocation$taskItemArgs<ExtArgs>
  }

  export type $AllocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Allocation"
    objects: {
      inventoryUnit: Prisma.$InventoryUnitPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs>
      orderItem: Prisma.$OrderItemPayload<ExtArgs> | null
      productVariant: Prisma.$ProductVariantPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
      taskItem: Prisma.$TaskItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inventoryUnitId: string
      orderId: string
      orderItemId: string | null
      productVariantId: string
      locationId: string
      quantity: number
      lotNumber: string | null
      status: $Enums.AllocationStatus
      allocatedAt: Date
      releasedAt: Date | null
      pickedAt: Date | null
      taskItemId: string | null
    }, ExtArgs["result"]["allocation"]>
    composites: {}
  }

  type AllocationGetPayload<S extends boolean | null | undefined | AllocationDefaultArgs> = $Result.GetResult<Prisma.$AllocationPayload, S>

  type AllocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AllocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AllocationCountAggregateInputType | true
    }

  export interface AllocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Allocation'], meta: { name: 'Allocation' } }
    /**
     * Find zero or one Allocation that matches the filter.
     * @param {AllocationFindUniqueArgs} args - Arguments to find a Allocation
     * @example
     * // Get one Allocation
     * const allocation = await prisma.allocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AllocationFindUniqueArgs>(args: SelectSubset<T, AllocationFindUniqueArgs<ExtArgs>>): Prisma__AllocationClient<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Allocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AllocationFindUniqueOrThrowArgs} args - Arguments to find a Allocation
     * @example
     * // Get one Allocation
     * const allocation = await prisma.allocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AllocationFindUniqueOrThrowArgs>(args: SelectSubset<T, AllocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AllocationClient<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Allocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationFindFirstArgs} args - Arguments to find a Allocation
     * @example
     * // Get one Allocation
     * const allocation = await prisma.allocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AllocationFindFirstArgs>(args?: SelectSubset<T, AllocationFindFirstArgs<ExtArgs>>): Prisma__AllocationClient<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Allocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationFindFirstOrThrowArgs} args - Arguments to find a Allocation
     * @example
     * // Get one Allocation
     * const allocation = await prisma.allocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AllocationFindFirstOrThrowArgs>(args?: SelectSubset<T, AllocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AllocationClient<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Allocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Allocations
     * const allocations = await prisma.allocation.findMany()
     * 
     * // Get first 10 Allocations
     * const allocations = await prisma.allocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const allocationWithIdOnly = await prisma.allocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AllocationFindManyArgs>(args?: SelectSubset<T, AllocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Allocation.
     * @param {AllocationCreateArgs} args - Arguments to create a Allocation.
     * @example
     * // Create one Allocation
     * const Allocation = await prisma.allocation.create({
     *   data: {
     *     // ... data to create a Allocation
     *   }
     * })
     * 
     */
    create<T extends AllocationCreateArgs>(args: SelectSubset<T, AllocationCreateArgs<ExtArgs>>): Prisma__AllocationClient<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Allocations.
     * @param {AllocationCreateManyArgs} args - Arguments to create many Allocations.
     * @example
     * // Create many Allocations
     * const allocation = await prisma.allocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AllocationCreateManyArgs>(args?: SelectSubset<T, AllocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Allocations and returns the data saved in the database.
     * @param {AllocationCreateManyAndReturnArgs} args - Arguments to create many Allocations.
     * @example
     * // Create many Allocations
     * const allocation = await prisma.allocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Allocations and only return the `id`
     * const allocationWithIdOnly = await prisma.allocation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AllocationCreateManyAndReturnArgs>(args?: SelectSubset<T, AllocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Allocation.
     * @param {AllocationDeleteArgs} args - Arguments to delete one Allocation.
     * @example
     * // Delete one Allocation
     * const Allocation = await prisma.allocation.delete({
     *   where: {
     *     // ... filter to delete one Allocation
     *   }
     * })
     * 
     */
    delete<T extends AllocationDeleteArgs>(args: SelectSubset<T, AllocationDeleteArgs<ExtArgs>>): Prisma__AllocationClient<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Allocation.
     * @param {AllocationUpdateArgs} args - Arguments to update one Allocation.
     * @example
     * // Update one Allocation
     * const allocation = await prisma.allocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AllocationUpdateArgs>(args: SelectSubset<T, AllocationUpdateArgs<ExtArgs>>): Prisma__AllocationClient<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Allocations.
     * @param {AllocationDeleteManyArgs} args - Arguments to filter Allocations to delete.
     * @example
     * // Delete a few Allocations
     * const { count } = await prisma.allocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AllocationDeleteManyArgs>(args?: SelectSubset<T, AllocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Allocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Allocations
     * const allocation = await prisma.allocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AllocationUpdateManyArgs>(args: SelectSubset<T, AllocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Allocations and returns the data updated in the database.
     * @param {AllocationUpdateManyAndReturnArgs} args - Arguments to update many Allocations.
     * @example
     * // Update many Allocations
     * const allocation = await prisma.allocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Allocations and only return the `id`
     * const allocationWithIdOnly = await prisma.allocation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AllocationUpdateManyAndReturnArgs>(args: SelectSubset<T, AllocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Allocation.
     * @param {AllocationUpsertArgs} args - Arguments to update or create a Allocation.
     * @example
     * // Update or create a Allocation
     * const allocation = await prisma.allocation.upsert({
     *   create: {
     *     // ... data to create a Allocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Allocation we want to update
     *   }
     * })
     */
    upsert<T extends AllocationUpsertArgs>(args: SelectSubset<T, AllocationUpsertArgs<ExtArgs>>): Prisma__AllocationClient<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Allocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationCountArgs} args - Arguments to filter Allocations to count.
     * @example
     * // Count the number of Allocations
     * const count = await prisma.allocation.count({
     *   where: {
     *     // ... the filter for the Allocations we want to count
     *   }
     * })
    **/
    count<T extends AllocationCountArgs>(
      args?: Subset<T, AllocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AllocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Allocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AllocationAggregateArgs>(args: Subset<T, AllocationAggregateArgs>): Prisma.PrismaPromise<GetAllocationAggregateType<T>>

    /**
     * Group by Allocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AllocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AllocationGroupByArgs['orderBy'] }
        : { orderBy?: AllocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AllocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAllocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Allocation model
   */
  readonly fields: AllocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Allocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AllocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventoryUnit<T extends InventoryUnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryUnitDefaultArgs<ExtArgs>>): Prisma__InventoryUnitClient<$Result.GetResult<Prisma.$InventoryUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orderItem<T extends Allocation$orderItemArgs<ExtArgs> = {}>(args?: Subset<T, Allocation$orderItemArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    productVariant<T extends ProductVariantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariantDefaultArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    taskItem<T extends Allocation$taskItemArgs<ExtArgs> = {}>(args?: Subset<T, Allocation$taskItemArgs<ExtArgs>>): Prisma__TaskItemClient<$Result.GetResult<Prisma.$TaskItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Allocation model
   */
  interface AllocationFieldRefs {
    readonly id: FieldRef<"Allocation", 'String'>
    readonly inventoryUnitId: FieldRef<"Allocation", 'String'>
    readonly orderId: FieldRef<"Allocation", 'String'>
    readonly orderItemId: FieldRef<"Allocation", 'String'>
    readonly productVariantId: FieldRef<"Allocation", 'String'>
    readonly locationId: FieldRef<"Allocation", 'String'>
    readonly quantity: FieldRef<"Allocation", 'Int'>
    readonly lotNumber: FieldRef<"Allocation", 'String'>
    readonly status: FieldRef<"Allocation", 'AllocationStatus'>
    readonly allocatedAt: FieldRef<"Allocation", 'DateTime'>
    readonly releasedAt: FieldRef<"Allocation", 'DateTime'>
    readonly pickedAt: FieldRef<"Allocation", 'DateTime'>
    readonly taskItemId: FieldRef<"Allocation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Allocation findUnique
   */
  export type AllocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allocation
     */
    omit?: AllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    /**
     * Filter, which Allocation to fetch.
     */
    where: AllocationWhereUniqueInput
  }

  /**
   * Allocation findUniqueOrThrow
   */
  export type AllocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allocation
     */
    omit?: AllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    /**
     * Filter, which Allocation to fetch.
     */
    where: AllocationWhereUniqueInput
  }

  /**
   * Allocation findFirst
   */
  export type AllocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allocation
     */
    omit?: AllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    /**
     * Filter, which Allocation to fetch.
     */
    where?: AllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allocations to fetch.
     */
    orderBy?: AllocationOrderByWithRelationInput | AllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Allocations.
     */
    cursor?: AllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Allocations.
     */
    distinct?: AllocationScalarFieldEnum | AllocationScalarFieldEnum[]
  }

  /**
   * Allocation findFirstOrThrow
   */
  export type AllocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allocation
     */
    omit?: AllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    /**
     * Filter, which Allocation to fetch.
     */
    where?: AllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allocations to fetch.
     */
    orderBy?: AllocationOrderByWithRelationInput | AllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Allocations.
     */
    cursor?: AllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Allocations.
     */
    distinct?: AllocationScalarFieldEnum | AllocationScalarFieldEnum[]
  }

  /**
   * Allocation findMany
   */
  export type AllocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allocation
     */
    omit?: AllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    /**
     * Filter, which Allocations to fetch.
     */
    where?: AllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allocations to fetch.
     */
    orderBy?: AllocationOrderByWithRelationInput | AllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Allocations.
     */
    cursor?: AllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allocations.
     */
    skip?: number
    distinct?: AllocationScalarFieldEnum | AllocationScalarFieldEnum[]
  }

  /**
   * Allocation create
   */
  export type AllocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allocation
     */
    omit?: AllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Allocation.
     */
    data: XOR<AllocationCreateInput, AllocationUncheckedCreateInput>
  }

  /**
   * Allocation createMany
   */
  export type AllocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Allocations.
     */
    data: AllocationCreateManyInput | AllocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Allocation createManyAndReturn
   */
  export type AllocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Allocation
     */
    omit?: AllocationOmit<ExtArgs> | null
    /**
     * The data used to create many Allocations.
     */
    data: AllocationCreateManyInput | AllocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Allocation update
   */
  export type AllocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allocation
     */
    omit?: AllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Allocation.
     */
    data: XOR<AllocationUpdateInput, AllocationUncheckedUpdateInput>
    /**
     * Choose, which Allocation to update.
     */
    where: AllocationWhereUniqueInput
  }

  /**
   * Allocation updateMany
   */
  export type AllocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Allocations.
     */
    data: XOR<AllocationUpdateManyMutationInput, AllocationUncheckedUpdateManyInput>
    /**
     * Filter which Allocations to update
     */
    where?: AllocationWhereInput
    /**
     * Limit how many Allocations to update.
     */
    limit?: number
  }

  /**
   * Allocation updateManyAndReturn
   */
  export type AllocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Allocation
     */
    omit?: AllocationOmit<ExtArgs> | null
    /**
     * The data used to update Allocations.
     */
    data: XOR<AllocationUpdateManyMutationInput, AllocationUncheckedUpdateManyInput>
    /**
     * Filter which Allocations to update
     */
    where?: AllocationWhereInput
    /**
     * Limit how many Allocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Allocation upsert
   */
  export type AllocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allocation
     */
    omit?: AllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Allocation to update in case it exists.
     */
    where: AllocationWhereUniqueInput
    /**
     * In case the Allocation found by the `where` argument doesn't exist, create a new Allocation with this data.
     */
    create: XOR<AllocationCreateInput, AllocationUncheckedCreateInput>
    /**
     * In case the Allocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AllocationUpdateInput, AllocationUncheckedUpdateInput>
  }

  /**
   * Allocation delete
   */
  export type AllocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allocation
     */
    omit?: AllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    /**
     * Filter which Allocation to delete.
     */
    where: AllocationWhereUniqueInput
  }

  /**
   * Allocation deleteMany
   */
  export type AllocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Allocations to delete
     */
    where?: AllocationWhereInput
    /**
     * Limit how many Allocations to delete.
     */
    limit?: number
  }

  /**
   * Allocation.orderItem
   */
  export type Allocation$orderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
  }

  /**
   * Allocation.taskItem
   */
  export type Allocation$taskItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskItem
     */
    select?: TaskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskItem
     */
    omit?: TaskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskItemInclude<ExtArgs> | null
    where?: TaskItemWhereInput
  }

  /**
   * Allocation without action
   */
  export type AllocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allocation
     */
    omit?: AllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    unmatchedItems: number | null
    totalAmount: Decimal | null
  }

  export type OrderSumAggregateOutputType = {
    unmatchedItems: number | null
    totalAmount: Decimal | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    shopifyOrderId: string | null
    customerId: string | null
    customerName: string | null
    customerEmail: string | null
    status: $Enums.OrderStatus | null
    paymentStatus: $Enums.PaymentStatus | null
    priority: $Enums.Priority | null
    holdReason: string | null
    holdAt: Date | null
    holdBy: string | null
    unmatchedItems: number | null
    totalAmount: Decimal | null
    warehouseId: string | null
    trackingNumber: string | null
    shippedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    shopifyOrderId: string | null
    customerId: string | null
    customerName: string | null
    customerEmail: string | null
    status: $Enums.OrderStatus | null
    paymentStatus: $Enums.PaymentStatus | null
    priority: $Enums.Priority | null
    holdReason: string | null
    holdAt: Date | null
    holdBy: string | null
    unmatchedItems: number | null
    totalAmount: Decimal | null
    warehouseId: string | null
    trackingNumber: string | null
    shippedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    shopifyOrderId: number
    customerId: number
    customerName: number
    customerEmail: number
    shippingAddress: number
    billingAddress: number
    shopifyLineItems: number
    status: number
    paymentStatus: number
    priority: number
    holdReason: number
    holdAt: number
    holdBy: number
    unmatchedItems: number
    totalAmount: number
    warehouseId: number
    trackingNumber: number
    shippedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    unmatchedItems?: true
    totalAmount?: true
  }

  export type OrderSumAggregateInputType = {
    unmatchedItems?: true
    totalAmount?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    shopifyOrderId?: true
    customerId?: true
    customerName?: true
    customerEmail?: true
    status?: true
    paymentStatus?: true
    priority?: true
    holdReason?: true
    holdAt?: true
    holdBy?: true
    unmatchedItems?: true
    totalAmount?: true
    warehouseId?: true
    trackingNumber?: true
    shippedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    shopifyOrderId?: true
    customerId?: true
    customerName?: true
    customerEmail?: true
    status?: true
    paymentStatus?: true
    priority?: true
    holdReason?: true
    holdAt?: true
    holdBy?: true
    unmatchedItems?: true
    totalAmount?: true
    warehouseId?: true
    trackingNumber?: true
    shippedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    shopifyOrderId?: true
    customerId?: true
    customerName?: true
    customerEmail?: true
    shippingAddress?: true
    billingAddress?: true
    shopifyLineItems?: true
    status?: true
    paymentStatus?: true
    priority?: true
    holdReason?: true
    holdAt?: true
    holdBy?: true
    unmatchedItems?: true
    totalAmount?: true
    warehouseId?: true
    trackingNumber?: true
    shippedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    orderNumber: string
    shopifyOrderId: string | null
    customerId: string | null
    customerName: string
    customerEmail: string | null
    shippingAddress: JsonValue
    billingAddress: JsonValue | null
    shopifyLineItems: JsonValue | null
    status: $Enums.OrderStatus
    paymentStatus: $Enums.PaymentStatus
    priority: $Enums.Priority
    holdReason: string | null
    holdAt: Date | null
    holdBy: string | null
    unmatchedItems: number
    totalAmount: Decimal
    warehouseId: string | null
    trackingNumber: string | null
    shippedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    shopifyOrderId?: boolean
    customerId?: boolean
    customerName?: boolean
    customerEmail?: boolean
    shippingAddress?: boolean
    billingAddress?: boolean
    shopifyLineItems?: boolean
    status?: boolean
    paymentStatus?: boolean
    priority?: boolean
    holdReason?: boolean
    holdAt?: boolean
    holdBy?: boolean
    unmatchedItems?: boolean
    totalAmount?: boolean
    warehouseId?: boolean
    trackingNumber?: boolean
    shippedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | Order$itemsArgs<ExtArgs>
    taskItems?: boolean | Order$taskItemsArgs<ExtArgs>
    allocations?: boolean | Order$allocationsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    shopifyOrderId?: boolean
    customerId?: boolean
    customerName?: boolean
    customerEmail?: boolean
    shippingAddress?: boolean
    billingAddress?: boolean
    shopifyLineItems?: boolean
    status?: boolean
    paymentStatus?: boolean
    priority?: boolean
    holdReason?: boolean
    holdAt?: boolean
    holdBy?: boolean
    unmatchedItems?: boolean
    totalAmount?: boolean
    warehouseId?: boolean
    trackingNumber?: boolean
    shippedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    shopifyOrderId?: boolean
    customerId?: boolean
    customerName?: boolean
    customerEmail?: boolean
    shippingAddress?: boolean
    billingAddress?: boolean
    shopifyLineItems?: boolean
    status?: boolean
    paymentStatus?: boolean
    priority?: boolean
    holdReason?: boolean
    holdAt?: boolean
    holdBy?: boolean
    unmatchedItems?: boolean
    totalAmount?: boolean
    warehouseId?: boolean
    trackingNumber?: boolean
    shippedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    shopifyOrderId?: boolean
    customerId?: boolean
    customerName?: boolean
    customerEmail?: boolean
    shippingAddress?: boolean
    billingAddress?: boolean
    shopifyLineItems?: boolean
    status?: boolean
    paymentStatus?: boolean
    priority?: boolean
    holdReason?: boolean
    holdAt?: boolean
    holdBy?: boolean
    unmatchedItems?: boolean
    totalAmount?: boolean
    warehouseId?: boolean
    trackingNumber?: boolean
    shippedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNumber" | "shopifyOrderId" | "customerId" | "customerName" | "customerEmail" | "shippingAddress" | "billingAddress" | "shopifyLineItems" | "status" | "paymentStatus" | "priority" | "holdReason" | "holdAt" | "holdBy" | "unmatchedItems" | "totalAmount" | "warehouseId" | "trackingNumber" | "shippedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Order$itemsArgs<ExtArgs>
    taskItems?: boolean | Order$taskItemsArgs<ExtArgs>
    allocations?: boolean | Order$allocationsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      taskItems: Prisma.$TaskItemPayload<ExtArgs>[]
      allocations: Prisma.$AllocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNumber: string
      shopifyOrderId: string | null
      customerId: string | null
      customerName: string
      customerEmail: string | null
      shippingAddress: Prisma.JsonValue
      billingAddress: Prisma.JsonValue | null
      shopifyLineItems: Prisma.JsonValue | null
      status: $Enums.OrderStatus
      paymentStatus: $Enums.PaymentStatus
      priority: $Enums.Priority
      holdReason: string | null
      holdAt: Date | null
      holdBy: string | null
      unmatchedItems: number
      totalAmount: Prisma.Decimal
      warehouseId: string | null
      trackingNumber: string | null
      shippedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskItems<T extends Order$taskItemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$taskItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    allocations<T extends Order$allocationsArgs<ExtArgs> = {}>(args?: Subset<T, Order$allocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly orderNumber: FieldRef<"Order", 'String'>
    readonly shopifyOrderId: FieldRef<"Order", 'String'>
    readonly customerId: FieldRef<"Order", 'String'>
    readonly customerName: FieldRef<"Order", 'String'>
    readonly customerEmail: FieldRef<"Order", 'String'>
    readonly shippingAddress: FieldRef<"Order", 'Json'>
    readonly billingAddress: FieldRef<"Order", 'Json'>
    readonly shopifyLineItems: FieldRef<"Order", 'Json'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly paymentStatus: FieldRef<"Order", 'PaymentStatus'>
    readonly priority: FieldRef<"Order", 'Priority'>
    readonly holdReason: FieldRef<"Order", 'String'>
    readonly holdAt: FieldRef<"Order", 'DateTime'>
    readonly holdBy: FieldRef<"Order", 'String'>
    readonly unmatchedItems: FieldRef<"Order", 'Int'>
    readonly totalAmount: FieldRef<"Order", 'Decimal'>
    readonly warehouseId: FieldRef<"Order", 'String'>
    readonly trackingNumber: FieldRef<"Order", 'String'>
    readonly shippedAt: FieldRef<"Order", 'DateTime'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.taskItems
   */
  export type Order$taskItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskItem
     */
    select?: TaskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskItem
     */
    omit?: TaskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskItemInclude<ExtArgs> | null
    where?: TaskItemWhereInput
    orderBy?: TaskItemOrderByWithRelationInput | TaskItemOrderByWithRelationInput[]
    cursor?: TaskItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskItemScalarFieldEnum | TaskItemScalarFieldEnum[]
  }

  /**
   * Order.allocations
   */
  export type Order$allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allocation
     */
    omit?: AllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    where?: AllocationWhereInput
    orderBy?: AllocationOrderByWithRelationInput | AllocationOrderByWithRelationInput[]
    cursor?: AllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AllocationScalarFieldEnum | AllocationScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
    quantityAllocated: number | null
    quantityPicked: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
    quantityAllocated: number | null
    quantityPicked: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    productVariantId: string | null
    sku: string | null
    quantity: number | null
    quantityAllocated: number | null
    quantityPicked: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    matched: boolean | null
    matchError: string | null
    shopifyLineItemId: string | null
    shopifyFulfillmentOrderLineItemId: string | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    productVariantId: string | null
    sku: string | null
    quantity: number | null
    quantityAllocated: number | null
    quantityPicked: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    matched: boolean | null
    matchError: string | null
    shopifyLineItemId: string | null
    shopifyFulfillmentOrderLineItemId: string | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    productVariantId: number
    sku: number
    quantity: number
    quantityAllocated: number
    quantityPicked: number
    unitPrice: number
    totalPrice: number
    matched: number
    matchError: number
    shopifyLineItemId: number
    shopifyFulfillmentOrderLineItemId: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
    quantityAllocated?: true
    quantityPicked?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
    quantityAllocated?: true
    quantityPicked?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    productVariantId?: true
    sku?: true
    quantity?: true
    quantityAllocated?: true
    quantityPicked?: true
    unitPrice?: true
    totalPrice?: true
    matched?: true
    matchError?: true
    shopifyLineItemId?: true
    shopifyFulfillmentOrderLineItemId?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    productVariantId?: true
    sku?: true
    quantity?: true
    quantityAllocated?: true
    quantityPicked?: true
    unitPrice?: true
    totalPrice?: true
    matched?: true
    matchError?: true
    shopifyLineItemId?: true
    shopifyFulfillmentOrderLineItemId?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    productVariantId?: true
    sku?: true
    quantity?: true
    quantityAllocated?: true
    quantityPicked?: true
    unitPrice?: true
    totalPrice?: true
    matched?: true
    matchError?: true
    shopifyLineItemId?: true
    shopifyFulfillmentOrderLineItemId?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    productVariantId: string | null
    sku: string
    quantity: number
    quantityAllocated: number
    quantityPicked: number
    unitPrice: Decimal
    totalPrice: Decimal | null
    matched: boolean
    matchError: string | null
    shopifyLineItemId: string | null
    shopifyFulfillmentOrderLineItemId: string | null
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productVariantId?: boolean
    sku?: boolean
    quantity?: boolean
    quantityAllocated?: boolean
    quantityPicked?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    matched?: boolean
    matchError?: boolean
    shopifyLineItemId?: boolean
    shopifyFulfillmentOrderLineItemId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    productVariant?: boolean | OrderItem$productVariantArgs<ExtArgs>
    taskItems?: boolean | OrderItem$taskItemsArgs<ExtArgs>
    allocations?: boolean | OrderItem$allocationsArgs<ExtArgs>
    _count?: boolean | OrderItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productVariantId?: boolean
    sku?: boolean
    quantity?: boolean
    quantityAllocated?: boolean
    quantityPicked?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    matched?: boolean
    matchError?: boolean
    shopifyLineItemId?: boolean
    shopifyFulfillmentOrderLineItemId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    productVariant?: boolean | OrderItem$productVariantArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productVariantId?: boolean
    sku?: boolean
    quantity?: boolean
    quantityAllocated?: boolean
    quantityPicked?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    matched?: boolean
    matchError?: boolean
    shopifyLineItemId?: boolean
    shopifyFulfillmentOrderLineItemId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    productVariant?: boolean | OrderItem$productVariantArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    productVariantId?: boolean
    sku?: boolean
    quantity?: boolean
    quantityAllocated?: boolean
    quantityPicked?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    matched?: boolean
    matchError?: boolean
    shopifyLineItemId?: boolean
    shopifyFulfillmentOrderLineItemId?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "productVariantId" | "sku" | "quantity" | "quantityAllocated" | "quantityPicked" | "unitPrice" | "totalPrice" | "matched" | "matchError" | "shopifyLineItemId" | "shopifyFulfillmentOrderLineItemId", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    productVariant?: boolean | OrderItem$productVariantArgs<ExtArgs>
    taskItems?: boolean | OrderItem$taskItemsArgs<ExtArgs>
    allocations?: boolean | OrderItem$allocationsArgs<ExtArgs>
    _count?: boolean | OrderItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    productVariant?: boolean | OrderItem$productVariantArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    productVariant?: boolean | OrderItem$productVariantArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      productVariant: Prisma.$ProductVariantPayload<ExtArgs> | null
      taskItems: Prisma.$TaskItemPayload<ExtArgs>[]
      allocations: Prisma.$AllocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      productVariantId: string | null
      sku: string
      quantity: number
      quantityAllocated: number
      quantityPicked: number
      unitPrice: Prisma.Decimal
      totalPrice: Prisma.Decimal | null
      matched: boolean
      matchError: string | null
      shopifyLineItemId: string | null
      shopifyFulfillmentOrderLineItemId: string | null
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    productVariant<T extends OrderItem$productVariantArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$productVariantArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    taskItems<T extends OrderItem$taskItemsArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$taskItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    allocations<T extends OrderItem$allocationsArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$allocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly productVariantId: FieldRef<"OrderItem", 'String'>
    readonly sku: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly quantityAllocated: FieldRef<"OrderItem", 'Int'>
    readonly quantityPicked: FieldRef<"OrderItem", 'Int'>
    readonly unitPrice: FieldRef<"OrderItem", 'Decimal'>
    readonly totalPrice: FieldRef<"OrderItem", 'Decimal'>
    readonly matched: FieldRef<"OrderItem", 'Boolean'>
    readonly matchError: FieldRef<"OrderItem", 'String'>
    readonly shopifyLineItemId: FieldRef<"OrderItem", 'String'>
    readonly shopifyFulfillmentOrderLineItemId: FieldRef<"OrderItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem.productVariant
   */
  export type OrderItem$productVariantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    where?: ProductVariantWhereInput
  }

  /**
   * OrderItem.taskItems
   */
  export type OrderItem$taskItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskItem
     */
    select?: TaskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskItem
     */
    omit?: TaskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskItemInclude<ExtArgs> | null
    where?: TaskItemWhereInput
    orderBy?: TaskItemOrderByWithRelationInput | TaskItemOrderByWithRelationInput[]
    cursor?: TaskItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskItemScalarFieldEnum | TaskItemScalarFieldEnum[]
  }

  /**
   * OrderItem.allocations
   */
  export type OrderItem$allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allocation
     */
    omit?: AllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    where?: AllocationWhereInput
    orderBy?: AllocationOrderByWithRelationInput | AllocationOrderByWithRelationInput[]
    cursor?: AllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AllocationScalarFieldEnum | AllocationScalarFieldEnum[]
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model WorkTask
   */

  export type AggregateWorkTask = {
    _count: WorkTaskCountAggregateOutputType | null
    _avg: WorkTaskAvgAggregateOutputType | null
    _sum: WorkTaskSumAggregateOutputType | null
    _min: WorkTaskMinAggregateOutputType | null
    _max: WorkTaskMaxAggregateOutputType | null
  }

  export type WorkTaskAvgAggregateOutputType = {
    priority: number | null
    totalOrders: number | null
    completedOrders: number | null
    totalItems: number | null
    completedItems: number | null
    shortItems: number | null
    skippedItems: number | null
  }

  export type WorkTaskSumAggregateOutputType = {
    priority: number | null
    totalOrders: number | null
    completedOrders: number | null
    totalItems: number | null
    completedItems: number | null
    shortItems: number | null
    skippedItems: number | null
  }

  export type WorkTaskMinAggregateOutputType = {
    id: string | null
    taskNumber: string | null
    type: $Enums.WorkTaskType | null
    status: $Enums.WorkTaskStatus | null
    priority: number | null
    idempotencyKey: string | null
    assignedTo: string | null
    assignedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    blockReason: $Enums.WorkTaskBlockReason | null
    blockedAt: Date | null
    totalOrders: number | null
    completedOrders: number | null
    totalItems: number | null
    completedItems: number | null
    shortItems: number | null
    skippedItems: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkTaskMaxAggregateOutputType = {
    id: string | null
    taskNumber: string | null
    type: $Enums.WorkTaskType | null
    status: $Enums.WorkTaskStatus | null
    priority: number | null
    idempotencyKey: string | null
    assignedTo: string | null
    assignedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    blockReason: $Enums.WorkTaskBlockReason | null
    blockedAt: Date | null
    totalOrders: number | null
    completedOrders: number | null
    totalItems: number | null
    completedItems: number | null
    shortItems: number | null
    skippedItems: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkTaskCountAggregateOutputType = {
    id: number
    taskNumber: number
    type: number
    status: number
    priority: number
    idempotencyKey: number
    assignedTo: number
    assignedAt: number
    startedAt: number
    completedAt: number
    blockReason: number
    blockedAt: number
    orderIds: number
    totalOrders: number
    completedOrders: number
    totalItems: number
    completedItems: number
    shortItems: number
    skippedItems: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkTaskAvgAggregateInputType = {
    priority?: true
    totalOrders?: true
    completedOrders?: true
    totalItems?: true
    completedItems?: true
    shortItems?: true
    skippedItems?: true
  }

  export type WorkTaskSumAggregateInputType = {
    priority?: true
    totalOrders?: true
    completedOrders?: true
    totalItems?: true
    completedItems?: true
    shortItems?: true
    skippedItems?: true
  }

  export type WorkTaskMinAggregateInputType = {
    id?: true
    taskNumber?: true
    type?: true
    status?: true
    priority?: true
    idempotencyKey?: true
    assignedTo?: true
    assignedAt?: true
    startedAt?: true
    completedAt?: true
    blockReason?: true
    blockedAt?: true
    totalOrders?: true
    completedOrders?: true
    totalItems?: true
    completedItems?: true
    shortItems?: true
    skippedItems?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkTaskMaxAggregateInputType = {
    id?: true
    taskNumber?: true
    type?: true
    status?: true
    priority?: true
    idempotencyKey?: true
    assignedTo?: true
    assignedAt?: true
    startedAt?: true
    completedAt?: true
    blockReason?: true
    blockedAt?: true
    totalOrders?: true
    completedOrders?: true
    totalItems?: true
    completedItems?: true
    shortItems?: true
    skippedItems?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkTaskCountAggregateInputType = {
    id?: true
    taskNumber?: true
    type?: true
    status?: true
    priority?: true
    idempotencyKey?: true
    assignedTo?: true
    assignedAt?: true
    startedAt?: true
    completedAt?: true
    blockReason?: true
    blockedAt?: true
    orderIds?: true
    totalOrders?: true
    completedOrders?: true
    totalItems?: true
    completedItems?: true
    shortItems?: true
    skippedItems?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkTask to aggregate.
     */
    where?: WorkTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkTasks to fetch.
     */
    orderBy?: WorkTaskOrderByWithRelationInput | WorkTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkTasks
    **/
    _count?: true | WorkTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkTaskMaxAggregateInputType
  }

  export type GetWorkTaskAggregateType<T extends WorkTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkTask[P]>
      : GetScalarType<T[P], AggregateWorkTask[P]>
  }




  export type WorkTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkTaskWhereInput
    orderBy?: WorkTaskOrderByWithAggregationInput | WorkTaskOrderByWithAggregationInput[]
    by: WorkTaskScalarFieldEnum[] | WorkTaskScalarFieldEnum
    having?: WorkTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkTaskCountAggregateInputType | true
    _avg?: WorkTaskAvgAggregateInputType
    _sum?: WorkTaskSumAggregateInputType
    _min?: WorkTaskMinAggregateInputType
    _max?: WorkTaskMaxAggregateInputType
  }

  export type WorkTaskGroupByOutputType = {
    id: string
    taskNumber: string
    type: $Enums.WorkTaskType
    status: $Enums.WorkTaskStatus
    priority: number
    idempotencyKey: string | null
    assignedTo: string | null
    assignedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    blockReason: $Enums.WorkTaskBlockReason | null
    blockedAt: Date | null
    orderIds: string[]
    totalOrders: number
    completedOrders: number
    totalItems: number
    completedItems: number
    shortItems: number
    skippedItems: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: WorkTaskCountAggregateOutputType | null
    _avg: WorkTaskAvgAggregateOutputType | null
    _sum: WorkTaskSumAggregateOutputType | null
    _min: WorkTaskMinAggregateOutputType | null
    _max: WorkTaskMaxAggregateOutputType | null
  }

  type GetWorkTaskGroupByPayload<T extends WorkTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkTaskGroupByOutputType[P]>
            : GetScalarType<T[P], WorkTaskGroupByOutputType[P]>
        }
      >
    >


  export type WorkTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskNumber?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    idempotencyKey?: boolean
    assignedTo?: boolean
    assignedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    blockReason?: boolean
    blockedAt?: boolean
    orderIds?: boolean
    totalOrders?: boolean
    completedOrders?: boolean
    totalItems?: boolean
    completedItems?: boolean
    shortItems?: boolean
    skippedItems?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedUser?: boolean | WorkTask$assignedUserArgs<ExtArgs>
    taskItems?: boolean | WorkTask$taskItemsArgs<ExtArgs>
    events?: boolean | WorkTask$eventsArgs<ExtArgs>
    _count?: boolean | WorkTaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workTask"]>

  export type WorkTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskNumber?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    idempotencyKey?: boolean
    assignedTo?: boolean
    assignedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    blockReason?: boolean
    blockedAt?: boolean
    orderIds?: boolean
    totalOrders?: boolean
    completedOrders?: boolean
    totalItems?: boolean
    completedItems?: boolean
    shortItems?: boolean
    skippedItems?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedUser?: boolean | WorkTask$assignedUserArgs<ExtArgs>
  }, ExtArgs["result"]["workTask"]>

  export type WorkTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskNumber?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    idempotencyKey?: boolean
    assignedTo?: boolean
    assignedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    blockReason?: boolean
    blockedAt?: boolean
    orderIds?: boolean
    totalOrders?: boolean
    completedOrders?: boolean
    totalItems?: boolean
    completedItems?: boolean
    shortItems?: boolean
    skippedItems?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedUser?: boolean | WorkTask$assignedUserArgs<ExtArgs>
  }, ExtArgs["result"]["workTask"]>

  export type WorkTaskSelectScalar = {
    id?: boolean
    taskNumber?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    idempotencyKey?: boolean
    assignedTo?: boolean
    assignedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    blockReason?: boolean
    blockedAt?: boolean
    orderIds?: boolean
    totalOrders?: boolean
    completedOrders?: boolean
    totalItems?: boolean
    completedItems?: boolean
    shortItems?: boolean
    skippedItems?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskNumber" | "type" | "status" | "priority" | "idempotencyKey" | "assignedTo" | "assignedAt" | "startedAt" | "completedAt" | "blockReason" | "blockedAt" | "orderIds" | "totalOrders" | "completedOrders" | "totalItems" | "completedItems" | "shortItems" | "skippedItems" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["workTask"]>
  export type WorkTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedUser?: boolean | WorkTask$assignedUserArgs<ExtArgs>
    taskItems?: boolean | WorkTask$taskItemsArgs<ExtArgs>
    events?: boolean | WorkTask$eventsArgs<ExtArgs>
    _count?: boolean | WorkTaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedUser?: boolean | WorkTask$assignedUserArgs<ExtArgs>
  }
  export type WorkTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedUser?: boolean | WorkTask$assignedUserArgs<ExtArgs>
  }

  export type $WorkTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkTask"
    objects: {
      assignedUser: Prisma.$UserPayload<ExtArgs> | null
      taskItems: Prisma.$TaskItemPayload<ExtArgs>[]
      events: Prisma.$TaskEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskNumber: string
      type: $Enums.WorkTaskType
      status: $Enums.WorkTaskStatus
      priority: number
      idempotencyKey: string | null
      assignedTo: string | null
      assignedAt: Date | null
      startedAt: Date | null
      completedAt: Date | null
      blockReason: $Enums.WorkTaskBlockReason | null
      blockedAt: Date | null
      orderIds: string[]
      totalOrders: number
      completedOrders: number
      totalItems: number
      completedItems: number
      shortItems: number
      skippedItems: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workTask"]>
    composites: {}
  }

  type WorkTaskGetPayload<S extends boolean | null | undefined | WorkTaskDefaultArgs> = $Result.GetResult<Prisma.$WorkTaskPayload, S>

  type WorkTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkTaskCountAggregateInputType | true
    }

  export interface WorkTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkTask'], meta: { name: 'WorkTask' } }
    /**
     * Find zero or one WorkTask that matches the filter.
     * @param {WorkTaskFindUniqueArgs} args - Arguments to find a WorkTask
     * @example
     * // Get one WorkTask
     * const workTask = await prisma.workTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkTaskFindUniqueArgs>(args: SelectSubset<T, WorkTaskFindUniqueArgs<ExtArgs>>): Prisma__WorkTaskClient<$Result.GetResult<Prisma.$WorkTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkTaskFindUniqueOrThrowArgs} args - Arguments to find a WorkTask
     * @example
     * // Get one WorkTask
     * const workTask = await prisma.workTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkTaskClient<$Result.GetResult<Prisma.$WorkTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkTaskFindFirstArgs} args - Arguments to find a WorkTask
     * @example
     * // Get one WorkTask
     * const workTask = await prisma.workTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkTaskFindFirstArgs>(args?: SelectSubset<T, WorkTaskFindFirstArgs<ExtArgs>>): Prisma__WorkTaskClient<$Result.GetResult<Prisma.$WorkTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkTaskFindFirstOrThrowArgs} args - Arguments to find a WorkTask
     * @example
     * // Get one WorkTask
     * const workTask = await prisma.workTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkTaskClient<$Result.GetResult<Prisma.$WorkTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkTasks
     * const workTasks = await prisma.workTask.findMany()
     * 
     * // Get first 10 WorkTasks
     * const workTasks = await prisma.workTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workTaskWithIdOnly = await prisma.workTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkTaskFindManyArgs>(args?: SelectSubset<T, WorkTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkTask.
     * @param {WorkTaskCreateArgs} args - Arguments to create a WorkTask.
     * @example
     * // Create one WorkTask
     * const WorkTask = await prisma.workTask.create({
     *   data: {
     *     // ... data to create a WorkTask
     *   }
     * })
     * 
     */
    create<T extends WorkTaskCreateArgs>(args: SelectSubset<T, WorkTaskCreateArgs<ExtArgs>>): Prisma__WorkTaskClient<$Result.GetResult<Prisma.$WorkTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkTasks.
     * @param {WorkTaskCreateManyArgs} args - Arguments to create many WorkTasks.
     * @example
     * // Create many WorkTasks
     * const workTask = await prisma.workTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkTaskCreateManyArgs>(args?: SelectSubset<T, WorkTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkTasks and returns the data saved in the database.
     * @param {WorkTaskCreateManyAndReturnArgs} args - Arguments to create many WorkTasks.
     * @example
     * // Create many WorkTasks
     * const workTask = await prisma.workTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkTasks and only return the `id`
     * const workTaskWithIdOnly = await prisma.workTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkTask.
     * @param {WorkTaskDeleteArgs} args - Arguments to delete one WorkTask.
     * @example
     * // Delete one WorkTask
     * const WorkTask = await prisma.workTask.delete({
     *   where: {
     *     // ... filter to delete one WorkTask
     *   }
     * })
     * 
     */
    delete<T extends WorkTaskDeleteArgs>(args: SelectSubset<T, WorkTaskDeleteArgs<ExtArgs>>): Prisma__WorkTaskClient<$Result.GetResult<Prisma.$WorkTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkTask.
     * @param {WorkTaskUpdateArgs} args - Arguments to update one WorkTask.
     * @example
     * // Update one WorkTask
     * const workTask = await prisma.workTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkTaskUpdateArgs>(args: SelectSubset<T, WorkTaskUpdateArgs<ExtArgs>>): Prisma__WorkTaskClient<$Result.GetResult<Prisma.$WorkTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkTasks.
     * @param {WorkTaskDeleteManyArgs} args - Arguments to filter WorkTasks to delete.
     * @example
     * // Delete a few WorkTasks
     * const { count } = await prisma.workTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkTaskDeleteManyArgs>(args?: SelectSubset<T, WorkTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkTasks
     * const workTask = await prisma.workTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkTaskUpdateManyArgs>(args: SelectSubset<T, WorkTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkTasks and returns the data updated in the database.
     * @param {WorkTaskUpdateManyAndReturnArgs} args - Arguments to update many WorkTasks.
     * @example
     * // Update many WorkTasks
     * const workTask = await prisma.workTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkTasks and only return the `id`
     * const workTaskWithIdOnly = await prisma.workTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkTask.
     * @param {WorkTaskUpsertArgs} args - Arguments to update or create a WorkTask.
     * @example
     * // Update or create a WorkTask
     * const workTask = await prisma.workTask.upsert({
     *   create: {
     *     // ... data to create a WorkTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkTask we want to update
     *   }
     * })
     */
    upsert<T extends WorkTaskUpsertArgs>(args: SelectSubset<T, WorkTaskUpsertArgs<ExtArgs>>): Prisma__WorkTaskClient<$Result.GetResult<Prisma.$WorkTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkTaskCountArgs} args - Arguments to filter WorkTasks to count.
     * @example
     * // Count the number of WorkTasks
     * const count = await prisma.workTask.count({
     *   where: {
     *     // ... the filter for the WorkTasks we want to count
     *   }
     * })
    **/
    count<T extends WorkTaskCountArgs>(
      args?: Subset<T, WorkTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkTaskAggregateArgs>(args: Subset<T, WorkTaskAggregateArgs>): Prisma.PrismaPromise<GetWorkTaskAggregateType<T>>

    /**
     * Group by WorkTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkTaskGroupByArgs['orderBy'] }
        : { orderBy?: WorkTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkTask model
   */
  readonly fields: WorkTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedUser<T extends WorkTask$assignedUserArgs<ExtArgs> = {}>(args?: Subset<T, WorkTask$assignedUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    taskItems<T extends WorkTask$taskItemsArgs<ExtArgs> = {}>(args?: Subset<T, WorkTask$taskItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends WorkTask$eventsArgs<ExtArgs> = {}>(args?: Subset<T, WorkTask$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkTask model
   */
  interface WorkTaskFieldRefs {
    readonly id: FieldRef<"WorkTask", 'String'>
    readonly taskNumber: FieldRef<"WorkTask", 'String'>
    readonly type: FieldRef<"WorkTask", 'WorkTaskType'>
    readonly status: FieldRef<"WorkTask", 'WorkTaskStatus'>
    readonly priority: FieldRef<"WorkTask", 'Int'>
    readonly idempotencyKey: FieldRef<"WorkTask", 'String'>
    readonly assignedTo: FieldRef<"WorkTask", 'String'>
    readonly assignedAt: FieldRef<"WorkTask", 'DateTime'>
    readonly startedAt: FieldRef<"WorkTask", 'DateTime'>
    readonly completedAt: FieldRef<"WorkTask", 'DateTime'>
    readonly blockReason: FieldRef<"WorkTask", 'WorkTaskBlockReason'>
    readonly blockedAt: FieldRef<"WorkTask", 'DateTime'>
    readonly orderIds: FieldRef<"WorkTask", 'String[]'>
    readonly totalOrders: FieldRef<"WorkTask", 'Int'>
    readonly completedOrders: FieldRef<"WorkTask", 'Int'>
    readonly totalItems: FieldRef<"WorkTask", 'Int'>
    readonly completedItems: FieldRef<"WorkTask", 'Int'>
    readonly shortItems: FieldRef<"WorkTask", 'Int'>
    readonly skippedItems: FieldRef<"WorkTask", 'Int'>
    readonly notes: FieldRef<"WorkTask", 'String'>
    readonly createdAt: FieldRef<"WorkTask", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkTask findUnique
   */
  export type WorkTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTask
     */
    select?: WorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTask
     */
    omit?: WorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTaskInclude<ExtArgs> | null
    /**
     * Filter, which WorkTask to fetch.
     */
    where: WorkTaskWhereUniqueInput
  }

  /**
   * WorkTask findUniqueOrThrow
   */
  export type WorkTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTask
     */
    select?: WorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTask
     */
    omit?: WorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTaskInclude<ExtArgs> | null
    /**
     * Filter, which WorkTask to fetch.
     */
    where: WorkTaskWhereUniqueInput
  }

  /**
   * WorkTask findFirst
   */
  export type WorkTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTask
     */
    select?: WorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTask
     */
    omit?: WorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTaskInclude<ExtArgs> | null
    /**
     * Filter, which WorkTask to fetch.
     */
    where?: WorkTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkTasks to fetch.
     */
    orderBy?: WorkTaskOrderByWithRelationInput | WorkTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkTasks.
     */
    cursor?: WorkTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkTasks.
     */
    distinct?: WorkTaskScalarFieldEnum | WorkTaskScalarFieldEnum[]
  }

  /**
   * WorkTask findFirstOrThrow
   */
  export type WorkTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTask
     */
    select?: WorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTask
     */
    omit?: WorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTaskInclude<ExtArgs> | null
    /**
     * Filter, which WorkTask to fetch.
     */
    where?: WorkTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkTasks to fetch.
     */
    orderBy?: WorkTaskOrderByWithRelationInput | WorkTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkTasks.
     */
    cursor?: WorkTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkTasks.
     */
    distinct?: WorkTaskScalarFieldEnum | WorkTaskScalarFieldEnum[]
  }

  /**
   * WorkTask findMany
   */
  export type WorkTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTask
     */
    select?: WorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTask
     */
    omit?: WorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTaskInclude<ExtArgs> | null
    /**
     * Filter, which WorkTasks to fetch.
     */
    where?: WorkTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkTasks to fetch.
     */
    orderBy?: WorkTaskOrderByWithRelationInput | WorkTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkTasks.
     */
    cursor?: WorkTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkTasks.
     */
    skip?: number
    distinct?: WorkTaskScalarFieldEnum | WorkTaskScalarFieldEnum[]
  }

  /**
   * WorkTask create
   */
  export type WorkTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTask
     */
    select?: WorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTask
     */
    omit?: WorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkTask.
     */
    data: XOR<WorkTaskCreateInput, WorkTaskUncheckedCreateInput>
  }

  /**
   * WorkTask createMany
   */
  export type WorkTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkTasks.
     */
    data: WorkTaskCreateManyInput | WorkTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkTask createManyAndReturn
   */
  export type WorkTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTask
     */
    select?: WorkTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTask
     */
    omit?: WorkTaskOmit<ExtArgs> | null
    /**
     * The data used to create many WorkTasks.
     */
    data: WorkTaskCreateManyInput | WorkTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkTask update
   */
  export type WorkTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTask
     */
    select?: WorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTask
     */
    omit?: WorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkTask.
     */
    data: XOR<WorkTaskUpdateInput, WorkTaskUncheckedUpdateInput>
    /**
     * Choose, which WorkTask to update.
     */
    where: WorkTaskWhereUniqueInput
  }

  /**
   * WorkTask updateMany
   */
  export type WorkTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkTasks.
     */
    data: XOR<WorkTaskUpdateManyMutationInput, WorkTaskUncheckedUpdateManyInput>
    /**
     * Filter which WorkTasks to update
     */
    where?: WorkTaskWhereInput
    /**
     * Limit how many WorkTasks to update.
     */
    limit?: number
  }

  /**
   * WorkTask updateManyAndReturn
   */
  export type WorkTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTask
     */
    select?: WorkTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTask
     */
    omit?: WorkTaskOmit<ExtArgs> | null
    /**
     * The data used to update WorkTasks.
     */
    data: XOR<WorkTaskUpdateManyMutationInput, WorkTaskUncheckedUpdateManyInput>
    /**
     * Filter which WorkTasks to update
     */
    where?: WorkTaskWhereInput
    /**
     * Limit how many WorkTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkTask upsert
   */
  export type WorkTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTask
     */
    select?: WorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTask
     */
    omit?: WorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkTask to update in case it exists.
     */
    where: WorkTaskWhereUniqueInput
    /**
     * In case the WorkTask found by the `where` argument doesn't exist, create a new WorkTask with this data.
     */
    create: XOR<WorkTaskCreateInput, WorkTaskUncheckedCreateInput>
    /**
     * In case the WorkTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkTaskUpdateInput, WorkTaskUncheckedUpdateInput>
  }

  /**
   * WorkTask delete
   */
  export type WorkTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTask
     */
    select?: WorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTask
     */
    omit?: WorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTaskInclude<ExtArgs> | null
    /**
     * Filter which WorkTask to delete.
     */
    where: WorkTaskWhereUniqueInput
  }

  /**
   * WorkTask deleteMany
   */
  export type WorkTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkTasks to delete
     */
    where?: WorkTaskWhereInput
    /**
     * Limit how many WorkTasks to delete.
     */
    limit?: number
  }

  /**
   * WorkTask.assignedUser
   */
  export type WorkTask$assignedUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * WorkTask.taskItems
   */
  export type WorkTask$taskItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskItem
     */
    select?: TaskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskItem
     */
    omit?: TaskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskItemInclude<ExtArgs> | null
    where?: TaskItemWhereInput
    orderBy?: TaskItemOrderByWithRelationInput | TaskItemOrderByWithRelationInput[]
    cursor?: TaskItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskItemScalarFieldEnum | TaskItemScalarFieldEnum[]
  }

  /**
   * WorkTask.events
   */
  export type WorkTask$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
    where?: TaskEventWhereInput
    orderBy?: TaskEventOrderByWithRelationInput | TaskEventOrderByWithRelationInput[]
    cursor?: TaskEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskEventScalarFieldEnum | TaskEventScalarFieldEnum[]
  }

  /**
   * WorkTask without action
   */
  export type WorkTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTask
     */
    select?: WorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkTask
     */
    omit?: WorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTaskInclude<ExtArgs> | null
  }


  /**
   * Model TaskItem
   */

  export type AggregateTaskItem = {
    _count: TaskItemCountAggregateOutputType | null
    _avg: TaskItemAvgAggregateOutputType | null
    _sum: TaskItemSumAggregateOutputType | null
    _min: TaskItemMinAggregateOutputType | null
    _max: TaskItemMaxAggregateOutputType | null
  }

  export type TaskItemAvgAggregateOutputType = {
    sequence: number | null
    quantityRequired: number | null
    quantityCompleted: number | null
  }

  export type TaskItemSumAggregateOutputType = {
    sequence: number | null
    quantityRequired: number | null
    quantityCompleted: number | null
  }

  export type TaskItemMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    orderId: string | null
    orderItemId: string | null
    productVariantId: string | null
    locationId: string | null
    allocationId: string | null
    sequence: number | null
    quantityRequired: number | null
    quantityCompleted: number | null
    status: $Enums.WorkTaskItemStatus | null
    completedBy: string | null
    completedAt: Date | null
    shortReason: string | null
    locationScanned: boolean | null
    itemScanned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskItemMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    orderId: string | null
    orderItemId: string | null
    productVariantId: string | null
    locationId: string | null
    allocationId: string | null
    sequence: number | null
    quantityRequired: number | null
    quantityCompleted: number | null
    status: $Enums.WorkTaskItemStatus | null
    completedBy: string | null
    completedAt: Date | null
    shortReason: string | null
    locationScanned: boolean | null
    itemScanned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskItemCountAggregateOutputType = {
    id: number
    taskId: number
    orderId: number
    orderItemId: number
    productVariantId: number
    locationId: number
    allocationId: number
    sequence: number
    quantityRequired: number
    quantityCompleted: number
    status: number
    completedBy: number
    completedAt: number
    shortReason: number
    locationScanned: number
    itemScanned: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskItemAvgAggregateInputType = {
    sequence?: true
    quantityRequired?: true
    quantityCompleted?: true
  }

  export type TaskItemSumAggregateInputType = {
    sequence?: true
    quantityRequired?: true
    quantityCompleted?: true
  }

  export type TaskItemMinAggregateInputType = {
    id?: true
    taskId?: true
    orderId?: true
    orderItemId?: true
    productVariantId?: true
    locationId?: true
    allocationId?: true
    sequence?: true
    quantityRequired?: true
    quantityCompleted?: true
    status?: true
    completedBy?: true
    completedAt?: true
    shortReason?: true
    locationScanned?: true
    itemScanned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskItemMaxAggregateInputType = {
    id?: true
    taskId?: true
    orderId?: true
    orderItemId?: true
    productVariantId?: true
    locationId?: true
    allocationId?: true
    sequence?: true
    quantityRequired?: true
    quantityCompleted?: true
    status?: true
    completedBy?: true
    completedAt?: true
    shortReason?: true
    locationScanned?: true
    itemScanned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskItemCountAggregateInputType = {
    id?: true
    taskId?: true
    orderId?: true
    orderItemId?: true
    productVariantId?: true
    locationId?: true
    allocationId?: true
    sequence?: true
    quantityRequired?: true
    quantityCompleted?: true
    status?: true
    completedBy?: true
    completedAt?: true
    shortReason?: true
    locationScanned?: true
    itemScanned?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskItem to aggregate.
     */
    where?: TaskItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskItems to fetch.
     */
    orderBy?: TaskItemOrderByWithRelationInput | TaskItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskItems
    **/
    _count?: true | TaskItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskItemMaxAggregateInputType
  }

  export type GetTaskItemAggregateType<T extends TaskItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskItem[P]>
      : GetScalarType<T[P], AggregateTaskItem[P]>
  }




  export type TaskItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskItemWhereInput
    orderBy?: TaskItemOrderByWithAggregationInput | TaskItemOrderByWithAggregationInput[]
    by: TaskItemScalarFieldEnum[] | TaskItemScalarFieldEnum
    having?: TaskItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskItemCountAggregateInputType | true
    _avg?: TaskItemAvgAggregateInputType
    _sum?: TaskItemSumAggregateInputType
    _min?: TaskItemMinAggregateInputType
    _max?: TaskItemMaxAggregateInputType
  }

  export type TaskItemGroupByOutputType = {
    id: string
    taskId: string
    orderId: string
    orderItemId: string | null
    productVariantId: string | null
    locationId: string | null
    allocationId: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted: number
    status: $Enums.WorkTaskItemStatus
    completedBy: string | null
    completedAt: Date | null
    shortReason: string | null
    locationScanned: boolean
    itemScanned: boolean
    createdAt: Date
    updatedAt: Date
    _count: TaskItemCountAggregateOutputType | null
    _avg: TaskItemAvgAggregateOutputType | null
    _sum: TaskItemSumAggregateOutputType | null
    _min: TaskItemMinAggregateOutputType | null
    _max: TaskItemMaxAggregateOutputType | null
  }

  type GetTaskItemGroupByPayload<T extends TaskItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskItemGroupByOutputType[P]>
            : GetScalarType<T[P], TaskItemGroupByOutputType[P]>
        }
      >
    >


  export type TaskItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    orderId?: boolean
    orderItemId?: boolean
    productVariantId?: boolean
    locationId?: boolean
    allocationId?: boolean
    sequence?: boolean
    quantityRequired?: boolean
    quantityCompleted?: boolean
    status?: boolean
    completedBy?: boolean
    completedAt?: boolean
    shortReason?: boolean
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | WorkTaskDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    orderItem?: boolean | TaskItem$orderItemArgs<ExtArgs>
    productVariant?: boolean | TaskItem$productVariantArgs<ExtArgs>
    location?: boolean | TaskItem$locationArgs<ExtArgs>
    completedByUser?: boolean | TaskItem$completedByUserArgs<ExtArgs>
    allocation?: boolean | TaskItem$allocationArgs<ExtArgs>
  }, ExtArgs["result"]["taskItem"]>

  export type TaskItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    orderId?: boolean
    orderItemId?: boolean
    productVariantId?: boolean
    locationId?: boolean
    allocationId?: boolean
    sequence?: boolean
    quantityRequired?: boolean
    quantityCompleted?: boolean
    status?: boolean
    completedBy?: boolean
    completedAt?: boolean
    shortReason?: boolean
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | WorkTaskDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    orderItem?: boolean | TaskItem$orderItemArgs<ExtArgs>
    productVariant?: boolean | TaskItem$productVariantArgs<ExtArgs>
    location?: boolean | TaskItem$locationArgs<ExtArgs>
    completedByUser?: boolean | TaskItem$completedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["taskItem"]>

  export type TaskItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    orderId?: boolean
    orderItemId?: boolean
    productVariantId?: boolean
    locationId?: boolean
    allocationId?: boolean
    sequence?: boolean
    quantityRequired?: boolean
    quantityCompleted?: boolean
    status?: boolean
    completedBy?: boolean
    completedAt?: boolean
    shortReason?: boolean
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | WorkTaskDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    orderItem?: boolean | TaskItem$orderItemArgs<ExtArgs>
    productVariant?: boolean | TaskItem$productVariantArgs<ExtArgs>
    location?: boolean | TaskItem$locationArgs<ExtArgs>
    completedByUser?: boolean | TaskItem$completedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["taskItem"]>

  export type TaskItemSelectScalar = {
    id?: boolean
    taskId?: boolean
    orderId?: boolean
    orderItemId?: boolean
    productVariantId?: boolean
    locationId?: boolean
    allocationId?: boolean
    sequence?: boolean
    quantityRequired?: boolean
    quantityCompleted?: boolean
    status?: boolean
    completedBy?: boolean
    completedAt?: boolean
    shortReason?: boolean
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "orderId" | "orderItemId" | "productVariantId" | "locationId" | "allocationId" | "sequence" | "quantityRequired" | "quantityCompleted" | "status" | "completedBy" | "completedAt" | "shortReason" | "locationScanned" | "itemScanned" | "createdAt" | "updatedAt", ExtArgs["result"]["taskItem"]>
  export type TaskItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | WorkTaskDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    orderItem?: boolean | TaskItem$orderItemArgs<ExtArgs>
    productVariant?: boolean | TaskItem$productVariantArgs<ExtArgs>
    location?: boolean | TaskItem$locationArgs<ExtArgs>
    completedByUser?: boolean | TaskItem$completedByUserArgs<ExtArgs>
    allocation?: boolean | TaskItem$allocationArgs<ExtArgs>
  }
  export type TaskItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | WorkTaskDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    orderItem?: boolean | TaskItem$orderItemArgs<ExtArgs>
    productVariant?: boolean | TaskItem$productVariantArgs<ExtArgs>
    location?: boolean | TaskItem$locationArgs<ExtArgs>
    completedByUser?: boolean | TaskItem$completedByUserArgs<ExtArgs>
  }
  export type TaskItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | WorkTaskDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    orderItem?: boolean | TaskItem$orderItemArgs<ExtArgs>
    productVariant?: boolean | TaskItem$productVariantArgs<ExtArgs>
    location?: boolean | TaskItem$locationArgs<ExtArgs>
    completedByUser?: boolean | TaskItem$completedByUserArgs<ExtArgs>
  }

  export type $TaskItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskItem"
    objects: {
      task: Prisma.$WorkTaskPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs>
      orderItem: Prisma.$OrderItemPayload<ExtArgs> | null
      productVariant: Prisma.$ProductVariantPayload<ExtArgs> | null
      location: Prisma.$LocationPayload<ExtArgs> | null
      completedByUser: Prisma.$UserPayload<ExtArgs> | null
      allocation: Prisma.$AllocationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      orderId: string
      orderItemId: string | null
      productVariantId: string | null
      locationId: string | null
      allocationId: string | null
      sequence: number
      quantityRequired: number
      quantityCompleted: number
      status: $Enums.WorkTaskItemStatus
      completedBy: string | null
      completedAt: Date | null
      shortReason: string | null
      locationScanned: boolean
      itemScanned: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["taskItem"]>
    composites: {}
  }

  type TaskItemGetPayload<S extends boolean | null | undefined | TaskItemDefaultArgs> = $Result.GetResult<Prisma.$TaskItemPayload, S>

  type TaskItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskItemCountAggregateInputType | true
    }

  export interface TaskItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskItem'], meta: { name: 'TaskItem' } }
    /**
     * Find zero or one TaskItem that matches the filter.
     * @param {TaskItemFindUniqueArgs} args - Arguments to find a TaskItem
     * @example
     * // Get one TaskItem
     * const taskItem = await prisma.taskItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskItemFindUniqueArgs>(args: SelectSubset<T, TaskItemFindUniqueArgs<ExtArgs>>): Prisma__TaskItemClient<$Result.GetResult<Prisma.$TaskItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskItemFindUniqueOrThrowArgs} args - Arguments to find a TaskItem
     * @example
     * // Get one TaskItem
     * const taskItem = await prisma.taskItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskItemFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskItemClient<$Result.GetResult<Prisma.$TaskItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskItemFindFirstArgs} args - Arguments to find a TaskItem
     * @example
     * // Get one TaskItem
     * const taskItem = await prisma.taskItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskItemFindFirstArgs>(args?: SelectSubset<T, TaskItemFindFirstArgs<ExtArgs>>): Prisma__TaskItemClient<$Result.GetResult<Prisma.$TaskItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskItemFindFirstOrThrowArgs} args - Arguments to find a TaskItem
     * @example
     * // Get one TaskItem
     * const taskItem = await prisma.taskItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskItemFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskItemClient<$Result.GetResult<Prisma.$TaskItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskItems
     * const taskItems = await prisma.taskItem.findMany()
     * 
     * // Get first 10 TaskItems
     * const taskItems = await prisma.taskItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskItemWithIdOnly = await prisma.taskItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskItemFindManyArgs>(args?: SelectSubset<T, TaskItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskItem.
     * @param {TaskItemCreateArgs} args - Arguments to create a TaskItem.
     * @example
     * // Create one TaskItem
     * const TaskItem = await prisma.taskItem.create({
     *   data: {
     *     // ... data to create a TaskItem
     *   }
     * })
     * 
     */
    create<T extends TaskItemCreateArgs>(args: SelectSubset<T, TaskItemCreateArgs<ExtArgs>>): Prisma__TaskItemClient<$Result.GetResult<Prisma.$TaskItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskItems.
     * @param {TaskItemCreateManyArgs} args - Arguments to create many TaskItems.
     * @example
     * // Create many TaskItems
     * const taskItem = await prisma.taskItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskItemCreateManyArgs>(args?: SelectSubset<T, TaskItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskItems and returns the data saved in the database.
     * @param {TaskItemCreateManyAndReturnArgs} args - Arguments to create many TaskItems.
     * @example
     * // Create many TaskItems
     * const taskItem = await prisma.taskItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskItems and only return the `id`
     * const taskItemWithIdOnly = await prisma.taskItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskItemCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskItem.
     * @param {TaskItemDeleteArgs} args - Arguments to delete one TaskItem.
     * @example
     * // Delete one TaskItem
     * const TaskItem = await prisma.taskItem.delete({
     *   where: {
     *     // ... filter to delete one TaskItem
     *   }
     * })
     * 
     */
    delete<T extends TaskItemDeleteArgs>(args: SelectSubset<T, TaskItemDeleteArgs<ExtArgs>>): Prisma__TaskItemClient<$Result.GetResult<Prisma.$TaskItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskItem.
     * @param {TaskItemUpdateArgs} args - Arguments to update one TaskItem.
     * @example
     * // Update one TaskItem
     * const taskItem = await prisma.taskItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskItemUpdateArgs>(args: SelectSubset<T, TaskItemUpdateArgs<ExtArgs>>): Prisma__TaskItemClient<$Result.GetResult<Prisma.$TaskItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskItems.
     * @param {TaskItemDeleteManyArgs} args - Arguments to filter TaskItems to delete.
     * @example
     * // Delete a few TaskItems
     * const { count } = await prisma.taskItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskItemDeleteManyArgs>(args?: SelectSubset<T, TaskItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskItems
     * const taskItem = await prisma.taskItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskItemUpdateManyArgs>(args: SelectSubset<T, TaskItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskItems and returns the data updated in the database.
     * @param {TaskItemUpdateManyAndReturnArgs} args - Arguments to update many TaskItems.
     * @example
     * // Update many TaskItems
     * const taskItem = await prisma.taskItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskItems and only return the `id`
     * const taskItemWithIdOnly = await prisma.taskItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskItemUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskItem.
     * @param {TaskItemUpsertArgs} args - Arguments to update or create a TaskItem.
     * @example
     * // Update or create a TaskItem
     * const taskItem = await prisma.taskItem.upsert({
     *   create: {
     *     // ... data to create a TaskItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskItem we want to update
     *   }
     * })
     */
    upsert<T extends TaskItemUpsertArgs>(args: SelectSubset<T, TaskItemUpsertArgs<ExtArgs>>): Prisma__TaskItemClient<$Result.GetResult<Prisma.$TaskItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskItemCountArgs} args - Arguments to filter TaskItems to count.
     * @example
     * // Count the number of TaskItems
     * const count = await prisma.taskItem.count({
     *   where: {
     *     // ... the filter for the TaskItems we want to count
     *   }
     * })
    **/
    count<T extends TaskItemCountArgs>(
      args?: Subset<T, TaskItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskItemAggregateArgs>(args: Subset<T, TaskItemAggregateArgs>): Prisma.PrismaPromise<GetTaskItemAggregateType<T>>

    /**
     * Group by TaskItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskItemGroupByArgs['orderBy'] }
        : { orderBy?: TaskItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskItem model
   */
  readonly fields: TaskItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends WorkTaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkTaskDefaultArgs<ExtArgs>>): Prisma__WorkTaskClient<$Result.GetResult<Prisma.$WorkTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orderItem<T extends TaskItem$orderItemArgs<ExtArgs> = {}>(args?: Subset<T, TaskItem$orderItemArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    productVariant<T extends TaskItem$productVariantArgs<ExtArgs> = {}>(args?: Subset<T, TaskItem$productVariantArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    location<T extends TaskItem$locationArgs<ExtArgs> = {}>(args?: Subset<T, TaskItem$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    completedByUser<T extends TaskItem$completedByUserArgs<ExtArgs> = {}>(args?: Subset<T, TaskItem$completedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    allocation<T extends TaskItem$allocationArgs<ExtArgs> = {}>(args?: Subset<T, TaskItem$allocationArgs<ExtArgs>>): Prisma__AllocationClient<$Result.GetResult<Prisma.$AllocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskItem model
   */
  interface TaskItemFieldRefs {
    readonly id: FieldRef<"TaskItem", 'String'>
    readonly taskId: FieldRef<"TaskItem", 'String'>
    readonly orderId: FieldRef<"TaskItem", 'String'>
    readonly orderItemId: FieldRef<"TaskItem", 'String'>
    readonly productVariantId: FieldRef<"TaskItem", 'String'>
    readonly locationId: FieldRef<"TaskItem", 'String'>
    readonly allocationId: FieldRef<"TaskItem", 'String'>
    readonly sequence: FieldRef<"TaskItem", 'Int'>
    readonly quantityRequired: FieldRef<"TaskItem", 'Int'>
    readonly quantityCompleted: FieldRef<"TaskItem", 'Int'>
    readonly status: FieldRef<"TaskItem", 'WorkTaskItemStatus'>
    readonly completedBy: FieldRef<"TaskItem", 'String'>
    readonly completedAt: FieldRef<"TaskItem", 'DateTime'>
    readonly shortReason: FieldRef<"TaskItem", 'String'>
    readonly locationScanned: FieldRef<"TaskItem", 'Boolean'>
    readonly itemScanned: FieldRef<"TaskItem", 'Boolean'>
    readonly createdAt: FieldRef<"TaskItem", 'DateTime'>
    readonly updatedAt: FieldRef<"TaskItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskItem findUnique
   */
  export type TaskItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskItem
     */
    select?: TaskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskItem
     */
    omit?: TaskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskItemInclude<ExtArgs> | null
    /**
     * Filter, which TaskItem to fetch.
     */
    where: TaskItemWhereUniqueInput
  }

  /**
   * TaskItem findUniqueOrThrow
   */
  export type TaskItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskItem
     */
    select?: TaskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskItem
     */
    omit?: TaskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskItemInclude<ExtArgs> | null
    /**
     * Filter, which TaskItem to fetch.
     */
    where: TaskItemWhereUniqueInput
  }

  /**
   * TaskItem findFirst
   */
  export type TaskItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskItem
     */
    select?: TaskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskItem
     */
    omit?: TaskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskItemInclude<ExtArgs> | null
    /**
     * Filter, which TaskItem to fetch.
     */
    where?: TaskItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskItems to fetch.
     */
    orderBy?: TaskItemOrderByWithRelationInput | TaskItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskItems.
     */
    cursor?: TaskItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskItems.
     */
    distinct?: TaskItemScalarFieldEnum | TaskItemScalarFieldEnum[]
  }

  /**
   * TaskItem findFirstOrThrow
   */
  export type TaskItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskItem
     */
    select?: TaskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskItem
     */
    omit?: TaskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskItemInclude<ExtArgs> | null
    /**
     * Filter, which TaskItem to fetch.
     */
    where?: TaskItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskItems to fetch.
     */
    orderBy?: TaskItemOrderByWithRelationInput | TaskItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskItems.
     */
    cursor?: TaskItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskItems.
     */
    distinct?: TaskItemScalarFieldEnum | TaskItemScalarFieldEnum[]
  }

  /**
   * TaskItem findMany
   */
  export type TaskItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskItem
     */
    select?: TaskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskItem
     */
    omit?: TaskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskItemInclude<ExtArgs> | null
    /**
     * Filter, which TaskItems to fetch.
     */
    where?: TaskItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskItems to fetch.
     */
    orderBy?: TaskItemOrderByWithRelationInput | TaskItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskItems.
     */
    cursor?: TaskItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskItems.
     */
    skip?: number
    distinct?: TaskItemScalarFieldEnum | TaskItemScalarFieldEnum[]
  }

  /**
   * TaskItem create
   */
  export type TaskItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskItem
     */
    select?: TaskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskItem
     */
    omit?: TaskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskItemInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskItem.
     */
    data: XOR<TaskItemCreateInput, TaskItemUncheckedCreateInput>
  }

  /**
   * TaskItem createMany
   */
  export type TaskItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskItems.
     */
    data: TaskItemCreateManyInput | TaskItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskItem createManyAndReturn
   */
  export type TaskItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskItem
     */
    select?: TaskItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskItem
     */
    omit?: TaskItemOmit<ExtArgs> | null
    /**
     * The data used to create many TaskItems.
     */
    data: TaskItemCreateManyInput | TaskItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskItem update
   */
  export type TaskItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskItem
     */
    select?: TaskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskItem
     */
    omit?: TaskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskItemInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskItem.
     */
    data: XOR<TaskItemUpdateInput, TaskItemUncheckedUpdateInput>
    /**
     * Choose, which TaskItem to update.
     */
    where: TaskItemWhereUniqueInput
  }

  /**
   * TaskItem updateMany
   */
  export type TaskItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskItems.
     */
    data: XOR<TaskItemUpdateManyMutationInput, TaskItemUncheckedUpdateManyInput>
    /**
     * Filter which TaskItems to update
     */
    where?: TaskItemWhereInput
    /**
     * Limit how many TaskItems to update.
     */
    limit?: number
  }

  /**
   * TaskItem updateManyAndReturn
   */
  export type TaskItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskItem
     */
    select?: TaskItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskItem
     */
    omit?: TaskItemOmit<ExtArgs> | null
    /**
     * The data used to update TaskItems.
     */
    data: XOR<TaskItemUpdateManyMutationInput, TaskItemUncheckedUpdateManyInput>
    /**
     * Filter which TaskItems to update
     */
    where?: TaskItemWhereInput
    /**
     * Limit how many TaskItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskItem upsert
   */
  export type TaskItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskItem
     */
    select?: TaskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskItem
     */
    omit?: TaskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskItemInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskItem to update in case it exists.
     */
    where: TaskItemWhereUniqueInput
    /**
     * In case the TaskItem found by the `where` argument doesn't exist, create a new TaskItem with this data.
     */
    create: XOR<TaskItemCreateInput, TaskItemUncheckedCreateInput>
    /**
     * In case the TaskItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskItemUpdateInput, TaskItemUncheckedUpdateInput>
  }

  /**
   * TaskItem delete
   */
  export type TaskItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskItem
     */
    select?: TaskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskItem
     */
    omit?: TaskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskItemInclude<ExtArgs> | null
    /**
     * Filter which TaskItem to delete.
     */
    where: TaskItemWhereUniqueInput
  }

  /**
   * TaskItem deleteMany
   */
  export type TaskItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskItems to delete
     */
    where?: TaskItemWhereInput
    /**
     * Limit how many TaskItems to delete.
     */
    limit?: number
  }

  /**
   * TaskItem.orderItem
   */
  export type TaskItem$orderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
  }

  /**
   * TaskItem.productVariant
   */
  export type TaskItem$productVariantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    where?: ProductVariantWhereInput
  }

  /**
   * TaskItem.location
   */
  export type TaskItem$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * TaskItem.completedByUser
   */
  export type TaskItem$completedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TaskItem.allocation
   */
  export type TaskItem$allocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allocation
     */
    select?: AllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allocation
     */
    omit?: AllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationInclude<ExtArgs> | null
    where?: AllocationWhereInput
  }

  /**
   * TaskItem without action
   */
  export type TaskItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskItem
     */
    select?: TaskItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskItem
     */
    omit?: TaskItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskItemInclude<ExtArgs> | null
  }


  /**
   * Model TaskEvent
   */

  export type AggregateTaskEvent = {
    _count: TaskEventCountAggregateOutputType | null
    _min: TaskEventMinAggregateOutputType | null
    _max: TaskEventMaxAggregateOutputType | null
  }

  export type TaskEventMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    eventType: $Enums.WorkTaskEventType | null
    userId: string | null
    taskItemId: string | null
    createdAt: Date | null
  }

  export type TaskEventMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    eventType: $Enums.WorkTaskEventType | null
    userId: string | null
    taskItemId: string | null
    createdAt: Date | null
  }

  export type TaskEventCountAggregateOutputType = {
    id: number
    taskId: number
    eventType: number
    userId: number
    taskItemId: number
    data: number
    createdAt: number
    _all: number
  }


  export type TaskEventMinAggregateInputType = {
    id?: true
    taskId?: true
    eventType?: true
    userId?: true
    taskItemId?: true
    createdAt?: true
  }

  export type TaskEventMaxAggregateInputType = {
    id?: true
    taskId?: true
    eventType?: true
    userId?: true
    taskItemId?: true
    createdAt?: true
  }

  export type TaskEventCountAggregateInputType = {
    id?: true
    taskId?: true
    eventType?: true
    userId?: true
    taskItemId?: true
    data?: true
    createdAt?: true
    _all?: true
  }

  export type TaskEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskEvent to aggregate.
     */
    where?: TaskEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskEvents to fetch.
     */
    orderBy?: TaskEventOrderByWithRelationInput | TaskEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskEvents
    **/
    _count?: true | TaskEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskEventMaxAggregateInputType
  }

  export type GetTaskEventAggregateType<T extends TaskEventAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskEvent[P]>
      : GetScalarType<T[P], AggregateTaskEvent[P]>
  }




  export type TaskEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskEventWhereInput
    orderBy?: TaskEventOrderByWithAggregationInput | TaskEventOrderByWithAggregationInput[]
    by: TaskEventScalarFieldEnum[] | TaskEventScalarFieldEnum
    having?: TaskEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskEventCountAggregateInputType | true
    _min?: TaskEventMinAggregateInputType
    _max?: TaskEventMaxAggregateInputType
  }

  export type TaskEventGroupByOutputType = {
    id: string
    taskId: string
    eventType: $Enums.WorkTaskEventType
    userId: string | null
    taskItemId: string | null
    data: JsonValue | null
    createdAt: Date
    _count: TaskEventCountAggregateOutputType | null
    _min: TaskEventMinAggregateOutputType | null
    _max: TaskEventMaxAggregateOutputType | null
  }

  type GetTaskEventGroupByPayload<T extends TaskEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskEventGroupByOutputType[P]>
            : GetScalarType<T[P], TaskEventGroupByOutputType[P]>
        }
      >
    >


  export type TaskEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    eventType?: boolean
    userId?: boolean
    taskItemId?: boolean
    data?: boolean
    createdAt?: boolean
    task?: boolean | WorkTaskDefaultArgs<ExtArgs>
    user?: boolean | TaskEvent$userArgs<ExtArgs>
  }, ExtArgs["result"]["taskEvent"]>

  export type TaskEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    eventType?: boolean
    userId?: boolean
    taskItemId?: boolean
    data?: boolean
    createdAt?: boolean
    task?: boolean | WorkTaskDefaultArgs<ExtArgs>
    user?: boolean | TaskEvent$userArgs<ExtArgs>
  }, ExtArgs["result"]["taskEvent"]>

  export type TaskEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    eventType?: boolean
    userId?: boolean
    taskItemId?: boolean
    data?: boolean
    createdAt?: boolean
    task?: boolean | WorkTaskDefaultArgs<ExtArgs>
    user?: boolean | TaskEvent$userArgs<ExtArgs>
  }, ExtArgs["result"]["taskEvent"]>

  export type TaskEventSelectScalar = {
    id?: boolean
    taskId?: boolean
    eventType?: boolean
    userId?: boolean
    taskItemId?: boolean
    data?: boolean
    createdAt?: boolean
  }

  export type TaskEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "eventType" | "userId" | "taskItemId" | "data" | "createdAt", ExtArgs["result"]["taskEvent"]>
  export type TaskEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | WorkTaskDefaultArgs<ExtArgs>
    user?: boolean | TaskEvent$userArgs<ExtArgs>
  }
  export type TaskEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | WorkTaskDefaultArgs<ExtArgs>
    user?: boolean | TaskEvent$userArgs<ExtArgs>
  }
  export type TaskEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | WorkTaskDefaultArgs<ExtArgs>
    user?: boolean | TaskEvent$userArgs<ExtArgs>
  }

  export type $TaskEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskEvent"
    objects: {
      task: Prisma.$WorkTaskPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      eventType: $Enums.WorkTaskEventType
      userId: string | null
      taskItemId: string | null
      data: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["taskEvent"]>
    composites: {}
  }

  type TaskEventGetPayload<S extends boolean | null | undefined | TaskEventDefaultArgs> = $Result.GetResult<Prisma.$TaskEventPayload, S>

  type TaskEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskEventCountAggregateInputType | true
    }

  export interface TaskEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskEvent'], meta: { name: 'TaskEvent' } }
    /**
     * Find zero or one TaskEvent that matches the filter.
     * @param {TaskEventFindUniqueArgs} args - Arguments to find a TaskEvent
     * @example
     * // Get one TaskEvent
     * const taskEvent = await prisma.taskEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskEventFindUniqueArgs>(args: SelectSubset<T, TaskEventFindUniqueArgs<ExtArgs>>): Prisma__TaskEventClient<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskEventFindUniqueOrThrowArgs} args - Arguments to find a TaskEvent
     * @example
     * // Get one TaskEvent
     * const taskEvent = await prisma.taskEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskEventFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskEventClient<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskEventFindFirstArgs} args - Arguments to find a TaskEvent
     * @example
     * // Get one TaskEvent
     * const taskEvent = await prisma.taskEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskEventFindFirstArgs>(args?: SelectSubset<T, TaskEventFindFirstArgs<ExtArgs>>): Prisma__TaskEventClient<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskEventFindFirstOrThrowArgs} args - Arguments to find a TaskEvent
     * @example
     * // Get one TaskEvent
     * const taskEvent = await prisma.taskEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskEventFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskEventClient<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskEvents
     * const taskEvents = await prisma.taskEvent.findMany()
     * 
     * // Get first 10 TaskEvents
     * const taskEvents = await prisma.taskEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskEventWithIdOnly = await prisma.taskEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskEventFindManyArgs>(args?: SelectSubset<T, TaskEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskEvent.
     * @param {TaskEventCreateArgs} args - Arguments to create a TaskEvent.
     * @example
     * // Create one TaskEvent
     * const TaskEvent = await prisma.taskEvent.create({
     *   data: {
     *     // ... data to create a TaskEvent
     *   }
     * })
     * 
     */
    create<T extends TaskEventCreateArgs>(args: SelectSubset<T, TaskEventCreateArgs<ExtArgs>>): Prisma__TaskEventClient<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskEvents.
     * @param {TaskEventCreateManyArgs} args - Arguments to create many TaskEvents.
     * @example
     * // Create many TaskEvents
     * const taskEvent = await prisma.taskEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskEventCreateManyArgs>(args?: SelectSubset<T, TaskEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskEvents and returns the data saved in the database.
     * @param {TaskEventCreateManyAndReturnArgs} args - Arguments to create many TaskEvents.
     * @example
     * // Create many TaskEvents
     * const taskEvent = await prisma.taskEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskEvents and only return the `id`
     * const taskEventWithIdOnly = await prisma.taskEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskEventCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskEvent.
     * @param {TaskEventDeleteArgs} args - Arguments to delete one TaskEvent.
     * @example
     * // Delete one TaskEvent
     * const TaskEvent = await prisma.taskEvent.delete({
     *   where: {
     *     // ... filter to delete one TaskEvent
     *   }
     * })
     * 
     */
    delete<T extends TaskEventDeleteArgs>(args: SelectSubset<T, TaskEventDeleteArgs<ExtArgs>>): Prisma__TaskEventClient<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskEvent.
     * @param {TaskEventUpdateArgs} args - Arguments to update one TaskEvent.
     * @example
     * // Update one TaskEvent
     * const taskEvent = await prisma.taskEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskEventUpdateArgs>(args: SelectSubset<T, TaskEventUpdateArgs<ExtArgs>>): Prisma__TaskEventClient<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskEvents.
     * @param {TaskEventDeleteManyArgs} args - Arguments to filter TaskEvents to delete.
     * @example
     * // Delete a few TaskEvents
     * const { count } = await prisma.taskEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskEventDeleteManyArgs>(args?: SelectSubset<T, TaskEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskEvents
     * const taskEvent = await prisma.taskEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskEventUpdateManyArgs>(args: SelectSubset<T, TaskEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskEvents and returns the data updated in the database.
     * @param {TaskEventUpdateManyAndReturnArgs} args - Arguments to update many TaskEvents.
     * @example
     * // Update many TaskEvents
     * const taskEvent = await prisma.taskEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskEvents and only return the `id`
     * const taskEventWithIdOnly = await prisma.taskEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskEventUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskEvent.
     * @param {TaskEventUpsertArgs} args - Arguments to update or create a TaskEvent.
     * @example
     * // Update or create a TaskEvent
     * const taskEvent = await prisma.taskEvent.upsert({
     *   create: {
     *     // ... data to create a TaskEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskEvent we want to update
     *   }
     * })
     */
    upsert<T extends TaskEventUpsertArgs>(args: SelectSubset<T, TaskEventUpsertArgs<ExtArgs>>): Prisma__TaskEventClient<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskEventCountArgs} args - Arguments to filter TaskEvents to count.
     * @example
     * // Count the number of TaskEvents
     * const count = await prisma.taskEvent.count({
     *   where: {
     *     // ... the filter for the TaskEvents we want to count
     *   }
     * })
    **/
    count<T extends TaskEventCountArgs>(
      args?: Subset<T, TaskEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskEventAggregateArgs>(args: Subset<T, TaskEventAggregateArgs>): Prisma.PrismaPromise<GetTaskEventAggregateType<T>>

    /**
     * Group by TaskEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskEventGroupByArgs['orderBy'] }
        : { orderBy?: TaskEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskEvent model
   */
  readonly fields: TaskEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends WorkTaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkTaskDefaultArgs<ExtArgs>>): Prisma__WorkTaskClient<$Result.GetResult<Prisma.$WorkTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends TaskEvent$userArgs<ExtArgs> = {}>(args?: Subset<T, TaskEvent$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskEvent model
   */
  interface TaskEventFieldRefs {
    readonly id: FieldRef<"TaskEvent", 'String'>
    readonly taskId: FieldRef<"TaskEvent", 'String'>
    readonly eventType: FieldRef<"TaskEvent", 'WorkTaskEventType'>
    readonly userId: FieldRef<"TaskEvent", 'String'>
    readonly taskItemId: FieldRef<"TaskEvent", 'String'>
    readonly data: FieldRef<"TaskEvent", 'Json'>
    readonly createdAt: FieldRef<"TaskEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskEvent findUnique
   */
  export type TaskEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
    /**
     * Filter, which TaskEvent to fetch.
     */
    where: TaskEventWhereUniqueInput
  }

  /**
   * TaskEvent findUniqueOrThrow
   */
  export type TaskEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
    /**
     * Filter, which TaskEvent to fetch.
     */
    where: TaskEventWhereUniqueInput
  }

  /**
   * TaskEvent findFirst
   */
  export type TaskEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
    /**
     * Filter, which TaskEvent to fetch.
     */
    where?: TaskEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskEvents to fetch.
     */
    orderBy?: TaskEventOrderByWithRelationInput | TaskEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskEvents.
     */
    cursor?: TaskEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskEvents.
     */
    distinct?: TaskEventScalarFieldEnum | TaskEventScalarFieldEnum[]
  }

  /**
   * TaskEvent findFirstOrThrow
   */
  export type TaskEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
    /**
     * Filter, which TaskEvent to fetch.
     */
    where?: TaskEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskEvents to fetch.
     */
    orderBy?: TaskEventOrderByWithRelationInput | TaskEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskEvents.
     */
    cursor?: TaskEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskEvents.
     */
    distinct?: TaskEventScalarFieldEnum | TaskEventScalarFieldEnum[]
  }

  /**
   * TaskEvent findMany
   */
  export type TaskEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
    /**
     * Filter, which TaskEvents to fetch.
     */
    where?: TaskEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskEvents to fetch.
     */
    orderBy?: TaskEventOrderByWithRelationInput | TaskEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskEvents.
     */
    cursor?: TaskEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskEvents.
     */
    skip?: number
    distinct?: TaskEventScalarFieldEnum | TaskEventScalarFieldEnum[]
  }

  /**
   * TaskEvent create
   */
  export type TaskEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskEvent.
     */
    data: XOR<TaskEventCreateInput, TaskEventUncheckedCreateInput>
  }

  /**
   * TaskEvent createMany
   */
  export type TaskEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskEvents.
     */
    data: TaskEventCreateManyInput | TaskEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskEvent createManyAndReturn
   */
  export type TaskEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * The data used to create many TaskEvents.
     */
    data: TaskEventCreateManyInput | TaskEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskEvent update
   */
  export type TaskEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskEvent.
     */
    data: XOR<TaskEventUpdateInput, TaskEventUncheckedUpdateInput>
    /**
     * Choose, which TaskEvent to update.
     */
    where: TaskEventWhereUniqueInput
  }

  /**
   * TaskEvent updateMany
   */
  export type TaskEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskEvents.
     */
    data: XOR<TaskEventUpdateManyMutationInput, TaskEventUncheckedUpdateManyInput>
    /**
     * Filter which TaskEvents to update
     */
    where?: TaskEventWhereInput
    /**
     * Limit how many TaskEvents to update.
     */
    limit?: number
  }

  /**
   * TaskEvent updateManyAndReturn
   */
  export type TaskEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * The data used to update TaskEvents.
     */
    data: XOR<TaskEventUpdateManyMutationInput, TaskEventUncheckedUpdateManyInput>
    /**
     * Filter which TaskEvents to update
     */
    where?: TaskEventWhereInput
    /**
     * Limit how many TaskEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskEvent upsert
   */
  export type TaskEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskEvent to update in case it exists.
     */
    where: TaskEventWhereUniqueInput
    /**
     * In case the TaskEvent found by the `where` argument doesn't exist, create a new TaskEvent with this data.
     */
    create: XOR<TaskEventCreateInput, TaskEventUncheckedCreateInput>
    /**
     * In case the TaskEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskEventUpdateInput, TaskEventUncheckedUpdateInput>
  }

  /**
   * TaskEvent delete
   */
  export type TaskEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
    /**
     * Filter which TaskEvent to delete.
     */
    where: TaskEventWhereUniqueInput
  }

  /**
   * TaskEvent deleteMany
   */
  export type TaskEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskEvents to delete
     */
    where?: TaskEventWhereInput
    /**
     * Limit how many TaskEvents to delete.
     */
    limit?: number
  }

  /**
   * TaskEvent.user
   */
  export type TaskEvent$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TaskEvent without action
   */
  export type TaskEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
  }


  /**
   * Model JobRecord
   */

  export type AggregateJobRecord = {
    _count: JobRecordCountAggregateOutputType | null
    _avg: JobRecordAvgAggregateOutputType | null
    _sum: JobRecordSumAggregateOutputType | null
    _min: JobRecordMinAggregateOutputType | null
    _max: JobRecordMaxAggregateOutputType | null
  }

  export type JobRecordAvgAggregateOutputType = {
    attempts: number | null
  }

  export type JobRecordSumAggregateOutputType = {
    attempts: number | null
  }

  export type JobRecordMinAggregateOutputType = {
    id: string | null
    jobId: string | null
    queue: string | null
    name: string | null
    status: string | null
    error: string | null
    attempts: number | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type JobRecordMaxAggregateOutputType = {
    id: string | null
    jobId: string | null
    queue: string | null
    name: string | null
    status: string | null
    error: string | null
    attempts: number | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type JobRecordCountAggregateOutputType = {
    id: number
    jobId: number
    queue: number
    name: number
    data: number
    status: number
    result: number
    error: number
    attempts: number
    startedAt: number
    completedAt: number
    createdAt: number
    _all: number
  }


  export type JobRecordAvgAggregateInputType = {
    attempts?: true
  }

  export type JobRecordSumAggregateInputType = {
    attempts?: true
  }

  export type JobRecordMinAggregateInputType = {
    id?: true
    jobId?: true
    queue?: true
    name?: true
    status?: true
    error?: true
    attempts?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
  }

  export type JobRecordMaxAggregateInputType = {
    id?: true
    jobId?: true
    queue?: true
    name?: true
    status?: true
    error?: true
    attempts?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
  }

  export type JobRecordCountAggregateInputType = {
    id?: true
    jobId?: true
    queue?: true
    name?: true
    data?: true
    status?: true
    result?: true
    error?: true
    attempts?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    _all?: true
  }

  export type JobRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobRecord to aggregate.
     */
    where?: JobRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRecords to fetch.
     */
    orderBy?: JobRecordOrderByWithRelationInput | JobRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobRecords
    **/
    _count?: true | JobRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobRecordMaxAggregateInputType
  }

  export type GetJobRecordAggregateType<T extends JobRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateJobRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobRecord[P]>
      : GetScalarType<T[P], AggregateJobRecord[P]>
  }




  export type JobRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobRecordWhereInput
    orderBy?: JobRecordOrderByWithAggregationInput | JobRecordOrderByWithAggregationInput[]
    by: JobRecordScalarFieldEnum[] | JobRecordScalarFieldEnum
    having?: JobRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobRecordCountAggregateInputType | true
    _avg?: JobRecordAvgAggregateInputType
    _sum?: JobRecordSumAggregateInputType
    _min?: JobRecordMinAggregateInputType
    _max?: JobRecordMaxAggregateInputType
  }

  export type JobRecordGroupByOutputType = {
    id: string
    jobId: string
    queue: string
    name: string
    data: JsonValue
    status: string
    result: JsonValue | null
    error: string | null
    attempts: number
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date
    _count: JobRecordCountAggregateOutputType | null
    _avg: JobRecordAvgAggregateOutputType | null
    _sum: JobRecordSumAggregateOutputType | null
    _min: JobRecordMinAggregateOutputType | null
    _max: JobRecordMaxAggregateOutputType | null
  }

  type GetJobRecordGroupByPayload<T extends JobRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobRecordGroupByOutputType[P]>
            : GetScalarType<T[P], JobRecordGroupByOutputType[P]>
        }
      >
    >


  export type JobRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    queue?: boolean
    name?: boolean
    data?: boolean
    status?: boolean
    result?: boolean
    error?: boolean
    attempts?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["jobRecord"]>

  export type JobRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    queue?: boolean
    name?: boolean
    data?: boolean
    status?: boolean
    result?: boolean
    error?: boolean
    attempts?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["jobRecord"]>

  export type JobRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    queue?: boolean
    name?: boolean
    data?: boolean
    status?: boolean
    result?: boolean
    error?: boolean
    attempts?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["jobRecord"]>

  export type JobRecordSelectScalar = {
    id?: boolean
    jobId?: boolean
    queue?: boolean
    name?: boolean
    data?: boolean
    status?: boolean
    result?: boolean
    error?: boolean
    attempts?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
  }

  export type JobRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobId" | "queue" | "name" | "data" | "status" | "result" | "error" | "attempts" | "startedAt" | "completedAt" | "createdAt", ExtArgs["result"]["jobRecord"]>

  export type $JobRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobRecord"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobId: string
      queue: string
      name: string
      data: Prisma.JsonValue
      status: string
      result: Prisma.JsonValue | null
      error: string | null
      attempts: number
      startedAt: Date | null
      completedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["jobRecord"]>
    composites: {}
  }

  type JobRecordGetPayload<S extends boolean | null | undefined | JobRecordDefaultArgs> = $Result.GetResult<Prisma.$JobRecordPayload, S>

  type JobRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobRecordCountAggregateInputType | true
    }

  export interface JobRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobRecord'], meta: { name: 'JobRecord' } }
    /**
     * Find zero or one JobRecord that matches the filter.
     * @param {JobRecordFindUniqueArgs} args - Arguments to find a JobRecord
     * @example
     * // Get one JobRecord
     * const jobRecord = await prisma.jobRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobRecordFindUniqueArgs>(args: SelectSubset<T, JobRecordFindUniqueArgs<ExtArgs>>): Prisma__JobRecordClient<$Result.GetResult<Prisma.$JobRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobRecordFindUniqueOrThrowArgs} args - Arguments to find a JobRecord
     * @example
     * // Get one JobRecord
     * const jobRecord = await prisma.jobRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, JobRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobRecordClient<$Result.GetResult<Prisma.$JobRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRecordFindFirstArgs} args - Arguments to find a JobRecord
     * @example
     * // Get one JobRecord
     * const jobRecord = await prisma.jobRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobRecordFindFirstArgs>(args?: SelectSubset<T, JobRecordFindFirstArgs<ExtArgs>>): Prisma__JobRecordClient<$Result.GetResult<Prisma.$JobRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRecordFindFirstOrThrowArgs} args - Arguments to find a JobRecord
     * @example
     * // Get one JobRecord
     * const jobRecord = await prisma.jobRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, JobRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobRecordClient<$Result.GetResult<Prisma.$JobRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobRecords
     * const jobRecords = await prisma.jobRecord.findMany()
     * 
     * // Get first 10 JobRecords
     * const jobRecords = await prisma.jobRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobRecordWithIdOnly = await prisma.jobRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobRecordFindManyArgs>(args?: SelectSubset<T, JobRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobRecord.
     * @param {JobRecordCreateArgs} args - Arguments to create a JobRecord.
     * @example
     * // Create one JobRecord
     * const JobRecord = await prisma.jobRecord.create({
     *   data: {
     *     // ... data to create a JobRecord
     *   }
     * })
     * 
     */
    create<T extends JobRecordCreateArgs>(args: SelectSubset<T, JobRecordCreateArgs<ExtArgs>>): Prisma__JobRecordClient<$Result.GetResult<Prisma.$JobRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobRecords.
     * @param {JobRecordCreateManyArgs} args - Arguments to create many JobRecords.
     * @example
     * // Create many JobRecords
     * const jobRecord = await prisma.jobRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobRecordCreateManyArgs>(args?: SelectSubset<T, JobRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobRecords and returns the data saved in the database.
     * @param {JobRecordCreateManyAndReturnArgs} args - Arguments to create many JobRecords.
     * @example
     * // Create many JobRecords
     * const jobRecord = await prisma.jobRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobRecords and only return the `id`
     * const jobRecordWithIdOnly = await prisma.jobRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, JobRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobRecord.
     * @param {JobRecordDeleteArgs} args - Arguments to delete one JobRecord.
     * @example
     * // Delete one JobRecord
     * const JobRecord = await prisma.jobRecord.delete({
     *   where: {
     *     // ... filter to delete one JobRecord
     *   }
     * })
     * 
     */
    delete<T extends JobRecordDeleteArgs>(args: SelectSubset<T, JobRecordDeleteArgs<ExtArgs>>): Prisma__JobRecordClient<$Result.GetResult<Prisma.$JobRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobRecord.
     * @param {JobRecordUpdateArgs} args - Arguments to update one JobRecord.
     * @example
     * // Update one JobRecord
     * const jobRecord = await prisma.jobRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobRecordUpdateArgs>(args: SelectSubset<T, JobRecordUpdateArgs<ExtArgs>>): Prisma__JobRecordClient<$Result.GetResult<Prisma.$JobRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobRecords.
     * @param {JobRecordDeleteManyArgs} args - Arguments to filter JobRecords to delete.
     * @example
     * // Delete a few JobRecords
     * const { count } = await prisma.jobRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobRecordDeleteManyArgs>(args?: SelectSubset<T, JobRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobRecords
     * const jobRecord = await prisma.jobRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobRecordUpdateManyArgs>(args: SelectSubset<T, JobRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobRecords and returns the data updated in the database.
     * @param {JobRecordUpdateManyAndReturnArgs} args - Arguments to update many JobRecords.
     * @example
     * // Update many JobRecords
     * const jobRecord = await prisma.jobRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobRecords and only return the `id`
     * const jobRecordWithIdOnly = await prisma.jobRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, JobRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobRecord.
     * @param {JobRecordUpsertArgs} args - Arguments to update or create a JobRecord.
     * @example
     * // Update or create a JobRecord
     * const jobRecord = await prisma.jobRecord.upsert({
     *   create: {
     *     // ... data to create a JobRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobRecord we want to update
     *   }
     * })
     */
    upsert<T extends JobRecordUpsertArgs>(args: SelectSubset<T, JobRecordUpsertArgs<ExtArgs>>): Prisma__JobRecordClient<$Result.GetResult<Prisma.$JobRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRecordCountArgs} args - Arguments to filter JobRecords to count.
     * @example
     * // Count the number of JobRecords
     * const count = await prisma.jobRecord.count({
     *   where: {
     *     // ... the filter for the JobRecords we want to count
     *   }
     * })
    **/
    count<T extends JobRecordCountArgs>(
      args?: Subset<T, JobRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobRecordAggregateArgs>(args: Subset<T, JobRecordAggregateArgs>): Prisma.PrismaPromise<GetJobRecordAggregateType<T>>

    /**
     * Group by JobRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobRecordGroupByArgs['orderBy'] }
        : { orderBy?: JobRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobRecord model
   */
  readonly fields: JobRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobRecord model
   */
  interface JobRecordFieldRefs {
    readonly id: FieldRef<"JobRecord", 'String'>
    readonly jobId: FieldRef<"JobRecord", 'String'>
    readonly queue: FieldRef<"JobRecord", 'String'>
    readonly name: FieldRef<"JobRecord", 'String'>
    readonly data: FieldRef<"JobRecord", 'Json'>
    readonly status: FieldRef<"JobRecord", 'String'>
    readonly result: FieldRef<"JobRecord", 'Json'>
    readonly error: FieldRef<"JobRecord", 'String'>
    readonly attempts: FieldRef<"JobRecord", 'Int'>
    readonly startedAt: FieldRef<"JobRecord", 'DateTime'>
    readonly completedAt: FieldRef<"JobRecord", 'DateTime'>
    readonly createdAt: FieldRef<"JobRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobRecord findUnique
   */
  export type JobRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRecord
     */
    select?: JobRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRecord
     */
    omit?: JobRecordOmit<ExtArgs> | null
    /**
     * Filter, which JobRecord to fetch.
     */
    where: JobRecordWhereUniqueInput
  }

  /**
   * JobRecord findUniqueOrThrow
   */
  export type JobRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRecord
     */
    select?: JobRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRecord
     */
    omit?: JobRecordOmit<ExtArgs> | null
    /**
     * Filter, which JobRecord to fetch.
     */
    where: JobRecordWhereUniqueInput
  }

  /**
   * JobRecord findFirst
   */
  export type JobRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRecord
     */
    select?: JobRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRecord
     */
    omit?: JobRecordOmit<ExtArgs> | null
    /**
     * Filter, which JobRecord to fetch.
     */
    where?: JobRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRecords to fetch.
     */
    orderBy?: JobRecordOrderByWithRelationInput | JobRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobRecords.
     */
    cursor?: JobRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobRecords.
     */
    distinct?: JobRecordScalarFieldEnum | JobRecordScalarFieldEnum[]
  }

  /**
   * JobRecord findFirstOrThrow
   */
  export type JobRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRecord
     */
    select?: JobRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRecord
     */
    omit?: JobRecordOmit<ExtArgs> | null
    /**
     * Filter, which JobRecord to fetch.
     */
    where?: JobRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRecords to fetch.
     */
    orderBy?: JobRecordOrderByWithRelationInput | JobRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobRecords.
     */
    cursor?: JobRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobRecords.
     */
    distinct?: JobRecordScalarFieldEnum | JobRecordScalarFieldEnum[]
  }

  /**
   * JobRecord findMany
   */
  export type JobRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRecord
     */
    select?: JobRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRecord
     */
    omit?: JobRecordOmit<ExtArgs> | null
    /**
     * Filter, which JobRecords to fetch.
     */
    where?: JobRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRecords to fetch.
     */
    orderBy?: JobRecordOrderByWithRelationInput | JobRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobRecords.
     */
    cursor?: JobRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRecords.
     */
    skip?: number
    distinct?: JobRecordScalarFieldEnum | JobRecordScalarFieldEnum[]
  }

  /**
   * JobRecord create
   */
  export type JobRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRecord
     */
    select?: JobRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRecord
     */
    omit?: JobRecordOmit<ExtArgs> | null
    /**
     * The data needed to create a JobRecord.
     */
    data: XOR<JobRecordCreateInput, JobRecordUncheckedCreateInput>
  }

  /**
   * JobRecord createMany
   */
  export type JobRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobRecords.
     */
    data: JobRecordCreateManyInput | JobRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobRecord createManyAndReturn
   */
  export type JobRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRecord
     */
    select?: JobRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobRecord
     */
    omit?: JobRecordOmit<ExtArgs> | null
    /**
     * The data used to create many JobRecords.
     */
    data: JobRecordCreateManyInput | JobRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobRecord update
   */
  export type JobRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRecord
     */
    select?: JobRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRecord
     */
    omit?: JobRecordOmit<ExtArgs> | null
    /**
     * The data needed to update a JobRecord.
     */
    data: XOR<JobRecordUpdateInput, JobRecordUncheckedUpdateInput>
    /**
     * Choose, which JobRecord to update.
     */
    where: JobRecordWhereUniqueInput
  }

  /**
   * JobRecord updateMany
   */
  export type JobRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobRecords.
     */
    data: XOR<JobRecordUpdateManyMutationInput, JobRecordUncheckedUpdateManyInput>
    /**
     * Filter which JobRecords to update
     */
    where?: JobRecordWhereInput
    /**
     * Limit how many JobRecords to update.
     */
    limit?: number
  }

  /**
   * JobRecord updateManyAndReturn
   */
  export type JobRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRecord
     */
    select?: JobRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobRecord
     */
    omit?: JobRecordOmit<ExtArgs> | null
    /**
     * The data used to update JobRecords.
     */
    data: XOR<JobRecordUpdateManyMutationInput, JobRecordUncheckedUpdateManyInput>
    /**
     * Filter which JobRecords to update
     */
    where?: JobRecordWhereInput
    /**
     * Limit how many JobRecords to update.
     */
    limit?: number
  }

  /**
   * JobRecord upsert
   */
  export type JobRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRecord
     */
    select?: JobRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRecord
     */
    omit?: JobRecordOmit<ExtArgs> | null
    /**
     * The filter to search for the JobRecord to update in case it exists.
     */
    where: JobRecordWhereUniqueInput
    /**
     * In case the JobRecord found by the `where` argument doesn't exist, create a new JobRecord with this data.
     */
    create: XOR<JobRecordCreateInput, JobRecordUncheckedCreateInput>
    /**
     * In case the JobRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobRecordUpdateInput, JobRecordUncheckedUpdateInput>
  }

  /**
   * JobRecord delete
   */
  export type JobRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRecord
     */
    select?: JobRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRecord
     */
    omit?: JobRecordOmit<ExtArgs> | null
    /**
     * Filter which JobRecord to delete.
     */
    where: JobRecordWhereUniqueInput
  }

  /**
   * JobRecord deleteMany
   */
  export type JobRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobRecords to delete
     */
    where?: JobRecordWhereInput
    /**
     * Limit how many JobRecords to delete.
     */
    limit?: number
  }

  /**
   * JobRecord without action
   */
  export type JobRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRecord
     */
    select?: JobRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRecord
     */
    omit?: JobRecordOmit<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    correlationId: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    correlationId: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entityType: number
    entityId: number
    changes: number
    correlationId: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    correlationId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    correlationId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    changes?: true
    correlationId?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    entityType: string
    entityId: string
    changes: JsonValue | null
    correlationId: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    correlationId?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    correlationId?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    correlationId?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    correlationId?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entityType" | "entityId" | "changes" | "correlationId" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      entityType: string
      entityId: string
      changes: Prisma.JsonValue | null
      correlationId: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly changes: FieldRef<"AuditLog", 'Json'>
    readonly correlationId: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    title: string
    message: string
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "message" | "read" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      title: string
      message: string
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    image: 'image',
    role: 'role',
    active: 'active',
    emailVerified: 'emailVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    revokedAt: 'revokedAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    name: 'name',
    description: 'description',
    brand: 'brand',
    category: 'category',
    shopifyProductId: 'shopifyProductId',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductVariantScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    sku: 'sku',
    upc: 'upc',
    barcode: 'barcode',
    name: 'name',
    imageUrl: 'imageUrl',
    shopifyVariantId: 'shopifyVariantId',
    costPrice: 'costPrice',
    sellingPrice: 'sellingPrice',
    weight: 'weight',
    trackLots: 'trackLots',
    trackExpiry: 'trackExpiry',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductVariantScalarFieldEnum = (typeof ProductVariantScalarFieldEnum)[keyof typeof ProductVariantScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    barcode: 'barcode',
    type: 'type',
    zone: 'zone',
    aisle: 'aisle',
    rack: 'rack',
    shelf: 'shelf',
    bin: 'bin',
    pickSequence: 'pickSequence',
    isPickable: 'isPickable',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const InventoryUnitScalarFieldEnum: {
    id: 'id',
    productVariantId: 'productVariantId',
    locationId: 'locationId',
    quantity: 'quantity',
    status: 'status',
    lotNumber: 'lotNumber',
    expiryDate: 'expiryDate',
    receivedAt: 'receivedAt',
    receivedFrom: 'receivedFrom',
    unitCost: 'unitCost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryUnitScalarFieldEnum = (typeof InventoryUnitScalarFieldEnum)[keyof typeof InventoryUnitScalarFieldEnum]


  export const AllocationScalarFieldEnum: {
    id: 'id',
    inventoryUnitId: 'inventoryUnitId',
    orderId: 'orderId',
    orderItemId: 'orderItemId',
    productVariantId: 'productVariantId',
    locationId: 'locationId',
    quantity: 'quantity',
    lotNumber: 'lotNumber',
    status: 'status',
    allocatedAt: 'allocatedAt',
    releasedAt: 'releasedAt',
    pickedAt: 'pickedAt',
    taskItemId: 'taskItemId'
  };

  export type AllocationScalarFieldEnum = (typeof AllocationScalarFieldEnum)[keyof typeof AllocationScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    shopifyOrderId: 'shopifyOrderId',
    customerId: 'customerId',
    customerName: 'customerName',
    customerEmail: 'customerEmail',
    shippingAddress: 'shippingAddress',
    billingAddress: 'billingAddress',
    shopifyLineItems: 'shopifyLineItems',
    status: 'status',
    paymentStatus: 'paymentStatus',
    priority: 'priority',
    holdReason: 'holdReason',
    holdAt: 'holdAt',
    holdBy: 'holdBy',
    unmatchedItems: 'unmatchedItems',
    totalAmount: 'totalAmount',
    warehouseId: 'warehouseId',
    trackingNumber: 'trackingNumber',
    shippedAt: 'shippedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productVariantId: 'productVariantId',
    sku: 'sku',
    quantity: 'quantity',
    quantityAllocated: 'quantityAllocated',
    quantityPicked: 'quantityPicked',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    matched: 'matched',
    matchError: 'matchError',
    shopifyLineItemId: 'shopifyLineItemId',
    shopifyFulfillmentOrderLineItemId: 'shopifyFulfillmentOrderLineItemId'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const WorkTaskScalarFieldEnum: {
    id: 'id',
    taskNumber: 'taskNumber',
    type: 'type',
    status: 'status',
    priority: 'priority',
    idempotencyKey: 'idempotencyKey',
    assignedTo: 'assignedTo',
    assignedAt: 'assignedAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    blockReason: 'blockReason',
    blockedAt: 'blockedAt',
    orderIds: 'orderIds',
    totalOrders: 'totalOrders',
    completedOrders: 'completedOrders',
    totalItems: 'totalItems',
    completedItems: 'completedItems',
    shortItems: 'shortItems',
    skippedItems: 'skippedItems',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkTaskScalarFieldEnum = (typeof WorkTaskScalarFieldEnum)[keyof typeof WorkTaskScalarFieldEnum]


  export const TaskItemScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    orderId: 'orderId',
    orderItemId: 'orderItemId',
    productVariantId: 'productVariantId',
    locationId: 'locationId',
    allocationId: 'allocationId',
    sequence: 'sequence',
    quantityRequired: 'quantityRequired',
    quantityCompleted: 'quantityCompleted',
    status: 'status',
    completedBy: 'completedBy',
    completedAt: 'completedAt',
    shortReason: 'shortReason',
    locationScanned: 'locationScanned',
    itemScanned: 'itemScanned',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskItemScalarFieldEnum = (typeof TaskItemScalarFieldEnum)[keyof typeof TaskItemScalarFieldEnum]


  export const TaskEventScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    eventType: 'eventType',
    userId: 'userId',
    taskItemId: 'taskItemId',
    data: 'data',
    createdAt: 'createdAt'
  };

  export type TaskEventScalarFieldEnum = (typeof TaskEventScalarFieldEnum)[keyof typeof TaskEventScalarFieldEnum]


  export const JobRecordScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    queue: 'queue',
    name: 'name',
    data: 'data',
    status: 'status',
    result: 'result',
    error: 'error',
    attempts: 'attempts',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt'
  };

  export type JobRecordScalarFieldEnum = (typeof JobRecordScalarFieldEnum)[keyof typeof JobRecordScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    changes: 'changes',
    correlationId: 'correlationId',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'LocationType'
   */
  export type EnumLocationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LocationType'>
    


  /**
   * Reference to a field of type 'LocationType[]'
   */
  export type ListEnumLocationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LocationType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'InventoryStatus'
   */
  export type EnumInventoryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryStatus'>
    


  /**
   * Reference to a field of type 'InventoryStatus[]'
   */
  export type ListEnumInventoryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryStatus[]'>
    


  /**
   * Reference to a field of type 'AllocationStatus'
   */
  export type EnumAllocationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AllocationStatus'>
    


  /**
   * Reference to a field of type 'AllocationStatus[]'
   */
  export type ListEnumAllocationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AllocationStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'WorkTaskType'
   */
  export type EnumWorkTaskTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkTaskType'>
    


  /**
   * Reference to a field of type 'WorkTaskType[]'
   */
  export type ListEnumWorkTaskTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkTaskType[]'>
    


  /**
   * Reference to a field of type 'WorkTaskStatus'
   */
  export type EnumWorkTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkTaskStatus'>
    


  /**
   * Reference to a field of type 'WorkTaskStatus[]'
   */
  export type ListEnumWorkTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkTaskStatus[]'>
    


  /**
   * Reference to a field of type 'WorkTaskBlockReason'
   */
  export type EnumWorkTaskBlockReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkTaskBlockReason'>
    


  /**
   * Reference to a field of type 'WorkTaskBlockReason[]'
   */
  export type ListEnumWorkTaskBlockReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkTaskBlockReason[]'>
    


  /**
   * Reference to a field of type 'WorkTaskItemStatus'
   */
  export type EnumWorkTaskItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkTaskItemStatus'>
    


  /**
   * Reference to a field of type 'WorkTaskItemStatus[]'
   */
  export type ListEnumWorkTaskItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkTaskItemStatus[]'>
    


  /**
   * Reference to a field of type 'WorkTaskEventType'
   */
  export type EnumWorkTaskEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkTaskEventType'>
    


  /**
   * Reference to a field of type 'WorkTaskEventType[]'
   */
  export type ListEnumWorkTaskEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkTaskEventType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    active?: BoolFilter<"User"> | boolean
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    refreshTokens?: RefreshTokenListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    assignedTasks?: WorkTaskListRelationFilter
    taskEvents?: TaskEventListRelationFilter
    completedTaskItems?: TaskItemListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    active?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    passwordResetTokens?: PasswordResetTokenOrderByRelationAggregateInput
    assignedTasks?: WorkTaskOrderByRelationAggregateInput
    taskEvents?: TaskEventOrderByRelationAggregateInput
    completedTaskItems?: TaskItemOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    active?: BoolFilter<"User"> | boolean
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    refreshTokens?: RefreshTokenListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    assignedTasks?: WorkTaskListRelationFilter
    taskEvents?: TaskEventListRelationFilter
    completedTaskItems?: TaskItemListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    active?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    active?: BoolWithAggregatesFilter<"User"> | boolean
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"RefreshToken"> | Date | string | null
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    userId?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    userId?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    sku?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    brand?: StringNullableFilter<"Product"> | string | null
    category?: StringNullableFilter<"Product"> | string | null
    shopifyProductId?: StringNullableFilter<"Product"> | string | null
    active?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    variants?: ProductVariantListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    brand?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    shopifyProductId?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    variants?: ProductVariantOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    shopifyProductId?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    brand?: StringNullableFilter<"Product"> | string | null
    category?: StringNullableFilter<"Product"> | string | null
    active?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    variants?: ProductVariantListRelationFilter
  }, "id" | "sku" | "shopifyProductId">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    brand?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    shopifyProductId?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    sku?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    brand?: StringNullableWithAggregatesFilter<"Product"> | string | null
    category?: StringNullableWithAggregatesFilter<"Product"> | string | null
    shopifyProductId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    active?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type ProductVariantWhereInput = {
    AND?: ProductVariantWhereInput | ProductVariantWhereInput[]
    OR?: ProductVariantWhereInput[]
    NOT?: ProductVariantWhereInput | ProductVariantWhereInput[]
    id?: StringFilter<"ProductVariant"> | string
    productId?: StringFilter<"ProductVariant"> | string
    sku?: StringFilter<"ProductVariant"> | string
    upc?: StringNullableFilter<"ProductVariant"> | string | null
    barcode?: StringNullableFilter<"ProductVariant"> | string | null
    name?: StringFilter<"ProductVariant"> | string
    imageUrl?: StringNullableFilter<"ProductVariant"> | string | null
    shopifyVariantId?: StringNullableFilter<"ProductVariant"> | string | null
    costPrice?: DecimalNullableFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string | null
    sellingPrice?: DecimalNullableFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string | null
    weight?: DecimalNullableFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string | null
    trackLots?: BoolFilter<"ProductVariant"> | boolean
    trackExpiry?: BoolFilter<"ProductVariant"> | boolean
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    orderItems?: OrderItemListRelationFilter
    inventoryUnits?: InventoryUnitListRelationFilter
    taskItems?: TaskItemListRelationFilter
    allocations?: AllocationListRelationFilter
  }

  export type ProductVariantOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    upc?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    name?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    shopifyVariantId?: SortOrderInput | SortOrder
    costPrice?: SortOrderInput | SortOrder
    sellingPrice?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    trackLots?: SortOrder
    trackExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    inventoryUnits?: InventoryUnitOrderByRelationAggregateInput
    taskItems?: TaskItemOrderByRelationAggregateInput
    allocations?: AllocationOrderByRelationAggregateInput
  }

  export type ProductVariantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    upc?: string
    shopifyVariantId?: string
    AND?: ProductVariantWhereInput | ProductVariantWhereInput[]
    OR?: ProductVariantWhereInput[]
    NOT?: ProductVariantWhereInput | ProductVariantWhereInput[]
    productId?: StringFilter<"ProductVariant"> | string
    barcode?: StringNullableFilter<"ProductVariant"> | string | null
    name?: StringFilter<"ProductVariant"> | string
    imageUrl?: StringNullableFilter<"ProductVariant"> | string | null
    costPrice?: DecimalNullableFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string | null
    sellingPrice?: DecimalNullableFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string | null
    weight?: DecimalNullableFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string | null
    trackLots?: BoolFilter<"ProductVariant"> | boolean
    trackExpiry?: BoolFilter<"ProductVariant"> | boolean
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    orderItems?: OrderItemListRelationFilter
    inventoryUnits?: InventoryUnitListRelationFilter
    taskItems?: TaskItemListRelationFilter
    allocations?: AllocationListRelationFilter
  }, "id" | "sku" | "upc" | "shopifyVariantId">

  export type ProductVariantOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    upc?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    name?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    shopifyVariantId?: SortOrderInput | SortOrder
    costPrice?: SortOrderInput | SortOrder
    sellingPrice?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    trackLots?: SortOrder
    trackExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductVariantCountOrderByAggregateInput
    _avg?: ProductVariantAvgOrderByAggregateInput
    _max?: ProductVariantMaxOrderByAggregateInput
    _min?: ProductVariantMinOrderByAggregateInput
    _sum?: ProductVariantSumOrderByAggregateInput
  }

  export type ProductVariantScalarWhereWithAggregatesInput = {
    AND?: ProductVariantScalarWhereWithAggregatesInput | ProductVariantScalarWhereWithAggregatesInput[]
    OR?: ProductVariantScalarWhereWithAggregatesInput[]
    NOT?: ProductVariantScalarWhereWithAggregatesInput | ProductVariantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductVariant"> | string
    productId?: StringWithAggregatesFilter<"ProductVariant"> | string
    sku?: StringWithAggregatesFilter<"ProductVariant"> | string
    upc?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    barcode?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    name?: StringWithAggregatesFilter<"ProductVariant"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    shopifyVariantId?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    costPrice?: DecimalNullableWithAggregatesFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string | null
    sellingPrice?: DecimalNullableWithAggregatesFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string | null
    weight?: DecimalNullableWithAggregatesFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string | null
    trackLots?: BoolWithAggregatesFilter<"ProductVariant"> | boolean
    trackExpiry?: BoolWithAggregatesFilter<"ProductVariant"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductVariant"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    barcode?: StringNullableFilter<"Location"> | string | null
    type?: EnumLocationTypeFilter<"Location"> | $Enums.LocationType
    zone?: StringNullableFilter<"Location"> | string | null
    aisle?: StringNullableFilter<"Location"> | string | null
    rack?: StringNullableFilter<"Location"> | string | null
    shelf?: StringNullableFilter<"Location"> | string | null
    bin?: StringNullableFilter<"Location"> | string | null
    pickSequence?: IntNullableFilter<"Location"> | number | null
    isPickable?: BoolFilter<"Location"> | boolean
    active?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    inventoryUnits?: InventoryUnitListRelationFilter
    taskItems?: TaskItemListRelationFilter
    allocations?: AllocationListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrderInput | SortOrder
    type?: SortOrder
    zone?: SortOrderInput | SortOrder
    aisle?: SortOrderInput | SortOrder
    rack?: SortOrderInput | SortOrder
    shelf?: SortOrderInput | SortOrder
    bin?: SortOrderInput | SortOrder
    pickSequence?: SortOrderInput | SortOrder
    isPickable?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inventoryUnits?: InventoryUnitOrderByRelationAggregateInput
    taskItems?: TaskItemOrderByRelationAggregateInput
    allocations?: AllocationOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    barcode?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    type?: EnumLocationTypeFilter<"Location"> | $Enums.LocationType
    zone?: StringNullableFilter<"Location"> | string | null
    aisle?: StringNullableFilter<"Location"> | string | null
    rack?: StringNullableFilter<"Location"> | string | null
    shelf?: StringNullableFilter<"Location"> | string | null
    bin?: StringNullableFilter<"Location"> | string | null
    pickSequence?: IntNullableFilter<"Location"> | number | null
    isPickable?: BoolFilter<"Location"> | boolean
    active?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    inventoryUnits?: InventoryUnitListRelationFilter
    taskItems?: TaskItemListRelationFilter
    allocations?: AllocationListRelationFilter
  }, "id" | "name" | "barcode">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrderInput | SortOrder
    type?: SortOrder
    zone?: SortOrderInput | SortOrder
    aisle?: SortOrderInput | SortOrder
    rack?: SortOrderInput | SortOrder
    shelf?: SortOrderInput | SortOrder
    bin?: SortOrderInput | SortOrder
    pickSequence?: SortOrderInput | SortOrder
    isPickable?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    name?: StringWithAggregatesFilter<"Location"> | string
    barcode?: StringNullableWithAggregatesFilter<"Location"> | string | null
    type?: EnumLocationTypeWithAggregatesFilter<"Location"> | $Enums.LocationType
    zone?: StringNullableWithAggregatesFilter<"Location"> | string | null
    aisle?: StringNullableWithAggregatesFilter<"Location"> | string | null
    rack?: StringNullableWithAggregatesFilter<"Location"> | string | null
    shelf?: StringNullableWithAggregatesFilter<"Location"> | string | null
    bin?: StringNullableWithAggregatesFilter<"Location"> | string | null
    pickSequence?: IntNullableWithAggregatesFilter<"Location"> | number | null
    isPickable?: BoolWithAggregatesFilter<"Location"> | boolean
    active?: BoolWithAggregatesFilter<"Location"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
  }

  export type InventoryUnitWhereInput = {
    AND?: InventoryUnitWhereInput | InventoryUnitWhereInput[]
    OR?: InventoryUnitWhereInput[]
    NOT?: InventoryUnitWhereInput | InventoryUnitWhereInput[]
    id?: StringFilter<"InventoryUnit"> | string
    productVariantId?: StringFilter<"InventoryUnit"> | string
    locationId?: StringFilter<"InventoryUnit"> | string
    quantity?: IntFilter<"InventoryUnit"> | number
    status?: EnumInventoryStatusFilter<"InventoryUnit"> | $Enums.InventoryStatus
    lotNumber?: StringNullableFilter<"InventoryUnit"> | string | null
    expiryDate?: DateTimeNullableFilter<"InventoryUnit"> | Date | string | null
    receivedAt?: DateTimeFilter<"InventoryUnit"> | Date | string
    receivedFrom?: StringNullableFilter<"InventoryUnit"> | string | null
    unitCost?: DecimalNullableFilter<"InventoryUnit"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"InventoryUnit"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryUnit"> | Date | string
    productVariant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    allocations?: AllocationListRelationFilter
  }

  export type InventoryUnitOrderByWithRelationInput = {
    id?: SortOrder
    productVariantId?: SortOrder
    locationId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    lotNumber?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    receivedAt?: SortOrder
    receivedFrom?: SortOrderInput | SortOrder
    unitCost?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productVariant?: ProductVariantOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    allocations?: AllocationOrderByRelationAggregateInput
  }

  export type InventoryUnitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryUnitWhereInput | InventoryUnitWhereInput[]
    OR?: InventoryUnitWhereInput[]
    NOT?: InventoryUnitWhereInput | InventoryUnitWhereInput[]
    productVariantId?: StringFilter<"InventoryUnit"> | string
    locationId?: StringFilter<"InventoryUnit"> | string
    quantity?: IntFilter<"InventoryUnit"> | number
    status?: EnumInventoryStatusFilter<"InventoryUnit"> | $Enums.InventoryStatus
    lotNumber?: StringNullableFilter<"InventoryUnit"> | string | null
    expiryDate?: DateTimeNullableFilter<"InventoryUnit"> | Date | string | null
    receivedAt?: DateTimeFilter<"InventoryUnit"> | Date | string
    receivedFrom?: StringNullableFilter<"InventoryUnit"> | string | null
    unitCost?: DecimalNullableFilter<"InventoryUnit"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"InventoryUnit"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryUnit"> | Date | string
    productVariant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    allocations?: AllocationListRelationFilter
  }, "id">

  export type InventoryUnitOrderByWithAggregationInput = {
    id?: SortOrder
    productVariantId?: SortOrder
    locationId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    lotNumber?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    receivedAt?: SortOrder
    receivedFrom?: SortOrderInput | SortOrder
    unitCost?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryUnitCountOrderByAggregateInput
    _avg?: InventoryUnitAvgOrderByAggregateInput
    _max?: InventoryUnitMaxOrderByAggregateInput
    _min?: InventoryUnitMinOrderByAggregateInput
    _sum?: InventoryUnitSumOrderByAggregateInput
  }

  export type InventoryUnitScalarWhereWithAggregatesInput = {
    AND?: InventoryUnitScalarWhereWithAggregatesInput | InventoryUnitScalarWhereWithAggregatesInput[]
    OR?: InventoryUnitScalarWhereWithAggregatesInput[]
    NOT?: InventoryUnitScalarWhereWithAggregatesInput | InventoryUnitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryUnit"> | string
    productVariantId?: StringWithAggregatesFilter<"InventoryUnit"> | string
    locationId?: StringWithAggregatesFilter<"InventoryUnit"> | string
    quantity?: IntWithAggregatesFilter<"InventoryUnit"> | number
    status?: EnumInventoryStatusWithAggregatesFilter<"InventoryUnit"> | $Enums.InventoryStatus
    lotNumber?: StringNullableWithAggregatesFilter<"InventoryUnit"> | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"InventoryUnit"> | Date | string | null
    receivedAt?: DateTimeWithAggregatesFilter<"InventoryUnit"> | Date | string
    receivedFrom?: StringNullableWithAggregatesFilter<"InventoryUnit"> | string | null
    unitCost?: DecimalNullableWithAggregatesFilter<"InventoryUnit"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InventoryUnit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InventoryUnit"> | Date | string
  }

  export type AllocationWhereInput = {
    AND?: AllocationWhereInput | AllocationWhereInput[]
    OR?: AllocationWhereInput[]
    NOT?: AllocationWhereInput | AllocationWhereInput[]
    id?: StringFilter<"Allocation"> | string
    inventoryUnitId?: StringFilter<"Allocation"> | string
    orderId?: StringFilter<"Allocation"> | string
    orderItemId?: StringNullableFilter<"Allocation"> | string | null
    productVariantId?: StringFilter<"Allocation"> | string
    locationId?: StringFilter<"Allocation"> | string
    quantity?: IntFilter<"Allocation"> | number
    lotNumber?: StringNullableFilter<"Allocation"> | string | null
    status?: EnumAllocationStatusFilter<"Allocation"> | $Enums.AllocationStatus
    allocatedAt?: DateTimeFilter<"Allocation"> | Date | string
    releasedAt?: DateTimeNullableFilter<"Allocation"> | Date | string | null
    pickedAt?: DateTimeNullableFilter<"Allocation"> | Date | string | null
    taskItemId?: StringNullableFilter<"Allocation"> | string | null
    inventoryUnit?: XOR<InventoryUnitScalarRelationFilter, InventoryUnitWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    orderItem?: XOR<OrderItemNullableScalarRelationFilter, OrderItemWhereInput> | null
    productVariant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    taskItem?: XOR<TaskItemNullableScalarRelationFilter, TaskItemWhereInput> | null
  }

  export type AllocationOrderByWithRelationInput = {
    id?: SortOrder
    inventoryUnitId?: SortOrder
    orderId?: SortOrder
    orderItemId?: SortOrderInput | SortOrder
    productVariantId?: SortOrder
    locationId?: SortOrder
    quantity?: SortOrder
    lotNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    allocatedAt?: SortOrder
    releasedAt?: SortOrderInput | SortOrder
    pickedAt?: SortOrderInput | SortOrder
    taskItemId?: SortOrderInput | SortOrder
    inventoryUnit?: InventoryUnitOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    orderItem?: OrderItemOrderByWithRelationInput
    productVariant?: ProductVariantOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    taskItem?: TaskItemOrderByWithRelationInput
  }

  export type AllocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    taskItemId?: string
    AND?: AllocationWhereInput | AllocationWhereInput[]
    OR?: AllocationWhereInput[]
    NOT?: AllocationWhereInput | AllocationWhereInput[]
    inventoryUnitId?: StringFilter<"Allocation"> | string
    orderId?: StringFilter<"Allocation"> | string
    orderItemId?: StringNullableFilter<"Allocation"> | string | null
    productVariantId?: StringFilter<"Allocation"> | string
    locationId?: StringFilter<"Allocation"> | string
    quantity?: IntFilter<"Allocation"> | number
    lotNumber?: StringNullableFilter<"Allocation"> | string | null
    status?: EnumAllocationStatusFilter<"Allocation"> | $Enums.AllocationStatus
    allocatedAt?: DateTimeFilter<"Allocation"> | Date | string
    releasedAt?: DateTimeNullableFilter<"Allocation"> | Date | string | null
    pickedAt?: DateTimeNullableFilter<"Allocation"> | Date | string | null
    inventoryUnit?: XOR<InventoryUnitScalarRelationFilter, InventoryUnitWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    orderItem?: XOR<OrderItemNullableScalarRelationFilter, OrderItemWhereInput> | null
    productVariant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    taskItem?: XOR<TaskItemNullableScalarRelationFilter, TaskItemWhereInput> | null
  }, "id" | "taskItemId">

  export type AllocationOrderByWithAggregationInput = {
    id?: SortOrder
    inventoryUnitId?: SortOrder
    orderId?: SortOrder
    orderItemId?: SortOrderInput | SortOrder
    productVariantId?: SortOrder
    locationId?: SortOrder
    quantity?: SortOrder
    lotNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    allocatedAt?: SortOrder
    releasedAt?: SortOrderInput | SortOrder
    pickedAt?: SortOrderInput | SortOrder
    taskItemId?: SortOrderInput | SortOrder
    _count?: AllocationCountOrderByAggregateInput
    _avg?: AllocationAvgOrderByAggregateInput
    _max?: AllocationMaxOrderByAggregateInput
    _min?: AllocationMinOrderByAggregateInput
    _sum?: AllocationSumOrderByAggregateInput
  }

  export type AllocationScalarWhereWithAggregatesInput = {
    AND?: AllocationScalarWhereWithAggregatesInput | AllocationScalarWhereWithAggregatesInput[]
    OR?: AllocationScalarWhereWithAggregatesInput[]
    NOT?: AllocationScalarWhereWithAggregatesInput | AllocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Allocation"> | string
    inventoryUnitId?: StringWithAggregatesFilter<"Allocation"> | string
    orderId?: StringWithAggregatesFilter<"Allocation"> | string
    orderItemId?: StringNullableWithAggregatesFilter<"Allocation"> | string | null
    productVariantId?: StringWithAggregatesFilter<"Allocation"> | string
    locationId?: StringWithAggregatesFilter<"Allocation"> | string
    quantity?: IntWithAggregatesFilter<"Allocation"> | number
    lotNumber?: StringNullableWithAggregatesFilter<"Allocation"> | string | null
    status?: EnumAllocationStatusWithAggregatesFilter<"Allocation"> | $Enums.AllocationStatus
    allocatedAt?: DateTimeWithAggregatesFilter<"Allocation"> | Date | string
    releasedAt?: DateTimeNullableWithAggregatesFilter<"Allocation"> | Date | string | null
    pickedAt?: DateTimeNullableWithAggregatesFilter<"Allocation"> | Date | string | null
    taskItemId?: StringNullableWithAggregatesFilter<"Allocation"> | string | null
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    shopifyOrderId?: StringNullableFilter<"Order"> | string | null
    customerId?: StringNullableFilter<"Order"> | string | null
    customerName?: StringFilter<"Order"> | string
    customerEmail?: StringNullableFilter<"Order"> | string | null
    shippingAddress?: JsonFilter<"Order">
    billingAddress?: JsonNullableFilter<"Order">
    shopifyLineItems?: JsonNullableFilter<"Order">
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFilter<"Order"> | $Enums.PaymentStatus
    priority?: EnumPriorityFilter<"Order"> | $Enums.Priority
    holdReason?: StringNullableFilter<"Order"> | string | null
    holdAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    holdBy?: StringNullableFilter<"Order"> | string | null
    unmatchedItems?: IntFilter<"Order"> | number
    totalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    warehouseId?: StringNullableFilter<"Order"> | string | null
    trackingNumber?: StringNullableFilter<"Order"> | string | null
    shippedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    items?: OrderItemListRelationFilter
    taskItems?: TaskItemListRelationFilter
    allocations?: AllocationListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    shopifyOrderId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrderInput | SortOrder
    shippingAddress?: SortOrder
    billingAddress?: SortOrderInput | SortOrder
    shopifyLineItems?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    priority?: SortOrder
    holdReason?: SortOrderInput | SortOrder
    holdAt?: SortOrderInput | SortOrder
    holdBy?: SortOrderInput | SortOrder
    unmatchedItems?: SortOrder
    totalAmount?: SortOrder
    warehouseId?: SortOrderInput | SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    shippedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: OrderItemOrderByRelationAggregateInput
    taskItems?: TaskItemOrderByRelationAggregateInput
    allocations?: AllocationOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    shopifyOrderId?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    customerId?: StringNullableFilter<"Order"> | string | null
    customerName?: StringFilter<"Order"> | string
    customerEmail?: StringNullableFilter<"Order"> | string | null
    shippingAddress?: JsonFilter<"Order">
    billingAddress?: JsonNullableFilter<"Order">
    shopifyLineItems?: JsonNullableFilter<"Order">
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFilter<"Order"> | $Enums.PaymentStatus
    priority?: EnumPriorityFilter<"Order"> | $Enums.Priority
    holdReason?: StringNullableFilter<"Order"> | string | null
    holdAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    holdBy?: StringNullableFilter<"Order"> | string | null
    unmatchedItems?: IntFilter<"Order"> | number
    totalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    warehouseId?: StringNullableFilter<"Order"> | string | null
    trackingNumber?: StringNullableFilter<"Order"> | string | null
    shippedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    items?: OrderItemListRelationFilter
    taskItems?: TaskItemListRelationFilter
    allocations?: AllocationListRelationFilter
  }, "id" | "orderNumber" | "shopifyOrderId">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    shopifyOrderId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrderInput | SortOrder
    shippingAddress?: SortOrder
    billingAddress?: SortOrderInput | SortOrder
    shopifyLineItems?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    priority?: SortOrder
    holdReason?: SortOrderInput | SortOrder
    holdAt?: SortOrderInput | SortOrder
    holdBy?: SortOrderInput | SortOrder
    unmatchedItems?: SortOrder
    totalAmount?: SortOrder
    warehouseId?: SortOrderInput | SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    shippedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    orderNumber?: StringWithAggregatesFilter<"Order"> | string
    shopifyOrderId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    customerName?: StringWithAggregatesFilter<"Order"> | string
    customerEmail?: StringNullableWithAggregatesFilter<"Order"> | string | null
    shippingAddress?: JsonWithAggregatesFilter<"Order">
    billingAddress?: JsonNullableWithAggregatesFilter<"Order">
    shopifyLineItems?: JsonNullableWithAggregatesFilter<"Order">
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"Order"> | $Enums.PaymentStatus
    priority?: EnumPriorityWithAggregatesFilter<"Order"> | $Enums.Priority
    holdReason?: StringNullableWithAggregatesFilter<"Order"> | string | null
    holdAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    holdBy?: StringNullableWithAggregatesFilter<"Order"> | string | null
    unmatchedItems?: IntWithAggregatesFilter<"Order"> | number
    totalAmount?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    warehouseId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    trackingNumber?: StringNullableWithAggregatesFilter<"Order"> | string | null
    shippedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productVariantId?: StringNullableFilter<"OrderItem"> | string | null
    sku?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    quantityAllocated?: IntFilter<"OrderItem"> | number
    quantityPicked?: IntFilter<"OrderItem"> | number
    unitPrice?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalNullableFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    matched?: BoolFilter<"OrderItem"> | boolean
    matchError?: StringNullableFilter<"OrderItem"> | string | null
    shopifyLineItemId?: StringNullableFilter<"OrderItem"> | string | null
    shopifyFulfillmentOrderLineItemId?: StringNullableFilter<"OrderItem"> | string | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    productVariant?: XOR<ProductVariantNullableScalarRelationFilter, ProductVariantWhereInput> | null
    taskItems?: TaskItemListRelationFilter
    allocations?: AllocationListRelationFilter
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productVariantId?: SortOrderInput | SortOrder
    sku?: SortOrder
    quantity?: SortOrder
    quantityAllocated?: SortOrder
    quantityPicked?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrderInput | SortOrder
    matched?: SortOrder
    matchError?: SortOrderInput | SortOrder
    shopifyLineItemId?: SortOrderInput | SortOrder
    shopifyFulfillmentOrderLineItemId?: SortOrderInput | SortOrder
    order?: OrderOrderByWithRelationInput
    productVariant?: ProductVariantOrderByWithRelationInput
    taskItems?: TaskItemOrderByRelationAggregateInput
    allocations?: AllocationOrderByRelationAggregateInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: StringFilter<"OrderItem"> | string
    productVariantId?: StringNullableFilter<"OrderItem"> | string | null
    sku?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    quantityAllocated?: IntFilter<"OrderItem"> | number
    quantityPicked?: IntFilter<"OrderItem"> | number
    unitPrice?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalNullableFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    matched?: BoolFilter<"OrderItem"> | boolean
    matchError?: StringNullableFilter<"OrderItem"> | string | null
    shopifyLineItemId?: StringNullableFilter<"OrderItem"> | string | null
    shopifyFulfillmentOrderLineItemId?: StringNullableFilter<"OrderItem"> | string | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    productVariant?: XOR<ProductVariantNullableScalarRelationFilter, ProductVariantWhereInput> | null
    taskItems?: TaskItemListRelationFilter
    allocations?: AllocationListRelationFilter
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productVariantId?: SortOrderInput | SortOrder
    sku?: SortOrder
    quantity?: SortOrder
    quantityAllocated?: SortOrder
    quantityPicked?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrderInput | SortOrder
    matched?: SortOrder
    matchError?: SortOrderInput | SortOrder
    shopifyLineItemId?: SortOrderInput | SortOrder
    shopifyFulfillmentOrderLineItemId?: SortOrderInput | SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    productVariantId?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    sku?: StringWithAggregatesFilter<"OrderItem"> | string
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    quantityAllocated?: IntWithAggregatesFilter<"OrderItem"> | number
    quantityPicked?: IntWithAggregatesFilter<"OrderItem"> | number
    unitPrice?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalNullableWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    matched?: BoolWithAggregatesFilter<"OrderItem"> | boolean
    matchError?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    shopifyLineItemId?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    shopifyFulfillmentOrderLineItemId?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
  }

  export type WorkTaskWhereInput = {
    AND?: WorkTaskWhereInput | WorkTaskWhereInput[]
    OR?: WorkTaskWhereInput[]
    NOT?: WorkTaskWhereInput | WorkTaskWhereInput[]
    id?: StringFilter<"WorkTask"> | string
    taskNumber?: StringFilter<"WorkTask"> | string
    type?: EnumWorkTaskTypeFilter<"WorkTask"> | $Enums.WorkTaskType
    status?: EnumWorkTaskStatusFilter<"WorkTask"> | $Enums.WorkTaskStatus
    priority?: IntFilter<"WorkTask"> | number
    idempotencyKey?: StringNullableFilter<"WorkTask"> | string | null
    assignedTo?: StringNullableFilter<"WorkTask"> | string | null
    assignedAt?: DateTimeNullableFilter<"WorkTask"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"WorkTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"WorkTask"> | Date | string | null
    blockReason?: EnumWorkTaskBlockReasonNullableFilter<"WorkTask"> | $Enums.WorkTaskBlockReason | null
    blockedAt?: DateTimeNullableFilter<"WorkTask"> | Date | string | null
    orderIds?: StringNullableListFilter<"WorkTask">
    totalOrders?: IntFilter<"WorkTask"> | number
    completedOrders?: IntFilter<"WorkTask"> | number
    totalItems?: IntFilter<"WorkTask"> | number
    completedItems?: IntFilter<"WorkTask"> | number
    shortItems?: IntFilter<"WorkTask"> | number
    skippedItems?: IntFilter<"WorkTask"> | number
    notes?: StringNullableFilter<"WorkTask"> | string | null
    createdAt?: DateTimeFilter<"WorkTask"> | Date | string
    updatedAt?: DateTimeFilter<"WorkTask"> | Date | string
    assignedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    taskItems?: TaskItemListRelationFilter
    events?: TaskEventListRelationFilter
  }

  export type WorkTaskOrderByWithRelationInput = {
    id?: SortOrder
    taskNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    idempotencyKey?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    blockReason?: SortOrderInput | SortOrder
    blockedAt?: SortOrderInput | SortOrder
    orderIds?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    totalItems?: SortOrder
    completedItems?: SortOrder
    shortItems?: SortOrder
    skippedItems?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedUser?: UserOrderByWithRelationInput
    taskItems?: TaskItemOrderByRelationAggregateInput
    events?: TaskEventOrderByRelationAggregateInput
  }

  export type WorkTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    taskNumber?: string
    idempotencyKey?: string
    AND?: WorkTaskWhereInput | WorkTaskWhereInput[]
    OR?: WorkTaskWhereInput[]
    NOT?: WorkTaskWhereInput | WorkTaskWhereInput[]
    type?: EnumWorkTaskTypeFilter<"WorkTask"> | $Enums.WorkTaskType
    status?: EnumWorkTaskStatusFilter<"WorkTask"> | $Enums.WorkTaskStatus
    priority?: IntFilter<"WorkTask"> | number
    assignedTo?: StringNullableFilter<"WorkTask"> | string | null
    assignedAt?: DateTimeNullableFilter<"WorkTask"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"WorkTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"WorkTask"> | Date | string | null
    blockReason?: EnumWorkTaskBlockReasonNullableFilter<"WorkTask"> | $Enums.WorkTaskBlockReason | null
    blockedAt?: DateTimeNullableFilter<"WorkTask"> | Date | string | null
    orderIds?: StringNullableListFilter<"WorkTask">
    totalOrders?: IntFilter<"WorkTask"> | number
    completedOrders?: IntFilter<"WorkTask"> | number
    totalItems?: IntFilter<"WorkTask"> | number
    completedItems?: IntFilter<"WorkTask"> | number
    shortItems?: IntFilter<"WorkTask"> | number
    skippedItems?: IntFilter<"WorkTask"> | number
    notes?: StringNullableFilter<"WorkTask"> | string | null
    createdAt?: DateTimeFilter<"WorkTask"> | Date | string
    updatedAt?: DateTimeFilter<"WorkTask"> | Date | string
    assignedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    taskItems?: TaskItemListRelationFilter
    events?: TaskEventListRelationFilter
  }, "id" | "taskNumber" | "idempotencyKey">

  export type WorkTaskOrderByWithAggregationInput = {
    id?: SortOrder
    taskNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    idempotencyKey?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    blockReason?: SortOrderInput | SortOrder
    blockedAt?: SortOrderInput | SortOrder
    orderIds?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    totalItems?: SortOrder
    completedItems?: SortOrder
    shortItems?: SortOrder
    skippedItems?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkTaskCountOrderByAggregateInput
    _avg?: WorkTaskAvgOrderByAggregateInput
    _max?: WorkTaskMaxOrderByAggregateInput
    _min?: WorkTaskMinOrderByAggregateInput
    _sum?: WorkTaskSumOrderByAggregateInput
  }

  export type WorkTaskScalarWhereWithAggregatesInput = {
    AND?: WorkTaskScalarWhereWithAggregatesInput | WorkTaskScalarWhereWithAggregatesInput[]
    OR?: WorkTaskScalarWhereWithAggregatesInput[]
    NOT?: WorkTaskScalarWhereWithAggregatesInput | WorkTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkTask"> | string
    taskNumber?: StringWithAggregatesFilter<"WorkTask"> | string
    type?: EnumWorkTaskTypeWithAggregatesFilter<"WorkTask"> | $Enums.WorkTaskType
    status?: EnumWorkTaskStatusWithAggregatesFilter<"WorkTask"> | $Enums.WorkTaskStatus
    priority?: IntWithAggregatesFilter<"WorkTask"> | number
    idempotencyKey?: StringNullableWithAggregatesFilter<"WorkTask"> | string | null
    assignedTo?: StringNullableWithAggregatesFilter<"WorkTask"> | string | null
    assignedAt?: DateTimeNullableWithAggregatesFilter<"WorkTask"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"WorkTask"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"WorkTask"> | Date | string | null
    blockReason?: EnumWorkTaskBlockReasonNullableWithAggregatesFilter<"WorkTask"> | $Enums.WorkTaskBlockReason | null
    blockedAt?: DateTimeNullableWithAggregatesFilter<"WorkTask"> | Date | string | null
    orderIds?: StringNullableListFilter<"WorkTask">
    totalOrders?: IntWithAggregatesFilter<"WorkTask"> | number
    completedOrders?: IntWithAggregatesFilter<"WorkTask"> | number
    totalItems?: IntWithAggregatesFilter<"WorkTask"> | number
    completedItems?: IntWithAggregatesFilter<"WorkTask"> | number
    shortItems?: IntWithAggregatesFilter<"WorkTask"> | number
    skippedItems?: IntWithAggregatesFilter<"WorkTask"> | number
    notes?: StringNullableWithAggregatesFilter<"WorkTask"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WorkTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkTask"> | Date | string
  }

  export type TaskItemWhereInput = {
    AND?: TaskItemWhereInput | TaskItemWhereInput[]
    OR?: TaskItemWhereInput[]
    NOT?: TaskItemWhereInput | TaskItemWhereInput[]
    id?: StringFilter<"TaskItem"> | string
    taskId?: StringFilter<"TaskItem"> | string
    orderId?: StringFilter<"TaskItem"> | string
    orderItemId?: StringNullableFilter<"TaskItem"> | string | null
    productVariantId?: StringNullableFilter<"TaskItem"> | string | null
    locationId?: StringNullableFilter<"TaskItem"> | string | null
    allocationId?: StringNullableFilter<"TaskItem"> | string | null
    sequence?: IntFilter<"TaskItem"> | number
    quantityRequired?: IntFilter<"TaskItem"> | number
    quantityCompleted?: IntFilter<"TaskItem"> | number
    status?: EnumWorkTaskItemStatusFilter<"TaskItem"> | $Enums.WorkTaskItemStatus
    completedBy?: StringNullableFilter<"TaskItem"> | string | null
    completedAt?: DateTimeNullableFilter<"TaskItem"> | Date | string | null
    shortReason?: StringNullableFilter<"TaskItem"> | string | null
    locationScanned?: BoolFilter<"TaskItem"> | boolean
    itemScanned?: BoolFilter<"TaskItem"> | boolean
    createdAt?: DateTimeFilter<"TaskItem"> | Date | string
    updatedAt?: DateTimeFilter<"TaskItem"> | Date | string
    task?: XOR<WorkTaskScalarRelationFilter, WorkTaskWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    orderItem?: XOR<OrderItemNullableScalarRelationFilter, OrderItemWhereInput> | null
    productVariant?: XOR<ProductVariantNullableScalarRelationFilter, ProductVariantWhereInput> | null
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    completedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    allocation?: XOR<AllocationNullableScalarRelationFilter, AllocationWhereInput> | null
  }

  export type TaskItemOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    orderId?: SortOrder
    orderItemId?: SortOrderInput | SortOrder
    productVariantId?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    allocationId?: SortOrderInput | SortOrder
    sequence?: SortOrder
    quantityRequired?: SortOrder
    quantityCompleted?: SortOrder
    status?: SortOrder
    completedBy?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    shortReason?: SortOrderInput | SortOrder
    locationScanned?: SortOrder
    itemScanned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    task?: WorkTaskOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    orderItem?: OrderItemOrderByWithRelationInput
    productVariant?: ProductVariantOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    completedByUser?: UserOrderByWithRelationInput
    allocation?: AllocationOrderByWithRelationInput
  }

  export type TaskItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    allocationId?: string
    AND?: TaskItemWhereInput | TaskItemWhereInput[]
    OR?: TaskItemWhereInput[]
    NOT?: TaskItemWhereInput | TaskItemWhereInput[]
    taskId?: StringFilter<"TaskItem"> | string
    orderId?: StringFilter<"TaskItem"> | string
    orderItemId?: StringNullableFilter<"TaskItem"> | string | null
    productVariantId?: StringNullableFilter<"TaskItem"> | string | null
    locationId?: StringNullableFilter<"TaskItem"> | string | null
    sequence?: IntFilter<"TaskItem"> | number
    quantityRequired?: IntFilter<"TaskItem"> | number
    quantityCompleted?: IntFilter<"TaskItem"> | number
    status?: EnumWorkTaskItemStatusFilter<"TaskItem"> | $Enums.WorkTaskItemStatus
    completedBy?: StringNullableFilter<"TaskItem"> | string | null
    completedAt?: DateTimeNullableFilter<"TaskItem"> | Date | string | null
    shortReason?: StringNullableFilter<"TaskItem"> | string | null
    locationScanned?: BoolFilter<"TaskItem"> | boolean
    itemScanned?: BoolFilter<"TaskItem"> | boolean
    createdAt?: DateTimeFilter<"TaskItem"> | Date | string
    updatedAt?: DateTimeFilter<"TaskItem"> | Date | string
    task?: XOR<WorkTaskScalarRelationFilter, WorkTaskWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    orderItem?: XOR<OrderItemNullableScalarRelationFilter, OrderItemWhereInput> | null
    productVariant?: XOR<ProductVariantNullableScalarRelationFilter, ProductVariantWhereInput> | null
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    completedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    allocation?: XOR<AllocationNullableScalarRelationFilter, AllocationWhereInput> | null
  }, "id" | "allocationId">

  export type TaskItemOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    orderId?: SortOrder
    orderItemId?: SortOrderInput | SortOrder
    productVariantId?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    allocationId?: SortOrderInput | SortOrder
    sequence?: SortOrder
    quantityRequired?: SortOrder
    quantityCompleted?: SortOrder
    status?: SortOrder
    completedBy?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    shortReason?: SortOrderInput | SortOrder
    locationScanned?: SortOrder
    itemScanned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskItemCountOrderByAggregateInput
    _avg?: TaskItemAvgOrderByAggregateInput
    _max?: TaskItemMaxOrderByAggregateInput
    _min?: TaskItemMinOrderByAggregateInput
    _sum?: TaskItemSumOrderByAggregateInput
  }

  export type TaskItemScalarWhereWithAggregatesInput = {
    AND?: TaskItemScalarWhereWithAggregatesInput | TaskItemScalarWhereWithAggregatesInput[]
    OR?: TaskItemScalarWhereWithAggregatesInput[]
    NOT?: TaskItemScalarWhereWithAggregatesInput | TaskItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskItem"> | string
    taskId?: StringWithAggregatesFilter<"TaskItem"> | string
    orderId?: StringWithAggregatesFilter<"TaskItem"> | string
    orderItemId?: StringNullableWithAggregatesFilter<"TaskItem"> | string | null
    productVariantId?: StringNullableWithAggregatesFilter<"TaskItem"> | string | null
    locationId?: StringNullableWithAggregatesFilter<"TaskItem"> | string | null
    allocationId?: StringNullableWithAggregatesFilter<"TaskItem"> | string | null
    sequence?: IntWithAggregatesFilter<"TaskItem"> | number
    quantityRequired?: IntWithAggregatesFilter<"TaskItem"> | number
    quantityCompleted?: IntWithAggregatesFilter<"TaskItem"> | number
    status?: EnumWorkTaskItemStatusWithAggregatesFilter<"TaskItem"> | $Enums.WorkTaskItemStatus
    completedBy?: StringNullableWithAggregatesFilter<"TaskItem"> | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"TaskItem"> | Date | string | null
    shortReason?: StringNullableWithAggregatesFilter<"TaskItem"> | string | null
    locationScanned?: BoolWithAggregatesFilter<"TaskItem"> | boolean
    itemScanned?: BoolWithAggregatesFilter<"TaskItem"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TaskItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaskItem"> | Date | string
  }

  export type TaskEventWhereInput = {
    AND?: TaskEventWhereInput | TaskEventWhereInput[]
    OR?: TaskEventWhereInput[]
    NOT?: TaskEventWhereInput | TaskEventWhereInput[]
    id?: StringFilter<"TaskEvent"> | string
    taskId?: StringFilter<"TaskEvent"> | string
    eventType?: EnumWorkTaskEventTypeFilter<"TaskEvent"> | $Enums.WorkTaskEventType
    userId?: StringNullableFilter<"TaskEvent"> | string | null
    taskItemId?: StringNullableFilter<"TaskEvent"> | string | null
    data?: JsonNullableFilter<"TaskEvent">
    createdAt?: DateTimeFilter<"TaskEvent"> | Date | string
    task?: XOR<WorkTaskScalarRelationFilter, WorkTaskWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TaskEventOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    eventType?: SortOrder
    userId?: SortOrderInput | SortOrder
    taskItemId?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    task?: WorkTaskOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TaskEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskEventWhereInput | TaskEventWhereInput[]
    OR?: TaskEventWhereInput[]
    NOT?: TaskEventWhereInput | TaskEventWhereInput[]
    taskId?: StringFilter<"TaskEvent"> | string
    eventType?: EnumWorkTaskEventTypeFilter<"TaskEvent"> | $Enums.WorkTaskEventType
    userId?: StringNullableFilter<"TaskEvent"> | string | null
    taskItemId?: StringNullableFilter<"TaskEvent"> | string | null
    data?: JsonNullableFilter<"TaskEvent">
    createdAt?: DateTimeFilter<"TaskEvent"> | Date | string
    task?: XOR<WorkTaskScalarRelationFilter, WorkTaskWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type TaskEventOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    eventType?: SortOrder
    userId?: SortOrderInput | SortOrder
    taskItemId?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TaskEventCountOrderByAggregateInput
    _max?: TaskEventMaxOrderByAggregateInput
    _min?: TaskEventMinOrderByAggregateInput
  }

  export type TaskEventScalarWhereWithAggregatesInput = {
    AND?: TaskEventScalarWhereWithAggregatesInput | TaskEventScalarWhereWithAggregatesInput[]
    OR?: TaskEventScalarWhereWithAggregatesInput[]
    NOT?: TaskEventScalarWhereWithAggregatesInput | TaskEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskEvent"> | string
    taskId?: StringWithAggregatesFilter<"TaskEvent"> | string
    eventType?: EnumWorkTaskEventTypeWithAggregatesFilter<"TaskEvent"> | $Enums.WorkTaskEventType
    userId?: StringNullableWithAggregatesFilter<"TaskEvent"> | string | null
    taskItemId?: StringNullableWithAggregatesFilter<"TaskEvent"> | string | null
    data?: JsonNullableWithAggregatesFilter<"TaskEvent">
    createdAt?: DateTimeWithAggregatesFilter<"TaskEvent"> | Date | string
  }

  export type JobRecordWhereInput = {
    AND?: JobRecordWhereInput | JobRecordWhereInput[]
    OR?: JobRecordWhereInput[]
    NOT?: JobRecordWhereInput | JobRecordWhereInput[]
    id?: StringFilter<"JobRecord"> | string
    jobId?: StringFilter<"JobRecord"> | string
    queue?: StringFilter<"JobRecord"> | string
    name?: StringFilter<"JobRecord"> | string
    data?: JsonFilter<"JobRecord">
    status?: StringFilter<"JobRecord"> | string
    result?: JsonNullableFilter<"JobRecord">
    error?: StringNullableFilter<"JobRecord"> | string | null
    attempts?: IntFilter<"JobRecord"> | number
    startedAt?: DateTimeNullableFilter<"JobRecord"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"JobRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"JobRecord"> | Date | string
  }

  export type JobRecordOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    queue?: SortOrder
    name?: SortOrder
    data?: SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    attempts?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type JobRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobId?: string
    AND?: JobRecordWhereInput | JobRecordWhereInput[]
    OR?: JobRecordWhereInput[]
    NOT?: JobRecordWhereInput | JobRecordWhereInput[]
    queue?: StringFilter<"JobRecord"> | string
    name?: StringFilter<"JobRecord"> | string
    data?: JsonFilter<"JobRecord">
    status?: StringFilter<"JobRecord"> | string
    result?: JsonNullableFilter<"JobRecord">
    error?: StringNullableFilter<"JobRecord"> | string | null
    attempts?: IntFilter<"JobRecord"> | number
    startedAt?: DateTimeNullableFilter<"JobRecord"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"JobRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"JobRecord"> | Date | string
  }, "id" | "jobId">

  export type JobRecordOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    queue?: SortOrder
    name?: SortOrder
    data?: SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    attempts?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: JobRecordCountOrderByAggregateInput
    _avg?: JobRecordAvgOrderByAggregateInput
    _max?: JobRecordMaxOrderByAggregateInput
    _min?: JobRecordMinOrderByAggregateInput
    _sum?: JobRecordSumOrderByAggregateInput
  }

  export type JobRecordScalarWhereWithAggregatesInput = {
    AND?: JobRecordScalarWhereWithAggregatesInput | JobRecordScalarWhereWithAggregatesInput[]
    OR?: JobRecordScalarWhereWithAggregatesInput[]
    NOT?: JobRecordScalarWhereWithAggregatesInput | JobRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobRecord"> | string
    jobId?: StringWithAggregatesFilter<"JobRecord"> | string
    queue?: StringWithAggregatesFilter<"JobRecord"> | string
    name?: StringWithAggregatesFilter<"JobRecord"> | string
    data?: JsonWithAggregatesFilter<"JobRecord">
    status?: StringWithAggregatesFilter<"JobRecord"> | string
    result?: JsonNullableWithAggregatesFilter<"JobRecord">
    error?: StringNullableWithAggregatesFilter<"JobRecord"> | string | null
    attempts?: IntWithAggregatesFilter<"JobRecord"> | number
    startedAt?: DateTimeNullableWithAggregatesFilter<"JobRecord"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"JobRecord"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"JobRecord"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    correlationId?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrderInput | SortOrder
    correlationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    correlationId?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrderInput | SortOrder
    correlationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    changes?: JsonNullableWithAggregatesFilter<"AuditLog">
    correlationId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    role?: $Enums.UserRole
    active?: boolean
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    assignedTasks?: WorkTaskCreateNestedManyWithoutAssignedUserInput
    taskEvents?: TaskEventCreateNestedManyWithoutUserInput
    completedTaskItems?: TaskItemCreateNestedManyWithoutCompletedByUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    role?: $Enums.UserRole
    active?: boolean
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: WorkTaskUncheckedCreateNestedManyWithoutAssignedUserInput
    taskEvents?: TaskEventUncheckedCreateNestedManyWithoutUserInput
    completedTaskItems?: TaskItemUncheckedCreateNestedManyWithoutCompletedByUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    assignedTasks?: WorkTaskUpdateManyWithoutAssignedUserNestedInput
    taskEvents?: TaskEventUpdateManyWithoutUserNestedInput
    completedTaskItems?: TaskItemUpdateManyWithoutCompletedByUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: WorkTaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    taskEvents?: TaskEventUncheckedUpdateManyWithoutUserNestedInput
    completedTaskItems?: TaskItemUncheckedUpdateManyWithoutCompletedByUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    role?: $Enums.UserRole
    active?: boolean
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordResetTokensInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    brand?: string | null
    category?: string | null
    shopifyProductId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: ProductVariantCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    brand?: string | null
    category?: string | null
    shopifyProductId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyProductId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyProductId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    brand?: string | null
    category?: string | null
    shopifyProductId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyProductId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyProductId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantCreateInput = {
    id?: string
    sku: string
    upc?: string | null
    barcode?: string | null
    name: string
    imageUrl?: string | null
    shopifyVariantId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    sellingPrice?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    trackLots?: boolean
    trackExpiry?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductVariantInput
    inventoryUnits?: InventoryUnitCreateNestedManyWithoutProductVariantInput
    taskItems?: TaskItemCreateNestedManyWithoutProductVariantInput
    allocations?: AllocationCreateNestedManyWithoutProductVariantInput
  }

  export type ProductVariantUncheckedCreateInput = {
    id?: string
    productId: string
    sku: string
    upc?: string | null
    barcode?: string | null
    name: string
    imageUrl?: string | null
    shopifyVariantId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    sellingPrice?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    trackLots?: boolean
    trackExpiry?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductVariantInput
    inventoryUnits?: InventoryUnitUncheckedCreateNestedManyWithoutProductVariantInput
    taskItems?: TaskItemUncheckedCreateNestedManyWithoutProductVariantInput
    allocations?: AllocationUncheckedCreateNestedManyWithoutProductVariantInput
  }

  export type ProductVariantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trackLots?: BoolFieldUpdateOperationsInput | boolean
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductVariantNestedInput
    inventoryUnits?: InventoryUnitUpdateManyWithoutProductVariantNestedInput
    taskItems?: TaskItemUpdateManyWithoutProductVariantNestedInput
    allocations?: AllocationUpdateManyWithoutProductVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trackLots?: BoolFieldUpdateOperationsInput | boolean
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductVariantNestedInput
    inventoryUnits?: InventoryUnitUncheckedUpdateManyWithoutProductVariantNestedInput
    taskItems?: TaskItemUncheckedUpdateManyWithoutProductVariantNestedInput
    allocations?: AllocationUncheckedUpdateManyWithoutProductVariantNestedInput
  }

  export type ProductVariantCreateManyInput = {
    id?: string
    productId: string
    sku: string
    upc?: string | null
    barcode?: string | null
    name: string
    imageUrl?: string | null
    shopifyVariantId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    sellingPrice?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    trackLots?: boolean
    trackExpiry?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trackLots?: BoolFieldUpdateOperationsInput | boolean
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trackLots?: BoolFieldUpdateOperationsInput | boolean
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    id?: string
    name: string
    barcode?: string | null
    type?: $Enums.LocationType
    zone?: string | null
    aisle?: string | null
    rack?: string | null
    shelf?: string | null
    bin?: string | null
    pickSequence?: number | null
    isPickable?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryUnits?: InventoryUnitCreateNestedManyWithoutLocationInput
    taskItems?: TaskItemCreateNestedManyWithoutLocationInput
    allocations?: AllocationCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    name: string
    barcode?: string | null
    type?: $Enums.LocationType
    zone?: string | null
    aisle?: string | null
    rack?: string | null
    shelf?: string | null
    bin?: string | null
    pickSequence?: number | null
    isPickable?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryUnits?: InventoryUnitUncheckedCreateNestedManyWithoutLocationInput
    taskItems?: TaskItemUncheckedCreateNestedManyWithoutLocationInput
    allocations?: AllocationUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    zone?: NullableStringFieldUpdateOperationsInput | string | null
    aisle?: NullableStringFieldUpdateOperationsInput | string | null
    rack?: NullableStringFieldUpdateOperationsInput | string | null
    shelf?: NullableStringFieldUpdateOperationsInput | string | null
    bin?: NullableStringFieldUpdateOperationsInput | string | null
    pickSequence?: NullableIntFieldUpdateOperationsInput | number | null
    isPickable?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryUnits?: InventoryUnitUpdateManyWithoutLocationNestedInput
    taskItems?: TaskItemUpdateManyWithoutLocationNestedInput
    allocations?: AllocationUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    zone?: NullableStringFieldUpdateOperationsInput | string | null
    aisle?: NullableStringFieldUpdateOperationsInput | string | null
    rack?: NullableStringFieldUpdateOperationsInput | string | null
    shelf?: NullableStringFieldUpdateOperationsInput | string | null
    bin?: NullableStringFieldUpdateOperationsInput | string | null
    pickSequence?: NullableIntFieldUpdateOperationsInput | number | null
    isPickable?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryUnits?: InventoryUnitUncheckedUpdateManyWithoutLocationNestedInput
    taskItems?: TaskItemUncheckedUpdateManyWithoutLocationNestedInput
    allocations?: AllocationUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    name: string
    barcode?: string | null
    type?: $Enums.LocationType
    zone?: string | null
    aisle?: string | null
    rack?: string | null
    shelf?: string | null
    bin?: string | null
    pickSequence?: number | null
    isPickable?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    zone?: NullableStringFieldUpdateOperationsInput | string | null
    aisle?: NullableStringFieldUpdateOperationsInput | string | null
    rack?: NullableStringFieldUpdateOperationsInput | string | null
    shelf?: NullableStringFieldUpdateOperationsInput | string | null
    bin?: NullableStringFieldUpdateOperationsInput | string | null
    pickSequence?: NullableIntFieldUpdateOperationsInput | number | null
    isPickable?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    zone?: NullableStringFieldUpdateOperationsInput | string | null
    aisle?: NullableStringFieldUpdateOperationsInput | string | null
    rack?: NullableStringFieldUpdateOperationsInput | string | null
    shelf?: NullableStringFieldUpdateOperationsInput | string | null
    bin?: NullableStringFieldUpdateOperationsInput | string | null
    pickSequence?: NullableIntFieldUpdateOperationsInput | number | null
    isPickable?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUnitCreateInput = {
    id?: string
    quantity?: number
    status?: $Enums.InventoryStatus
    lotNumber?: string | null
    expiryDate?: Date | string | null
    receivedAt?: Date | string
    receivedFrom?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productVariant: ProductVariantCreateNestedOneWithoutInventoryUnitsInput
    location: LocationCreateNestedOneWithoutInventoryUnitsInput
    allocations?: AllocationCreateNestedManyWithoutInventoryUnitInput
  }

  export type InventoryUnitUncheckedCreateInput = {
    id?: string
    productVariantId: string
    locationId: string
    quantity?: number
    status?: $Enums.InventoryStatus
    lotNumber?: string | null
    expiryDate?: Date | string | null
    receivedAt?: Date | string
    receivedFrom?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    allocations?: AllocationUncheckedCreateNestedManyWithoutInventoryUnitInput
  }

  export type InventoryUnitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productVariant?: ProductVariantUpdateOneRequiredWithoutInventoryUnitsNestedInput
    location?: LocationUpdateOneRequiredWithoutInventoryUnitsNestedInput
    allocations?: AllocationUpdateManyWithoutInventoryUnitNestedInput
  }

  export type InventoryUnitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productVariantId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: AllocationUncheckedUpdateManyWithoutInventoryUnitNestedInput
  }

  export type InventoryUnitCreateManyInput = {
    id?: string
    productVariantId: string
    locationId: string
    quantity?: number
    status?: $Enums.InventoryStatus
    lotNumber?: string | null
    expiryDate?: Date | string | null
    receivedAt?: Date | string
    receivedFrom?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUnitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUnitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productVariantId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllocationCreateInput = {
    id?: string
    quantity: number
    lotNumber?: string | null
    status?: $Enums.AllocationStatus
    allocatedAt?: Date | string
    releasedAt?: Date | string | null
    pickedAt?: Date | string | null
    inventoryUnit: InventoryUnitCreateNestedOneWithoutAllocationsInput
    order: OrderCreateNestedOneWithoutAllocationsInput
    orderItem?: OrderItemCreateNestedOneWithoutAllocationsInput
    productVariant: ProductVariantCreateNestedOneWithoutAllocationsInput
    location: LocationCreateNestedOneWithoutAllocationsInput
    taskItem?: TaskItemCreateNestedOneWithoutAllocationInput
  }

  export type AllocationUncheckedCreateInput = {
    id?: string
    inventoryUnitId: string
    orderId: string
    orderItemId?: string | null
    productVariantId: string
    locationId: string
    quantity: number
    lotNumber?: string | null
    status?: $Enums.AllocationStatus
    allocatedAt?: Date | string
    releasedAt?: Date | string | null
    pickedAt?: Date | string | null
    taskItemId?: string | null
  }

  export type AllocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAllocationStatusFieldUpdateOperationsInput | $Enums.AllocationStatus
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryUnit?: InventoryUnitUpdateOneRequiredWithoutAllocationsNestedInput
    order?: OrderUpdateOneRequiredWithoutAllocationsNestedInput
    orderItem?: OrderItemUpdateOneWithoutAllocationsNestedInput
    productVariant?: ProductVariantUpdateOneRequiredWithoutAllocationsNestedInput
    location?: LocationUpdateOneRequiredWithoutAllocationsNestedInput
    taskItem?: TaskItemUpdateOneWithoutAllocationNestedInput
  }

  export type AllocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryUnitId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAllocationStatusFieldUpdateOperationsInput | $Enums.AllocationStatus
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AllocationCreateManyInput = {
    id?: string
    inventoryUnitId: string
    orderId: string
    orderItemId?: string | null
    productVariantId: string
    locationId: string
    quantity: number
    lotNumber?: string | null
    status?: $Enums.AllocationStatus
    allocatedAt?: Date | string
    releasedAt?: Date | string | null
    pickedAt?: Date | string | null
    taskItemId?: string | null
  }

  export type AllocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAllocationStatusFieldUpdateOperationsInput | $Enums.AllocationStatus
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AllocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryUnitId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAllocationStatusFieldUpdateOperationsInput | $Enums.AllocationStatus
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateInput = {
    id?: string
    orderNumber: string
    shopifyOrderId?: string | null
    customerId?: string | null
    customerName: string
    customerEmail?: string | null
    shippingAddress: JsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shopifyLineItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    priority?: $Enums.Priority
    holdReason?: string | null
    holdAt?: Date | string | null
    holdBy?: string | null
    unmatchedItems?: number
    totalAmount: Decimal | DecimalJsLike | number | string
    warehouseId?: string | null
    trackingNumber?: string | null
    shippedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemCreateNestedManyWithoutOrderInput
    taskItems?: TaskItemCreateNestedManyWithoutOrderInput
    allocations?: AllocationCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    orderNumber: string
    shopifyOrderId?: string | null
    customerId?: string | null
    customerName: string
    customerEmail?: string | null
    shippingAddress: JsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shopifyLineItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    priority?: $Enums.Priority
    holdReason?: string | null
    holdAt?: Date | string | null
    holdBy?: string | null
    unmatchedItems?: number
    totalAmount: Decimal | DecimalJsLike | number | string
    warehouseId?: string | null
    trackingNumber?: string | null
    shippedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    taskItems?: TaskItemUncheckedCreateNestedManyWithoutOrderInput
    allocations?: AllocationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    shopifyOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: JsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shopifyLineItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    holdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    holdBy?: NullableStringFieldUpdateOperationsInput | string | null
    unmatchedItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    taskItems?: TaskItemUpdateManyWithoutOrderNestedInput
    allocations?: AllocationUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    shopifyOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: JsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shopifyLineItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    holdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    holdBy?: NullableStringFieldUpdateOperationsInput | string | null
    unmatchedItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    taskItems?: TaskItemUncheckedUpdateManyWithoutOrderNestedInput
    allocations?: AllocationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    orderNumber: string
    shopifyOrderId?: string | null
    customerId?: string | null
    customerName: string
    customerEmail?: string | null
    shippingAddress: JsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shopifyLineItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    priority?: $Enums.Priority
    holdReason?: string | null
    holdAt?: Date | string | null
    holdBy?: string | null
    unmatchedItems?: number
    totalAmount: Decimal | DecimalJsLike | number | string
    warehouseId?: string | null
    trackingNumber?: string | null
    shippedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    shopifyOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: JsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shopifyLineItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    holdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    holdBy?: NullableStringFieldUpdateOperationsInput | string | null
    unmatchedItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    shopifyOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: JsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shopifyLineItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    holdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    holdBy?: NullableStringFieldUpdateOperationsInput | string | null
    unmatchedItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    id?: string
    sku: string
    quantity: number
    quantityAllocated?: number
    quantityPicked?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    matched?: boolean
    matchError?: string | null
    shopifyLineItemId?: string | null
    shopifyFulfillmentOrderLineItemId?: string | null
    order: OrderCreateNestedOneWithoutItemsInput
    productVariant?: ProductVariantCreateNestedOneWithoutOrderItemsInput
    taskItems?: TaskItemCreateNestedManyWithoutOrderItemInput
    allocations?: AllocationCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    productVariantId?: string | null
    sku: string
    quantity: number
    quantityAllocated?: number
    quantityPicked?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    matched?: boolean
    matchError?: string | null
    shopifyLineItemId?: string | null
    shopifyFulfillmentOrderLineItemId?: string | null
    taskItems?: TaskItemUncheckedCreateNestedManyWithoutOrderItemInput
    allocations?: AllocationUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quantityAllocated?: IntFieldUpdateOperationsInput | number
    quantityPicked?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchError?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyFulfillmentOrderLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    productVariant?: ProductVariantUpdateOneWithoutOrderItemsNestedInput
    taskItems?: TaskItemUpdateManyWithoutOrderItemNestedInput
    allocations?: AllocationUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quantityAllocated?: IntFieldUpdateOperationsInput | number
    quantityPicked?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchError?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyFulfillmentOrderLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    taskItems?: TaskItemUncheckedUpdateManyWithoutOrderItemNestedInput
    allocations?: AllocationUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderId: string
    productVariantId?: string | null
    sku: string
    quantity: number
    quantityAllocated?: number
    quantityPicked?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    matched?: boolean
    matchError?: string | null
    shopifyLineItemId?: string | null
    shopifyFulfillmentOrderLineItemId?: string | null
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quantityAllocated?: IntFieldUpdateOperationsInput | number
    quantityPicked?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchError?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyFulfillmentOrderLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quantityAllocated?: IntFieldUpdateOperationsInput | number
    quantityPicked?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchError?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyFulfillmentOrderLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkTaskCreateInput = {
    id?: string
    taskNumber: string
    type: $Enums.WorkTaskType
    status?: $Enums.WorkTaskStatus
    priority?: number
    idempotencyKey?: string | null
    assignedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    blockReason?: $Enums.WorkTaskBlockReason | null
    blockedAt?: Date | string | null
    orderIds?: WorkTaskCreateorderIdsInput | string[]
    totalOrders: number
    completedOrders?: number
    totalItems: number
    completedItems?: number
    shortItems?: number
    skippedItems?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedUser?: UserCreateNestedOneWithoutAssignedTasksInput
    taskItems?: TaskItemCreateNestedManyWithoutTaskInput
    events?: TaskEventCreateNestedManyWithoutTaskInput
  }

  export type WorkTaskUncheckedCreateInput = {
    id?: string
    taskNumber: string
    type: $Enums.WorkTaskType
    status?: $Enums.WorkTaskStatus
    priority?: number
    idempotencyKey?: string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    blockReason?: $Enums.WorkTaskBlockReason | null
    blockedAt?: Date | string | null
    orderIds?: WorkTaskCreateorderIdsInput | string[]
    totalOrders: number
    completedOrders?: number
    totalItems: number
    completedItems?: number
    shortItems?: number
    skippedItems?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    taskItems?: TaskItemUncheckedCreateNestedManyWithoutTaskInput
    events?: TaskEventUncheckedCreateNestedManyWithoutTaskInput
  }

  export type WorkTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkTaskTypeFieldUpdateOperationsInput | $Enums.WorkTaskType
    status?: EnumWorkTaskStatusFieldUpdateOperationsInput | $Enums.WorkTaskStatus
    priority?: IntFieldUpdateOperationsInput | number
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockReason?: NullableEnumWorkTaskBlockReasonFieldUpdateOperationsInput | $Enums.WorkTaskBlockReason | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderIds?: WorkTaskUpdateorderIdsInput | string[]
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    totalItems?: IntFieldUpdateOperationsInput | number
    completedItems?: IntFieldUpdateOperationsInput | number
    shortItems?: IntFieldUpdateOperationsInput | number
    skippedItems?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedUser?: UserUpdateOneWithoutAssignedTasksNestedInput
    taskItems?: TaskItemUpdateManyWithoutTaskNestedInput
    events?: TaskEventUpdateManyWithoutTaskNestedInput
  }

  export type WorkTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkTaskTypeFieldUpdateOperationsInput | $Enums.WorkTaskType
    status?: EnumWorkTaskStatusFieldUpdateOperationsInput | $Enums.WorkTaskStatus
    priority?: IntFieldUpdateOperationsInput | number
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockReason?: NullableEnumWorkTaskBlockReasonFieldUpdateOperationsInput | $Enums.WorkTaskBlockReason | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderIds?: WorkTaskUpdateorderIdsInput | string[]
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    totalItems?: IntFieldUpdateOperationsInput | number
    completedItems?: IntFieldUpdateOperationsInput | number
    shortItems?: IntFieldUpdateOperationsInput | number
    skippedItems?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskItems?: TaskItemUncheckedUpdateManyWithoutTaskNestedInput
    events?: TaskEventUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type WorkTaskCreateManyInput = {
    id?: string
    taskNumber: string
    type: $Enums.WorkTaskType
    status?: $Enums.WorkTaskStatus
    priority?: number
    idempotencyKey?: string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    blockReason?: $Enums.WorkTaskBlockReason | null
    blockedAt?: Date | string | null
    orderIds?: WorkTaskCreateorderIdsInput | string[]
    totalOrders: number
    completedOrders?: number
    totalItems: number
    completedItems?: number
    shortItems?: number
    skippedItems?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkTaskTypeFieldUpdateOperationsInput | $Enums.WorkTaskType
    status?: EnumWorkTaskStatusFieldUpdateOperationsInput | $Enums.WorkTaskStatus
    priority?: IntFieldUpdateOperationsInput | number
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockReason?: NullableEnumWorkTaskBlockReasonFieldUpdateOperationsInput | $Enums.WorkTaskBlockReason | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderIds?: WorkTaskUpdateorderIdsInput | string[]
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    totalItems?: IntFieldUpdateOperationsInput | number
    completedItems?: IntFieldUpdateOperationsInput | number
    shortItems?: IntFieldUpdateOperationsInput | number
    skippedItems?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkTaskTypeFieldUpdateOperationsInput | $Enums.WorkTaskType
    status?: EnumWorkTaskStatusFieldUpdateOperationsInput | $Enums.WorkTaskStatus
    priority?: IntFieldUpdateOperationsInput | number
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockReason?: NullableEnumWorkTaskBlockReasonFieldUpdateOperationsInput | $Enums.WorkTaskBlockReason | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderIds?: WorkTaskUpdateorderIdsInput | string[]
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    totalItems?: IntFieldUpdateOperationsInput | number
    completedItems?: IntFieldUpdateOperationsInput | number
    shortItems?: IntFieldUpdateOperationsInput | number
    skippedItems?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskItemCreateInput = {
    id?: string
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    task: WorkTaskCreateNestedOneWithoutTaskItemsInput
    order: OrderCreateNestedOneWithoutTaskItemsInput
    orderItem?: OrderItemCreateNestedOneWithoutTaskItemsInput
    productVariant?: ProductVariantCreateNestedOneWithoutTaskItemsInput
    location?: LocationCreateNestedOneWithoutTaskItemsInput
    completedByUser?: UserCreateNestedOneWithoutCompletedTaskItemsInput
    allocation?: AllocationCreateNestedOneWithoutTaskItemInput
  }

  export type TaskItemUncheckedCreateInput = {
    id?: string
    taskId: string
    orderId: string
    orderItemId?: string | null
    productVariantId?: string | null
    locationId?: string | null
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedBy?: string | null
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    allocation?: AllocationUncheckedCreateNestedOneWithoutTaskItemInput
  }

  export type TaskItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: WorkTaskUpdateOneRequiredWithoutTaskItemsNestedInput
    order?: OrderUpdateOneRequiredWithoutTaskItemsNestedInput
    orderItem?: OrderItemUpdateOneWithoutTaskItemsNestedInput
    productVariant?: ProductVariantUpdateOneWithoutTaskItemsNestedInput
    location?: LocationUpdateOneWithoutTaskItemsNestedInput
    completedByUser?: UserUpdateOneWithoutCompletedTaskItemsNestedInput
    allocation?: AllocationUpdateOneWithoutTaskItemNestedInput
  }

  export type TaskItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocation?: AllocationUncheckedUpdateOneWithoutTaskItemNestedInput
  }

  export type TaskItemCreateManyInput = {
    id?: string
    taskId: string
    orderId: string
    orderItemId?: string | null
    productVariantId?: string | null
    locationId?: string | null
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedBy?: string | null
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskEventCreateInput = {
    id?: string
    eventType: $Enums.WorkTaskEventType
    taskItemId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    task: WorkTaskCreateNestedOneWithoutEventsInput
    user?: UserCreateNestedOneWithoutTaskEventsInput
  }

  export type TaskEventUncheckedCreateInput = {
    id?: string
    taskId: string
    eventType: $Enums.WorkTaskEventType
    userId?: string | null
    taskItemId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TaskEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWorkTaskEventTypeFieldUpdateOperationsInput | $Enums.WorkTaskEventType
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: WorkTaskUpdateOneRequiredWithoutEventsNestedInput
    user?: UserUpdateOneWithoutTaskEventsNestedInput
  }

  export type TaskEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWorkTaskEventTypeFieldUpdateOperationsInput | $Enums.WorkTaskEventType
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskEventCreateManyInput = {
    id?: string
    taskId: string
    eventType: $Enums.WorkTaskEventType
    userId?: string | null
    taskItemId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TaskEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWorkTaskEventTypeFieldUpdateOperationsInput | $Enums.WorkTaskEventType
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWorkTaskEventTypeFieldUpdateOperationsInput | $Enums.WorkTaskEventType
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobRecordCreateInput = {
    id?: string
    jobId: string
    queue: string
    name: string
    data: JsonNullValueInput | InputJsonValue
    status: string
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    attempts?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type JobRecordUncheckedCreateInput = {
    id?: string
    jobId: string
    queue: string
    name: string
    data: JsonNullValueInput | InputJsonValue
    status: string
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    attempts?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type JobRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobRecordCreateManyInput = {
    id?: string
    jobId: string
    queue: string
    name: string
    data: JsonNullValueInput | InputJsonValue
    status: string
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    attempts?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type JobRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    correlationId?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    correlationId?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    correlationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    correlationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    correlationId?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    correlationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    correlationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type PasswordResetTokenListRelationFilter = {
    every?: PasswordResetTokenWhereInput
    some?: PasswordResetTokenWhereInput
    none?: PasswordResetTokenWhereInput
  }

  export type WorkTaskListRelationFilter = {
    every?: WorkTaskWhereInput
    some?: WorkTaskWhereInput
    none?: WorkTaskWhereInput
  }

  export type TaskEventListRelationFilter = {
    every?: TaskEventWhereInput
    some?: TaskEventWhereInput
    none?: TaskEventWhereInput
  }

  export type TaskItemListRelationFilter = {
    every?: TaskItemWhereInput
    some?: TaskItemWhereInput
    none?: TaskItemWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    image?: SortOrder
    role?: SortOrder
    active?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    image?: SortOrder
    role?: SortOrder
    active?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    image?: SortOrder
    role?: SortOrder
    active?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductVariantListRelationFilter = {
    every?: ProductVariantWhereInput
    some?: ProductVariantWhereInput
    none?: ProductVariantWhereInput
  }

  export type ProductVariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    brand?: SortOrder
    category?: SortOrder
    shopifyProductId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    brand?: SortOrder
    category?: SortOrder
    shopifyProductId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    brand?: SortOrder
    category?: SortOrder
    shopifyProductId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type InventoryUnitListRelationFilter = {
    every?: InventoryUnitWhereInput
    some?: InventoryUnitWhereInput
    none?: InventoryUnitWhereInput
  }

  export type AllocationListRelationFilter = {
    every?: AllocationWhereInput
    some?: AllocationWhereInput
    none?: AllocationWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryUnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AllocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductVariantCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    upc?: SortOrder
    barcode?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    shopifyVariantId?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    weight?: SortOrder
    trackLots?: SortOrder
    trackExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantAvgOrderByAggregateInput = {
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    weight?: SortOrder
  }

  export type ProductVariantMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    upc?: SortOrder
    barcode?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    shopifyVariantId?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    weight?: SortOrder
    trackLots?: SortOrder
    trackExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    upc?: SortOrder
    barcode?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    shopifyVariantId?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    weight?: SortOrder
    trackLots?: SortOrder
    trackExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantSumOrderByAggregateInput = {
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    weight?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumLocationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLocationTypeFilter<$PrismaModel> | $Enums.LocationType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    type?: SortOrder
    zone?: SortOrder
    aisle?: SortOrder
    rack?: SortOrder
    shelf?: SortOrder
    bin?: SortOrder
    pickSequence?: SortOrder
    isPickable?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    pickSequence?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    type?: SortOrder
    zone?: SortOrder
    aisle?: SortOrder
    rack?: SortOrder
    shelf?: SortOrder
    bin?: SortOrder
    pickSequence?: SortOrder
    isPickable?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    type?: SortOrder
    zone?: SortOrder
    aisle?: SortOrder
    rack?: SortOrder
    shelf?: SortOrder
    bin?: SortOrder
    pickSequence?: SortOrder
    isPickable?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    pickSequence?: SortOrder
  }

  export type EnumLocationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLocationTypeWithAggregatesFilter<$PrismaModel> | $Enums.LocationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLocationTypeFilter<$PrismaModel>
    _max?: NestedEnumLocationTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumInventoryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryStatus | EnumInventoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryStatusFilter<$PrismaModel> | $Enums.InventoryStatus
  }

  export type ProductVariantScalarRelationFilter = {
    is?: ProductVariantWhereInput
    isNot?: ProductVariantWhereInput
  }

  export type LocationScalarRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type InventoryUnitCountOrderByAggregateInput = {
    id?: SortOrder
    productVariantId?: SortOrder
    locationId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    lotNumber?: SortOrder
    expiryDate?: SortOrder
    receivedAt?: SortOrder
    receivedFrom?: SortOrder
    unitCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryUnitAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitCost?: SortOrder
  }

  export type InventoryUnitMaxOrderByAggregateInput = {
    id?: SortOrder
    productVariantId?: SortOrder
    locationId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    lotNumber?: SortOrder
    expiryDate?: SortOrder
    receivedAt?: SortOrder
    receivedFrom?: SortOrder
    unitCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryUnitMinOrderByAggregateInput = {
    id?: SortOrder
    productVariantId?: SortOrder
    locationId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    lotNumber?: SortOrder
    expiryDate?: SortOrder
    receivedAt?: SortOrder
    receivedFrom?: SortOrder
    unitCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryUnitSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitCost?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumInventoryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryStatus | EnumInventoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryStatusWithAggregatesFilter<$PrismaModel> | $Enums.InventoryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInventoryStatusFilter<$PrismaModel>
    _max?: NestedEnumInventoryStatusFilter<$PrismaModel>
  }

  export type EnumAllocationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AllocationStatus | EnumAllocationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AllocationStatus[] | ListEnumAllocationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AllocationStatus[] | ListEnumAllocationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAllocationStatusFilter<$PrismaModel> | $Enums.AllocationStatus
  }

  export type InventoryUnitScalarRelationFilter = {
    is?: InventoryUnitWhereInput
    isNot?: InventoryUnitWhereInput
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderItemNullableScalarRelationFilter = {
    is?: OrderItemWhereInput | null
    isNot?: OrderItemWhereInput | null
  }

  export type TaskItemNullableScalarRelationFilter = {
    is?: TaskItemWhereInput | null
    isNot?: TaskItemWhereInput | null
  }

  export type AllocationCountOrderByAggregateInput = {
    id?: SortOrder
    inventoryUnitId?: SortOrder
    orderId?: SortOrder
    orderItemId?: SortOrder
    productVariantId?: SortOrder
    locationId?: SortOrder
    quantity?: SortOrder
    lotNumber?: SortOrder
    status?: SortOrder
    allocatedAt?: SortOrder
    releasedAt?: SortOrder
    pickedAt?: SortOrder
    taskItemId?: SortOrder
  }

  export type AllocationAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type AllocationMaxOrderByAggregateInput = {
    id?: SortOrder
    inventoryUnitId?: SortOrder
    orderId?: SortOrder
    orderItemId?: SortOrder
    productVariantId?: SortOrder
    locationId?: SortOrder
    quantity?: SortOrder
    lotNumber?: SortOrder
    status?: SortOrder
    allocatedAt?: SortOrder
    releasedAt?: SortOrder
    pickedAt?: SortOrder
    taskItemId?: SortOrder
  }

  export type AllocationMinOrderByAggregateInput = {
    id?: SortOrder
    inventoryUnitId?: SortOrder
    orderId?: SortOrder
    orderItemId?: SortOrder
    productVariantId?: SortOrder
    locationId?: SortOrder
    quantity?: SortOrder
    lotNumber?: SortOrder
    status?: SortOrder
    allocatedAt?: SortOrder
    releasedAt?: SortOrder
    pickedAt?: SortOrder
    taskItemId?: SortOrder
  }

  export type AllocationSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumAllocationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AllocationStatus | EnumAllocationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AllocationStatus[] | ListEnumAllocationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AllocationStatus[] | ListEnumAllocationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAllocationStatusWithAggregatesFilter<$PrismaModel> | $Enums.AllocationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAllocationStatusFilter<$PrismaModel>
    _max?: NestedEnumAllocationStatusFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    shopifyOrderId?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    shippingAddress?: SortOrder
    billingAddress?: SortOrder
    shopifyLineItems?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    priority?: SortOrder
    holdReason?: SortOrder
    holdAt?: SortOrder
    holdBy?: SortOrder
    unmatchedItems?: SortOrder
    totalAmount?: SortOrder
    warehouseId?: SortOrder
    trackingNumber?: SortOrder
    shippedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    unmatchedItems?: SortOrder
    totalAmount?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    shopifyOrderId?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    priority?: SortOrder
    holdReason?: SortOrder
    holdAt?: SortOrder
    holdBy?: SortOrder
    unmatchedItems?: SortOrder
    totalAmount?: SortOrder
    warehouseId?: SortOrder
    trackingNumber?: SortOrder
    shippedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    shopifyOrderId?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    priority?: SortOrder
    holdReason?: SortOrder
    holdAt?: SortOrder
    holdBy?: SortOrder
    unmatchedItems?: SortOrder
    totalAmount?: SortOrder
    warehouseId?: SortOrder
    trackingNumber?: SortOrder
    shippedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    unmatchedItems?: SortOrder
    totalAmount?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type ProductVariantNullableScalarRelationFilter = {
    is?: ProductVariantWhereInput | null
    isNot?: ProductVariantWhereInput | null
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productVariantId?: SortOrder
    sku?: SortOrder
    quantity?: SortOrder
    quantityAllocated?: SortOrder
    quantityPicked?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    matched?: SortOrder
    matchError?: SortOrder
    shopifyLineItemId?: SortOrder
    shopifyFulfillmentOrderLineItemId?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    quantityAllocated?: SortOrder
    quantityPicked?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productVariantId?: SortOrder
    sku?: SortOrder
    quantity?: SortOrder
    quantityAllocated?: SortOrder
    quantityPicked?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    matched?: SortOrder
    matchError?: SortOrder
    shopifyLineItemId?: SortOrder
    shopifyFulfillmentOrderLineItemId?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productVariantId?: SortOrder
    sku?: SortOrder
    quantity?: SortOrder
    quantityAllocated?: SortOrder
    quantityPicked?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    matched?: SortOrder
    matchError?: SortOrder
    shopifyLineItemId?: SortOrder
    shopifyFulfillmentOrderLineItemId?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    quantityAllocated?: SortOrder
    quantityPicked?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type EnumWorkTaskTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTaskType | EnumWorkTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkTaskType[] | ListEnumWorkTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkTaskType[] | ListEnumWorkTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTaskTypeFilter<$PrismaModel> | $Enums.WorkTaskType
  }

  export type EnumWorkTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTaskStatus | EnumWorkTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkTaskStatus[] | ListEnumWorkTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkTaskStatus[] | ListEnumWorkTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTaskStatusFilter<$PrismaModel> | $Enums.WorkTaskStatus
  }

  export type EnumWorkTaskBlockReasonNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTaskBlockReason | EnumWorkTaskBlockReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.WorkTaskBlockReason[] | ListEnumWorkTaskBlockReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WorkTaskBlockReason[] | ListEnumWorkTaskBlockReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWorkTaskBlockReasonNullableFilter<$PrismaModel> | $Enums.WorkTaskBlockReason | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type WorkTaskCountOrderByAggregateInput = {
    id?: SortOrder
    taskNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    idempotencyKey?: SortOrder
    assignedTo?: SortOrder
    assignedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    blockReason?: SortOrder
    blockedAt?: SortOrder
    orderIds?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    totalItems?: SortOrder
    completedItems?: SortOrder
    shortItems?: SortOrder
    skippedItems?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkTaskAvgOrderByAggregateInput = {
    priority?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    totalItems?: SortOrder
    completedItems?: SortOrder
    shortItems?: SortOrder
    skippedItems?: SortOrder
  }

  export type WorkTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    taskNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    idempotencyKey?: SortOrder
    assignedTo?: SortOrder
    assignedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    blockReason?: SortOrder
    blockedAt?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    totalItems?: SortOrder
    completedItems?: SortOrder
    shortItems?: SortOrder
    skippedItems?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkTaskMinOrderByAggregateInput = {
    id?: SortOrder
    taskNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    idempotencyKey?: SortOrder
    assignedTo?: SortOrder
    assignedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    blockReason?: SortOrder
    blockedAt?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    totalItems?: SortOrder
    completedItems?: SortOrder
    shortItems?: SortOrder
    skippedItems?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkTaskSumOrderByAggregateInput = {
    priority?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    totalItems?: SortOrder
    completedItems?: SortOrder
    shortItems?: SortOrder
    skippedItems?: SortOrder
  }

  export type EnumWorkTaskTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTaskType | EnumWorkTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkTaskType[] | ListEnumWorkTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkTaskType[] | ListEnumWorkTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTaskTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkTaskType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkTaskTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkTaskTypeFilter<$PrismaModel>
  }

  export type EnumWorkTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTaskStatus | EnumWorkTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkTaskStatus[] | ListEnumWorkTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkTaskStatus[] | ListEnumWorkTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkTaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkTaskStatusFilter<$PrismaModel>
  }

  export type EnumWorkTaskBlockReasonNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTaskBlockReason | EnumWorkTaskBlockReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.WorkTaskBlockReason[] | ListEnumWorkTaskBlockReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WorkTaskBlockReason[] | ListEnumWorkTaskBlockReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWorkTaskBlockReasonNullableWithAggregatesFilter<$PrismaModel> | $Enums.WorkTaskBlockReason | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumWorkTaskBlockReasonNullableFilter<$PrismaModel>
    _max?: NestedEnumWorkTaskBlockReasonNullableFilter<$PrismaModel>
  }

  export type EnumWorkTaskItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTaskItemStatus | EnumWorkTaskItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkTaskItemStatus[] | ListEnumWorkTaskItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkTaskItemStatus[] | ListEnumWorkTaskItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTaskItemStatusFilter<$PrismaModel> | $Enums.WorkTaskItemStatus
  }

  export type WorkTaskScalarRelationFilter = {
    is?: WorkTaskWhereInput
    isNot?: WorkTaskWhereInput
  }

  export type LocationNullableScalarRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type AllocationNullableScalarRelationFilter = {
    is?: AllocationWhereInput | null
    isNot?: AllocationWhereInput | null
  }

  export type TaskItemCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    orderId?: SortOrder
    orderItemId?: SortOrder
    productVariantId?: SortOrder
    locationId?: SortOrder
    allocationId?: SortOrder
    sequence?: SortOrder
    quantityRequired?: SortOrder
    quantityCompleted?: SortOrder
    status?: SortOrder
    completedBy?: SortOrder
    completedAt?: SortOrder
    shortReason?: SortOrder
    locationScanned?: SortOrder
    itemScanned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskItemAvgOrderByAggregateInput = {
    sequence?: SortOrder
    quantityRequired?: SortOrder
    quantityCompleted?: SortOrder
  }

  export type TaskItemMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    orderId?: SortOrder
    orderItemId?: SortOrder
    productVariantId?: SortOrder
    locationId?: SortOrder
    allocationId?: SortOrder
    sequence?: SortOrder
    quantityRequired?: SortOrder
    quantityCompleted?: SortOrder
    status?: SortOrder
    completedBy?: SortOrder
    completedAt?: SortOrder
    shortReason?: SortOrder
    locationScanned?: SortOrder
    itemScanned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskItemMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    orderId?: SortOrder
    orderItemId?: SortOrder
    productVariantId?: SortOrder
    locationId?: SortOrder
    allocationId?: SortOrder
    sequence?: SortOrder
    quantityRequired?: SortOrder
    quantityCompleted?: SortOrder
    status?: SortOrder
    completedBy?: SortOrder
    completedAt?: SortOrder
    shortReason?: SortOrder
    locationScanned?: SortOrder
    itemScanned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskItemSumOrderByAggregateInput = {
    sequence?: SortOrder
    quantityRequired?: SortOrder
    quantityCompleted?: SortOrder
  }

  export type EnumWorkTaskItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTaskItemStatus | EnumWorkTaskItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkTaskItemStatus[] | ListEnumWorkTaskItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkTaskItemStatus[] | ListEnumWorkTaskItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTaskItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkTaskItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkTaskItemStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkTaskItemStatusFilter<$PrismaModel>
  }

  export type EnumWorkTaskEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTaskEventType | EnumWorkTaskEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkTaskEventType[] | ListEnumWorkTaskEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkTaskEventType[] | ListEnumWorkTaskEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTaskEventTypeFilter<$PrismaModel> | $Enums.WorkTaskEventType
  }

  export type TaskEventCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    eventType?: SortOrder
    userId?: SortOrder
    taskItemId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskEventMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    eventType?: SortOrder
    userId?: SortOrder
    taskItemId?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskEventMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    eventType?: SortOrder
    userId?: SortOrder
    taskItemId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumWorkTaskEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTaskEventType | EnumWorkTaskEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkTaskEventType[] | ListEnumWorkTaskEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkTaskEventType[] | ListEnumWorkTaskEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTaskEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkTaskEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkTaskEventTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkTaskEventTypeFilter<$PrismaModel>
  }

  export type JobRecordCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    queue?: SortOrder
    name?: SortOrder
    data?: SortOrder
    status?: SortOrder
    result?: SortOrder
    error?: SortOrder
    attempts?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type JobRecordAvgOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type JobRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    queue?: SortOrder
    name?: SortOrder
    status?: SortOrder
    error?: SortOrder
    attempts?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type JobRecordMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    queue?: SortOrder
    name?: SortOrder
    status?: SortOrder
    error?: SortOrder
    attempts?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type JobRecordSumOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    correlationId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    correlationId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    correlationId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type PasswordResetTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type WorkTaskCreateNestedManyWithoutAssignedUserInput = {
    create?: XOR<WorkTaskCreateWithoutAssignedUserInput, WorkTaskUncheckedCreateWithoutAssignedUserInput> | WorkTaskCreateWithoutAssignedUserInput[] | WorkTaskUncheckedCreateWithoutAssignedUserInput[]
    connectOrCreate?: WorkTaskCreateOrConnectWithoutAssignedUserInput | WorkTaskCreateOrConnectWithoutAssignedUserInput[]
    createMany?: WorkTaskCreateManyAssignedUserInputEnvelope
    connect?: WorkTaskWhereUniqueInput | WorkTaskWhereUniqueInput[]
  }

  export type TaskEventCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskEventCreateWithoutUserInput, TaskEventUncheckedCreateWithoutUserInput> | TaskEventCreateWithoutUserInput[] | TaskEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskEventCreateOrConnectWithoutUserInput | TaskEventCreateOrConnectWithoutUserInput[]
    createMany?: TaskEventCreateManyUserInputEnvelope
    connect?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
  }

  export type TaskItemCreateNestedManyWithoutCompletedByUserInput = {
    create?: XOR<TaskItemCreateWithoutCompletedByUserInput, TaskItemUncheckedCreateWithoutCompletedByUserInput> | TaskItemCreateWithoutCompletedByUserInput[] | TaskItemUncheckedCreateWithoutCompletedByUserInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutCompletedByUserInput | TaskItemCreateOrConnectWithoutCompletedByUserInput[]
    createMany?: TaskItemCreateManyCompletedByUserInputEnvelope
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type WorkTaskUncheckedCreateNestedManyWithoutAssignedUserInput = {
    create?: XOR<WorkTaskCreateWithoutAssignedUserInput, WorkTaskUncheckedCreateWithoutAssignedUserInput> | WorkTaskCreateWithoutAssignedUserInput[] | WorkTaskUncheckedCreateWithoutAssignedUserInput[]
    connectOrCreate?: WorkTaskCreateOrConnectWithoutAssignedUserInput | WorkTaskCreateOrConnectWithoutAssignedUserInput[]
    createMany?: WorkTaskCreateManyAssignedUserInputEnvelope
    connect?: WorkTaskWhereUniqueInput | WorkTaskWhereUniqueInput[]
  }

  export type TaskEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskEventCreateWithoutUserInput, TaskEventUncheckedCreateWithoutUserInput> | TaskEventCreateWithoutUserInput[] | TaskEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskEventCreateOrConnectWithoutUserInput | TaskEventCreateOrConnectWithoutUserInput[]
    createMany?: TaskEventCreateManyUserInputEnvelope
    connect?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
  }

  export type TaskItemUncheckedCreateNestedManyWithoutCompletedByUserInput = {
    create?: XOR<TaskItemCreateWithoutCompletedByUserInput, TaskItemUncheckedCreateWithoutCompletedByUserInput> | TaskItemCreateWithoutCompletedByUserInput[] | TaskItemUncheckedCreateWithoutCompletedByUserInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutCompletedByUserInput | TaskItemCreateOrConnectWithoutCompletedByUserInput[]
    createMany?: TaskItemCreateManyCompletedByUserInputEnvelope
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type PasswordResetTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type WorkTaskUpdateManyWithoutAssignedUserNestedInput = {
    create?: XOR<WorkTaskCreateWithoutAssignedUserInput, WorkTaskUncheckedCreateWithoutAssignedUserInput> | WorkTaskCreateWithoutAssignedUserInput[] | WorkTaskUncheckedCreateWithoutAssignedUserInput[]
    connectOrCreate?: WorkTaskCreateOrConnectWithoutAssignedUserInput | WorkTaskCreateOrConnectWithoutAssignedUserInput[]
    upsert?: WorkTaskUpsertWithWhereUniqueWithoutAssignedUserInput | WorkTaskUpsertWithWhereUniqueWithoutAssignedUserInput[]
    createMany?: WorkTaskCreateManyAssignedUserInputEnvelope
    set?: WorkTaskWhereUniqueInput | WorkTaskWhereUniqueInput[]
    disconnect?: WorkTaskWhereUniqueInput | WorkTaskWhereUniqueInput[]
    delete?: WorkTaskWhereUniqueInput | WorkTaskWhereUniqueInput[]
    connect?: WorkTaskWhereUniqueInput | WorkTaskWhereUniqueInput[]
    update?: WorkTaskUpdateWithWhereUniqueWithoutAssignedUserInput | WorkTaskUpdateWithWhereUniqueWithoutAssignedUserInput[]
    updateMany?: WorkTaskUpdateManyWithWhereWithoutAssignedUserInput | WorkTaskUpdateManyWithWhereWithoutAssignedUserInput[]
    deleteMany?: WorkTaskScalarWhereInput | WorkTaskScalarWhereInput[]
  }

  export type TaskEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskEventCreateWithoutUserInput, TaskEventUncheckedCreateWithoutUserInput> | TaskEventCreateWithoutUserInput[] | TaskEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskEventCreateOrConnectWithoutUserInput | TaskEventCreateOrConnectWithoutUserInput[]
    upsert?: TaskEventUpsertWithWhereUniqueWithoutUserInput | TaskEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskEventCreateManyUserInputEnvelope
    set?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    disconnect?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    delete?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    connect?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    update?: TaskEventUpdateWithWhereUniqueWithoutUserInput | TaskEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskEventUpdateManyWithWhereWithoutUserInput | TaskEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskEventScalarWhereInput | TaskEventScalarWhereInput[]
  }

  export type TaskItemUpdateManyWithoutCompletedByUserNestedInput = {
    create?: XOR<TaskItemCreateWithoutCompletedByUserInput, TaskItemUncheckedCreateWithoutCompletedByUserInput> | TaskItemCreateWithoutCompletedByUserInput[] | TaskItemUncheckedCreateWithoutCompletedByUserInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutCompletedByUserInput | TaskItemCreateOrConnectWithoutCompletedByUserInput[]
    upsert?: TaskItemUpsertWithWhereUniqueWithoutCompletedByUserInput | TaskItemUpsertWithWhereUniqueWithoutCompletedByUserInput[]
    createMany?: TaskItemCreateManyCompletedByUserInputEnvelope
    set?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    disconnect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    delete?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    update?: TaskItemUpdateWithWhereUniqueWithoutCompletedByUserInput | TaskItemUpdateWithWhereUniqueWithoutCompletedByUserInput[]
    updateMany?: TaskItemUpdateManyWithWhereWithoutCompletedByUserInput | TaskItemUpdateManyWithWhereWithoutCompletedByUserInput[]
    deleteMany?: TaskItemScalarWhereInput | TaskItemScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type WorkTaskUncheckedUpdateManyWithoutAssignedUserNestedInput = {
    create?: XOR<WorkTaskCreateWithoutAssignedUserInput, WorkTaskUncheckedCreateWithoutAssignedUserInput> | WorkTaskCreateWithoutAssignedUserInput[] | WorkTaskUncheckedCreateWithoutAssignedUserInput[]
    connectOrCreate?: WorkTaskCreateOrConnectWithoutAssignedUserInput | WorkTaskCreateOrConnectWithoutAssignedUserInput[]
    upsert?: WorkTaskUpsertWithWhereUniqueWithoutAssignedUserInput | WorkTaskUpsertWithWhereUniqueWithoutAssignedUserInput[]
    createMany?: WorkTaskCreateManyAssignedUserInputEnvelope
    set?: WorkTaskWhereUniqueInput | WorkTaskWhereUniqueInput[]
    disconnect?: WorkTaskWhereUniqueInput | WorkTaskWhereUniqueInput[]
    delete?: WorkTaskWhereUniqueInput | WorkTaskWhereUniqueInput[]
    connect?: WorkTaskWhereUniqueInput | WorkTaskWhereUniqueInput[]
    update?: WorkTaskUpdateWithWhereUniqueWithoutAssignedUserInput | WorkTaskUpdateWithWhereUniqueWithoutAssignedUserInput[]
    updateMany?: WorkTaskUpdateManyWithWhereWithoutAssignedUserInput | WorkTaskUpdateManyWithWhereWithoutAssignedUserInput[]
    deleteMany?: WorkTaskScalarWhereInput | WorkTaskScalarWhereInput[]
  }

  export type TaskEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskEventCreateWithoutUserInput, TaskEventUncheckedCreateWithoutUserInput> | TaskEventCreateWithoutUserInput[] | TaskEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskEventCreateOrConnectWithoutUserInput | TaskEventCreateOrConnectWithoutUserInput[]
    upsert?: TaskEventUpsertWithWhereUniqueWithoutUserInput | TaskEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskEventCreateManyUserInputEnvelope
    set?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    disconnect?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    delete?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    connect?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    update?: TaskEventUpdateWithWhereUniqueWithoutUserInput | TaskEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskEventUpdateManyWithWhereWithoutUserInput | TaskEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskEventScalarWhereInput | TaskEventScalarWhereInput[]
  }

  export type TaskItemUncheckedUpdateManyWithoutCompletedByUserNestedInput = {
    create?: XOR<TaskItemCreateWithoutCompletedByUserInput, TaskItemUncheckedCreateWithoutCompletedByUserInput> | TaskItemCreateWithoutCompletedByUserInput[] | TaskItemUncheckedCreateWithoutCompletedByUserInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutCompletedByUserInput | TaskItemCreateOrConnectWithoutCompletedByUserInput[]
    upsert?: TaskItemUpsertWithWhereUniqueWithoutCompletedByUserInput | TaskItemUpsertWithWhereUniqueWithoutCompletedByUserInput[]
    createMany?: TaskItemCreateManyCompletedByUserInputEnvelope
    set?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    disconnect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    delete?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    update?: TaskItemUpdateWithWhereUniqueWithoutCompletedByUserInput | TaskItemUpdateWithWhereUniqueWithoutCompletedByUserInput[]
    updateMany?: TaskItemUpdateManyWithWhereWithoutCompletedByUserInput | TaskItemUpdateManyWithWhereWithoutCompletedByUserInput[]
    deleteMany?: TaskItemScalarWhereInput | TaskItemScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetTokensInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    upsert?: UserUpsertWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetTokensInput, UserUpdateWithoutPasswordResetTokensInput>, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type ProductVariantCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
  }

  export type ProductVariantUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
  }

  export type ProductVariantUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    upsert?: ProductVariantUpsertWithWhereUniqueWithoutProductInput | ProductVariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    set?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    disconnect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    delete?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    update?: ProductVariantUpdateWithWhereUniqueWithoutProductInput | ProductVariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductVariantUpdateManyWithWhereWithoutProductInput | ProductVariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
  }

  export type ProductVariantUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    upsert?: ProductVariantUpsertWithWhereUniqueWithoutProductInput | ProductVariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    set?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    disconnect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    delete?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    update?: ProductVariantUpdateWithWhereUniqueWithoutProductInput | ProductVariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductVariantUpdateManyWithWhereWithoutProductInput | ProductVariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutVariantsInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutProductVariantInput = {
    create?: XOR<OrderItemCreateWithoutProductVariantInput, OrderItemUncheckedCreateWithoutProductVariantInput> | OrderItemCreateWithoutProductVariantInput[] | OrderItemUncheckedCreateWithoutProductVariantInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductVariantInput | OrderItemCreateOrConnectWithoutProductVariantInput[]
    createMany?: OrderItemCreateManyProductVariantInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type InventoryUnitCreateNestedManyWithoutProductVariantInput = {
    create?: XOR<InventoryUnitCreateWithoutProductVariantInput, InventoryUnitUncheckedCreateWithoutProductVariantInput> | InventoryUnitCreateWithoutProductVariantInput[] | InventoryUnitUncheckedCreateWithoutProductVariantInput[]
    connectOrCreate?: InventoryUnitCreateOrConnectWithoutProductVariantInput | InventoryUnitCreateOrConnectWithoutProductVariantInput[]
    createMany?: InventoryUnitCreateManyProductVariantInputEnvelope
    connect?: InventoryUnitWhereUniqueInput | InventoryUnitWhereUniqueInput[]
  }

  export type TaskItemCreateNestedManyWithoutProductVariantInput = {
    create?: XOR<TaskItemCreateWithoutProductVariantInput, TaskItemUncheckedCreateWithoutProductVariantInput> | TaskItemCreateWithoutProductVariantInput[] | TaskItemUncheckedCreateWithoutProductVariantInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutProductVariantInput | TaskItemCreateOrConnectWithoutProductVariantInput[]
    createMany?: TaskItemCreateManyProductVariantInputEnvelope
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
  }

  export type AllocationCreateNestedManyWithoutProductVariantInput = {
    create?: XOR<AllocationCreateWithoutProductVariantInput, AllocationUncheckedCreateWithoutProductVariantInput> | AllocationCreateWithoutProductVariantInput[] | AllocationUncheckedCreateWithoutProductVariantInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutProductVariantInput | AllocationCreateOrConnectWithoutProductVariantInput[]
    createMany?: AllocationCreateManyProductVariantInputEnvelope
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductVariantInput = {
    create?: XOR<OrderItemCreateWithoutProductVariantInput, OrderItemUncheckedCreateWithoutProductVariantInput> | OrderItemCreateWithoutProductVariantInput[] | OrderItemUncheckedCreateWithoutProductVariantInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductVariantInput | OrderItemCreateOrConnectWithoutProductVariantInput[]
    createMany?: OrderItemCreateManyProductVariantInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type InventoryUnitUncheckedCreateNestedManyWithoutProductVariantInput = {
    create?: XOR<InventoryUnitCreateWithoutProductVariantInput, InventoryUnitUncheckedCreateWithoutProductVariantInput> | InventoryUnitCreateWithoutProductVariantInput[] | InventoryUnitUncheckedCreateWithoutProductVariantInput[]
    connectOrCreate?: InventoryUnitCreateOrConnectWithoutProductVariantInput | InventoryUnitCreateOrConnectWithoutProductVariantInput[]
    createMany?: InventoryUnitCreateManyProductVariantInputEnvelope
    connect?: InventoryUnitWhereUniqueInput | InventoryUnitWhereUniqueInput[]
  }

  export type TaskItemUncheckedCreateNestedManyWithoutProductVariantInput = {
    create?: XOR<TaskItemCreateWithoutProductVariantInput, TaskItemUncheckedCreateWithoutProductVariantInput> | TaskItemCreateWithoutProductVariantInput[] | TaskItemUncheckedCreateWithoutProductVariantInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutProductVariantInput | TaskItemCreateOrConnectWithoutProductVariantInput[]
    createMany?: TaskItemCreateManyProductVariantInputEnvelope
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
  }

  export type AllocationUncheckedCreateNestedManyWithoutProductVariantInput = {
    create?: XOR<AllocationCreateWithoutProductVariantInput, AllocationUncheckedCreateWithoutProductVariantInput> | AllocationCreateWithoutProductVariantInput[] | AllocationUncheckedCreateWithoutProductVariantInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutProductVariantInput | AllocationCreateOrConnectWithoutProductVariantInput[]
    createMany?: AllocationCreateManyProductVariantInputEnvelope
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ProductUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    upsert?: ProductUpsertWithoutVariantsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutVariantsInput, ProductUpdateWithoutVariantsInput>, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type OrderItemUpdateManyWithoutProductVariantNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductVariantInput, OrderItemUncheckedCreateWithoutProductVariantInput> | OrderItemCreateWithoutProductVariantInput[] | OrderItemUncheckedCreateWithoutProductVariantInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductVariantInput | OrderItemCreateOrConnectWithoutProductVariantInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductVariantInput | OrderItemUpsertWithWhereUniqueWithoutProductVariantInput[]
    createMany?: OrderItemCreateManyProductVariantInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductVariantInput | OrderItemUpdateWithWhereUniqueWithoutProductVariantInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductVariantInput | OrderItemUpdateManyWithWhereWithoutProductVariantInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type InventoryUnitUpdateManyWithoutProductVariantNestedInput = {
    create?: XOR<InventoryUnitCreateWithoutProductVariantInput, InventoryUnitUncheckedCreateWithoutProductVariantInput> | InventoryUnitCreateWithoutProductVariantInput[] | InventoryUnitUncheckedCreateWithoutProductVariantInput[]
    connectOrCreate?: InventoryUnitCreateOrConnectWithoutProductVariantInput | InventoryUnitCreateOrConnectWithoutProductVariantInput[]
    upsert?: InventoryUnitUpsertWithWhereUniqueWithoutProductVariantInput | InventoryUnitUpsertWithWhereUniqueWithoutProductVariantInput[]
    createMany?: InventoryUnitCreateManyProductVariantInputEnvelope
    set?: InventoryUnitWhereUniqueInput | InventoryUnitWhereUniqueInput[]
    disconnect?: InventoryUnitWhereUniqueInput | InventoryUnitWhereUniqueInput[]
    delete?: InventoryUnitWhereUniqueInput | InventoryUnitWhereUniqueInput[]
    connect?: InventoryUnitWhereUniqueInput | InventoryUnitWhereUniqueInput[]
    update?: InventoryUnitUpdateWithWhereUniqueWithoutProductVariantInput | InventoryUnitUpdateWithWhereUniqueWithoutProductVariantInput[]
    updateMany?: InventoryUnitUpdateManyWithWhereWithoutProductVariantInput | InventoryUnitUpdateManyWithWhereWithoutProductVariantInput[]
    deleteMany?: InventoryUnitScalarWhereInput | InventoryUnitScalarWhereInput[]
  }

  export type TaskItemUpdateManyWithoutProductVariantNestedInput = {
    create?: XOR<TaskItemCreateWithoutProductVariantInput, TaskItemUncheckedCreateWithoutProductVariantInput> | TaskItemCreateWithoutProductVariantInput[] | TaskItemUncheckedCreateWithoutProductVariantInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutProductVariantInput | TaskItemCreateOrConnectWithoutProductVariantInput[]
    upsert?: TaskItemUpsertWithWhereUniqueWithoutProductVariantInput | TaskItemUpsertWithWhereUniqueWithoutProductVariantInput[]
    createMany?: TaskItemCreateManyProductVariantInputEnvelope
    set?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    disconnect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    delete?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    update?: TaskItemUpdateWithWhereUniqueWithoutProductVariantInput | TaskItemUpdateWithWhereUniqueWithoutProductVariantInput[]
    updateMany?: TaskItemUpdateManyWithWhereWithoutProductVariantInput | TaskItemUpdateManyWithWhereWithoutProductVariantInput[]
    deleteMany?: TaskItemScalarWhereInput | TaskItemScalarWhereInput[]
  }

  export type AllocationUpdateManyWithoutProductVariantNestedInput = {
    create?: XOR<AllocationCreateWithoutProductVariantInput, AllocationUncheckedCreateWithoutProductVariantInput> | AllocationCreateWithoutProductVariantInput[] | AllocationUncheckedCreateWithoutProductVariantInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutProductVariantInput | AllocationCreateOrConnectWithoutProductVariantInput[]
    upsert?: AllocationUpsertWithWhereUniqueWithoutProductVariantInput | AllocationUpsertWithWhereUniqueWithoutProductVariantInput[]
    createMany?: AllocationCreateManyProductVariantInputEnvelope
    set?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    disconnect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    delete?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    update?: AllocationUpdateWithWhereUniqueWithoutProductVariantInput | AllocationUpdateWithWhereUniqueWithoutProductVariantInput[]
    updateMany?: AllocationUpdateManyWithWhereWithoutProductVariantInput | AllocationUpdateManyWithWhereWithoutProductVariantInput[]
    deleteMany?: AllocationScalarWhereInput | AllocationScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductVariantNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductVariantInput, OrderItemUncheckedCreateWithoutProductVariantInput> | OrderItemCreateWithoutProductVariantInput[] | OrderItemUncheckedCreateWithoutProductVariantInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductVariantInput | OrderItemCreateOrConnectWithoutProductVariantInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductVariantInput | OrderItemUpsertWithWhereUniqueWithoutProductVariantInput[]
    createMany?: OrderItemCreateManyProductVariantInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductVariantInput | OrderItemUpdateWithWhereUniqueWithoutProductVariantInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductVariantInput | OrderItemUpdateManyWithWhereWithoutProductVariantInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type InventoryUnitUncheckedUpdateManyWithoutProductVariantNestedInput = {
    create?: XOR<InventoryUnitCreateWithoutProductVariantInput, InventoryUnitUncheckedCreateWithoutProductVariantInput> | InventoryUnitCreateWithoutProductVariantInput[] | InventoryUnitUncheckedCreateWithoutProductVariantInput[]
    connectOrCreate?: InventoryUnitCreateOrConnectWithoutProductVariantInput | InventoryUnitCreateOrConnectWithoutProductVariantInput[]
    upsert?: InventoryUnitUpsertWithWhereUniqueWithoutProductVariantInput | InventoryUnitUpsertWithWhereUniqueWithoutProductVariantInput[]
    createMany?: InventoryUnitCreateManyProductVariantInputEnvelope
    set?: InventoryUnitWhereUniqueInput | InventoryUnitWhereUniqueInput[]
    disconnect?: InventoryUnitWhereUniqueInput | InventoryUnitWhereUniqueInput[]
    delete?: InventoryUnitWhereUniqueInput | InventoryUnitWhereUniqueInput[]
    connect?: InventoryUnitWhereUniqueInput | InventoryUnitWhereUniqueInput[]
    update?: InventoryUnitUpdateWithWhereUniqueWithoutProductVariantInput | InventoryUnitUpdateWithWhereUniqueWithoutProductVariantInput[]
    updateMany?: InventoryUnitUpdateManyWithWhereWithoutProductVariantInput | InventoryUnitUpdateManyWithWhereWithoutProductVariantInput[]
    deleteMany?: InventoryUnitScalarWhereInput | InventoryUnitScalarWhereInput[]
  }

  export type TaskItemUncheckedUpdateManyWithoutProductVariantNestedInput = {
    create?: XOR<TaskItemCreateWithoutProductVariantInput, TaskItemUncheckedCreateWithoutProductVariantInput> | TaskItemCreateWithoutProductVariantInput[] | TaskItemUncheckedCreateWithoutProductVariantInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutProductVariantInput | TaskItemCreateOrConnectWithoutProductVariantInput[]
    upsert?: TaskItemUpsertWithWhereUniqueWithoutProductVariantInput | TaskItemUpsertWithWhereUniqueWithoutProductVariantInput[]
    createMany?: TaskItemCreateManyProductVariantInputEnvelope
    set?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    disconnect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    delete?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    update?: TaskItemUpdateWithWhereUniqueWithoutProductVariantInput | TaskItemUpdateWithWhereUniqueWithoutProductVariantInput[]
    updateMany?: TaskItemUpdateManyWithWhereWithoutProductVariantInput | TaskItemUpdateManyWithWhereWithoutProductVariantInput[]
    deleteMany?: TaskItemScalarWhereInput | TaskItemScalarWhereInput[]
  }

  export type AllocationUncheckedUpdateManyWithoutProductVariantNestedInput = {
    create?: XOR<AllocationCreateWithoutProductVariantInput, AllocationUncheckedCreateWithoutProductVariantInput> | AllocationCreateWithoutProductVariantInput[] | AllocationUncheckedCreateWithoutProductVariantInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutProductVariantInput | AllocationCreateOrConnectWithoutProductVariantInput[]
    upsert?: AllocationUpsertWithWhereUniqueWithoutProductVariantInput | AllocationUpsertWithWhereUniqueWithoutProductVariantInput[]
    createMany?: AllocationCreateManyProductVariantInputEnvelope
    set?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    disconnect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    delete?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    update?: AllocationUpdateWithWhereUniqueWithoutProductVariantInput | AllocationUpdateWithWhereUniqueWithoutProductVariantInput[]
    updateMany?: AllocationUpdateManyWithWhereWithoutProductVariantInput | AllocationUpdateManyWithWhereWithoutProductVariantInput[]
    deleteMany?: AllocationScalarWhereInput | AllocationScalarWhereInput[]
  }

  export type InventoryUnitCreateNestedManyWithoutLocationInput = {
    create?: XOR<InventoryUnitCreateWithoutLocationInput, InventoryUnitUncheckedCreateWithoutLocationInput> | InventoryUnitCreateWithoutLocationInput[] | InventoryUnitUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InventoryUnitCreateOrConnectWithoutLocationInput | InventoryUnitCreateOrConnectWithoutLocationInput[]
    createMany?: InventoryUnitCreateManyLocationInputEnvelope
    connect?: InventoryUnitWhereUniqueInput | InventoryUnitWhereUniqueInput[]
  }

  export type TaskItemCreateNestedManyWithoutLocationInput = {
    create?: XOR<TaskItemCreateWithoutLocationInput, TaskItemUncheckedCreateWithoutLocationInput> | TaskItemCreateWithoutLocationInput[] | TaskItemUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutLocationInput | TaskItemCreateOrConnectWithoutLocationInput[]
    createMany?: TaskItemCreateManyLocationInputEnvelope
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
  }

  export type AllocationCreateNestedManyWithoutLocationInput = {
    create?: XOR<AllocationCreateWithoutLocationInput, AllocationUncheckedCreateWithoutLocationInput> | AllocationCreateWithoutLocationInput[] | AllocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutLocationInput | AllocationCreateOrConnectWithoutLocationInput[]
    createMany?: AllocationCreateManyLocationInputEnvelope
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
  }

  export type InventoryUnitUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<InventoryUnitCreateWithoutLocationInput, InventoryUnitUncheckedCreateWithoutLocationInput> | InventoryUnitCreateWithoutLocationInput[] | InventoryUnitUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InventoryUnitCreateOrConnectWithoutLocationInput | InventoryUnitCreateOrConnectWithoutLocationInput[]
    createMany?: InventoryUnitCreateManyLocationInputEnvelope
    connect?: InventoryUnitWhereUniqueInput | InventoryUnitWhereUniqueInput[]
  }

  export type TaskItemUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<TaskItemCreateWithoutLocationInput, TaskItemUncheckedCreateWithoutLocationInput> | TaskItemCreateWithoutLocationInput[] | TaskItemUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutLocationInput | TaskItemCreateOrConnectWithoutLocationInput[]
    createMany?: TaskItemCreateManyLocationInputEnvelope
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
  }

  export type AllocationUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<AllocationCreateWithoutLocationInput, AllocationUncheckedCreateWithoutLocationInput> | AllocationCreateWithoutLocationInput[] | AllocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutLocationInput | AllocationCreateOrConnectWithoutLocationInput[]
    createMany?: AllocationCreateManyLocationInputEnvelope
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
  }

  export type EnumLocationTypeFieldUpdateOperationsInput = {
    set?: $Enums.LocationType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InventoryUnitUpdateManyWithoutLocationNestedInput = {
    create?: XOR<InventoryUnitCreateWithoutLocationInput, InventoryUnitUncheckedCreateWithoutLocationInput> | InventoryUnitCreateWithoutLocationInput[] | InventoryUnitUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InventoryUnitCreateOrConnectWithoutLocationInput | InventoryUnitCreateOrConnectWithoutLocationInput[]
    upsert?: InventoryUnitUpsertWithWhereUniqueWithoutLocationInput | InventoryUnitUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: InventoryUnitCreateManyLocationInputEnvelope
    set?: InventoryUnitWhereUniqueInput | InventoryUnitWhereUniqueInput[]
    disconnect?: InventoryUnitWhereUniqueInput | InventoryUnitWhereUniqueInput[]
    delete?: InventoryUnitWhereUniqueInput | InventoryUnitWhereUniqueInput[]
    connect?: InventoryUnitWhereUniqueInput | InventoryUnitWhereUniqueInput[]
    update?: InventoryUnitUpdateWithWhereUniqueWithoutLocationInput | InventoryUnitUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: InventoryUnitUpdateManyWithWhereWithoutLocationInput | InventoryUnitUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: InventoryUnitScalarWhereInput | InventoryUnitScalarWhereInput[]
  }

  export type TaskItemUpdateManyWithoutLocationNestedInput = {
    create?: XOR<TaskItemCreateWithoutLocationInput, TaskItemUncheckedCreateWithoutLocationInput> | TaskItemCreateWithoutLocationInput[] | TaskItemUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutLocationInput | TaskItemCreateOrConnectWithoutLocationInput[]
    upsert?: TaskItemUpsertWithWhereUniqueWithoutLocationInput | TaskItemUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: TaskItemCreateManyLocationInputEnvelope
    set?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    disconnect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    delete?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    update?: TaskItemUpdateWithWhereUniqueWithoutLocationInput | TaskItemUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: TaskItemUpdateManyWithWhereWithoutLocationInput | TaskItemUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: TaskItemScalarWhereInput | TaskItemScalarWhereInput[]
  }

  export type AllocationUpdateManyWithoutLocationNestedInput = {
    create?: XOR<AllocationCreateWithoutLocationInput, AllocationUncheckedCreateWithoutLocationInput> | AllocationCreateWithoutLocationInput[] | AllocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutLocationInput | AllocationCreateOrConnectWithoutLocationInput[]
    upsert?: AllocationUpsertWithWhereUniqueWithoutLocationInput | AllocationUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: AllocationCreateManyLocationInputEnvelope
    set?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    disconnect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    delete?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    update?: AllocationUpdateWithWhereUniqueWithoutLocationInput | AllocationUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: AllocationUpdateManyWithWhereWithoutLocationInput | AllocationUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: AllocationScalarWhereInput | AllocationScalarWhereInput[]
  }

  export type InventoryUnitUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<InventoryUnitCreateWithoutLocationInput, InventoryUnitUncheckedCreateWithoutLocationInput> | InventoryUnitCreateWithoutLocationInput[] | InventoryUnitUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InventoryUnitCreateOrConnectWithoutLocationInput | InventoryUnitCreateOrConnectWithoutLocationInput[]
    upsert?: InventoryUnitUpsertWithWhereUniqueWithoutLocationInput | InventoryUnitUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: InventoryUnitCreateManyLocationInputEnvelope
    set?: InventoryUnitWhereUniqueInput | InventoryUnitWhereUniqueInput[]
    disconnect?: InventoryUnitWhereUniqueInput | InventoryUnitWhereUniqueInput[]
    delete?: InventoryUnitWhereUniqueInput | InventoryUnitWhereUniqueInput[]
    connect?: InventoryUnitWhereUniqueInput | InventoryUnitWhereUniqueInput[]
    update?: InventoryUnitUpdateWithWhereUniqueWithoutLocationInput | InventoryUnitUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: InventoryUnitUpdateManyWithWhereWithoutLocationInput | InventoryUnitUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: InventoryUnitScalarWhereInput | InventoryUnitScalarWhereInput[]
  }

  export type TaskItemUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<TaskItemCreateWithoutLocationInput, TaskItemUncheckedCreateWithoutLocationInput> | TaskItemCreateWithoutLocationInput[] | TaskItemUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutLocationInput | TaskItemCreateOrConnectWithoutLocationInput[]
    upsert?: TaskItemUpsertWithWhereUniqueWithoutLocationInput | TaskItemUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: TaskItemCreateManyLocationInputEnvelope
    set?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    disconnect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    delete?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    update?: TaskItemUpdateWithWhereUniqueWithoutLocationInput | TaskItemUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: TaskItemUpdateManyWithWhereWithoutLocationInput | TaskItemUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: TaskItemScalarWhereInput | TaskItemScalarWhereInput[]
  }

  export type AllocationUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<AllocationCreateWithoutLocationInput, AllocationUncheckedCreateWithoutLocationInput> | AllocationCreateWithoutLocationInput[] | AllocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutLocationInput | AllocationCreateOrConnectWithoutLocationInput[]
    upsert?: AllocationUpsertWithWhereUniqueWithoutLocationInput | AllocationUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: AllocationCreateManyLocationInputEnvelope
    set?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    disconnect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    delete?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    update?: AllocationUpdateWithWhereUniqueWithoutLocationInput | AllocationUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: AllocationUpdateManyWithWhereWithoutLocationInput | AllocationUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: AllocationScalarWhereInput | AllocationScalarWhereInput[]
  }

  export type ProductVariantCreateNestedOneWithoutInventoryUnitsInput = {
    create?: XOR<ProductVariantCreateWithoutInventoryUnitsInput, ProductVariantUncheckedCreateWithoutInventoryUnitsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutInventoryUnitsInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutInventoryUnitsInput = {
    create?: XOR<LocationCreateWithoutInventoryUnitsInput, LocationUncheckedCreateWithoutInventoryUnitsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutInventoryUnitsInput
    connect?: LocationWhereUniqueInput
  }

  export type AllocationCreateNestedManyWithoutInventoryUnitInput = {
    create?: XOR<AllocationCreateWithoutInventoryUnitInput, AllocationUncheckedCreateWithoutInventoryUnitInput> | AllocationCreateWithoutInventoryUnitInput[] | AllocationUncheckedCreateWithoutInventoryUnitInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutInventoryUnitInput | AllocationCreateOrConnectWithoutInventoryUnitInput[]
    createMany?: AllocationCreateManyInventoryUnitInputEnvelope
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
  }

  export type AllocationUncheckedCreateNestedManyWithoutInventoryUnitInput = {
    create?: XOR<AllocationCreateWithoutInventoryUnitInput, AllocationUncheckedCreateWithoutInventoryUnitInput> | AllocationCreateWithoutInventoryUnitInput[] | AllocationUncheckedCreateWithoutInventoryUnitInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutInventoryUnitInput | AllocationCreateOrConnectWithoutInventoryUnitInput[]
    createMany?: AllocationCreateManyInventoryUnitInputEnvelope
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumInventoryStatusFieldUpdateOperationsInput = {
    set?: $Enums.InventoryStatus
  }

  export type ProductVariantUpdateOneRequiredWithoutInventoryUnitsNestedInput = {
    create?: XOR<ProductVariantCreateWithoutInventoryUnitsInput, ProductVariantUncheckedCreateWithoutInventoryUnitsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutInventoryUnitsInput
    upsert?: ProductVariantUpsertWithoutInventoryUnitsInput
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<XOR<ProductVariantUpdateToOneWithWhereWithoutInventoryUnitsInput, ProductVariantUpdateWithoutInventoryUnitsInput>, ProductVariantUncheckedUpdateWithoutInventoryUnitsInput>
  }

  export type LocationUpdateOneRequiredWithoutInventoryUnitsNestedInput = {
    create?: XOR<LocationCreateWithoutInventoryUnitsInput, LocationUncheckedCreateWithoutInventoryUnitsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutInventoryUnitsInput
    upsert?: LocationUpsertWithoutInventoryUnitsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutInventoryUnitsInput, LocationUpdateWithoutInventoryUnitsInput>, LocationUncheckedUpdateWithoutInventoryUnitsInput>
  }

  export type AllocationUpdateManyWithoutInventoryUnitNestedInput = {
    create?: XOR<AllocationCreateWithoutInventoryUnitInput, AllocationUncheckedCreateWithoutInventoryUnitInput> | AllocationCreateWithoutInventoryUnitInput[] | AllocationUncheckedCreateWithoutInventoryUnitInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutInventoryUnitInput | AllocationCreateOrConnectWithoutInventoryUnitInput[]
    upsert?: AllocationUpsertWithWhereUniqueWithoutInventoryUnitInput | AllocationUpsertWithWhereUniqueWithoutInventoryUnitInput[]
    createMany?: AllocationCreateManyInventoryUnitInputEnvelope
    set?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    disconnect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    delete?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    update?: AllocationUpdateWithWhereUniqueWithoutInventoryUnitInput | AllocationUpdateWithWhereUniqueWithoutInventoryUnitInput[]
    updateMany?: AllocationUpdateManyWithWhereWithoutInventoryUnitInput | AllocationUpdateManyWithWhereWithoutInventoryUnitInput[]
    deleteMany?: AllocationScalarWhereInput | AllocationScalarWhereInput[]
  }

  export type AllocationUncheckedUpdateManyWithoutInventoryUnitNestedInput = {
    create?: XOR<AllocationCreateWithoutInventoryUnitInput, AllocationUncheckedCreateWithoutInventoryUnitInput> | AllocationCreateWithoutInventoryUnitInput[] | AllocationUncheckedCreateWithoutInventoryUnitInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutInventoryUnitInput | AllocationCreateOrConnectWithoutInventoryUnitInput[]
    upsert?: AllocationUpsertWithWhereUniqueWithoutInventoryUnitInput | AllocationUpsertWithWhereUniqueWithoutInventoryUnitInput[]
    createMany?: AllocationCreateManyInventoryUnitInputEnvelope
    set?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    disconnect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    delete?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    update?: AllocationUpdateWithWhereUniqueWithoutInventoryUnitInput | AllocationUpdateWithWhereUniqueWithoutInventoryUnitInput[]
    updateMany?: AllocationUpdateManyWithWhereWithoutInventoryUnitInput | AllocationUpdateManyWithWhereWithoutInventoryUnitInput[]
    deleteMany?: AllocationScalarWhereInput | AllocationScalarWhereInput[]
  }

  export type InventoryUnitCreateNestedOneWithoutAllocationsInput = {
    create?: XOR<InventoryUnitCreateWithoutAllocationsInput, InventoryUnitUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: InventoryUnitCreateOrConnectWithoutAllocationsInput
    connect?: InventoryUnitWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutAllocationsInput = {
    create?: XOR<OrderCreateWithoutAllocationsInput, OrderUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutAllocationsInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderItemCreateNestedOneWithoutAllocationsInput = {
    create?: XOR<OrderItemCreateWithoutAllocationsInput, OrderItemUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutAllocationsInput
    connect?: OrderItemWhereUniqueInput
  }

  export type ProductVariantCreateNestedOneWithoutAllocationsInput = {
    create?: XOR<ProductVariantCreateWithoutAllocationsInput, ProductVariantUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutAllocationsInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutAllocationsInput = {
    create?: XOR<LocationCreateWithoutAllocationsInput, LocationUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutAllocationsInput
    connect?: LocationWhereUniqueInput
  }

  export type TaskItemCreateNestedOneWithoutAllocationInput = {
    create?: XOR<TaskItemCreateWithoutAllocationInput, TaskItemUncheckedCreateWithoutAllocationInput>
    connectOrCreate?: TaskItemCreateOrConnectWithoutAllocationInput
    connect?: TaskItemWhereUniqueInput
  }

  export type EnumAllocationStatusFieldUpdateOperationsInput = {
    set?: $Enums.AllocationStatus
  }

  export type InventoryUnitUpdateOneRequiredWithoutAllocationsNestedInput = {
    create?: XOR<InventoryUnitCreateWithoutAllocationsInput, InventoryUnitUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: InventoryUnitCreateOrConnectWithoutAllocationsInput
    upsert?: InventoryUnitUpsertWithoutAllocationsInput
    connect?: InventoryUnitWhereUniqueInput
    update?: XOR<XOR<InventoryUnitUpdateToOneWithWhereWithoutAllocationsInput, InventoryUnitUpdateWithoutAllocationsInput>, InventoryUnitUncheckedUpdateWithoutAllocationsInput>
  }

  export type OrderUpdateOneRequiredWithoutAllocationsNestedInput = {
    create?: XOR<OrderCreateWithoutAllocationsInput, OrderUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutAllocationsInput
    upsert?: OrderUpsertWithoutAllocationsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutAllocationsInput, OrderUpdateWithoutAllocationsInput>, OrderUncheckedUpdateWithoutAllocationsInput>
  }

  export type OrderItemUpdateOneWithoutAllocationsNestedInput = {
    create?: XOR<OrderItemCreateWithoutAllocationsInput, OrderItemUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutAllocationsInput
    upsert?: OrderItemUpsertWithoutAllocationsInput
    disconnect?: OrderItemWhereInput | boolean
    delete?: OrderItemWhereInput | boolean
    connect?: OrderItemWhereUniqueInput
    update?: XOR<XOR<OrderItemUpdateToOneWithWhereWithoutAllocationsInput, OrderItemUpdateWithoutAllocationsInput>, OrderItemUncheckedUpdateWithoutAllocationsInput>
  }

  export type ProductVariantUpdateOneRequiredWithoutAllocationsNestedInput = {
    create?: XOR<ProductVariantCreateWithoutAllocationsInput, ProductVariantUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutAllocationsInput
    upsert?: ProductVariantUpsertWithoutAllocationsInput
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<XOR<ProductVariantUpdateToOneWithWhereWithoutAllocationsInput, ProductVariantUpdateWithoutAllocationsInput>, ProductVariantUncheckedUpdateWithoutAllocationsInput>
  }

  export type LocationUpdateOneRequiredWithoutAllocationsNestedInput = {
    create?: XOR<LocationCreateWithoutAllocationsInput, LocationUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutAllocationsInput
    upsert?: LocationUpsertWithoutAllocationsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutAllocationsInput, LocationUpdateWithoutAllocationsInput>, LocationUncheckedUpdateWithoutAllocationsInput>
  }

  export type TaskItemUpdateOneWithoutAllocationNestedInput = {
    create?: XOR<TaskItemCreateWithoutAllocationInput, TaskItemUncheckedCreateWithoutAllocationInput>
    connectOrCreate?: TaskItemCreateOrConnectWithoutAllocationInput
    upsert?: TaskItemUpsertWithoutAllocationInput
    disconnect?: TaskItemWhereInput | boolean
    delete?: TaskItemWhereInput | boolean
    connect?: TaskItemWhereUniqueInput
    update?: XOR<XOR<TaskItemUpdateToOneWithWhereWithoutAllocationInput, TaskItemUpdateWithoutAllocationInput>, TaskItemUncheckedUpdateWithoutAllocationInput>
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type TaskItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<TaskItemCreateWithoutOrderInput, TaskItemUncheckedCreateWithoutOrderInput> | TaskItemCreateWithoutOrderInput[] | TaskItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutOrderInput | TaskItemCreateOrConnectWithoutOrderInput[]
    createMany?: TaskItemCreateManyOrderInputEnvelope
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
  }

  export type AllocationCreateNestedManyWithoutOrderInput = {
    create?: XOR<AllocationCreateWithoutOrderInput, AllocationUncheckedCreateWithoutOrderInput> | AllocationCreateWithoutOrderInput[] | AllocationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutOrderInput | AllocationCreateOrConnectWithoutOrderInput[]
    createMany?: AllocationCreateManyOrderInputEnvelope
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type TaskItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<TaskItemCreateWithoutOrderInput, TaskItemUncheckedCreateWithoutOrderInput> | TaskItemCreateWithoutOrderInput[] | TaskItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutOrderInput | TaskItemCreateOrConnectWithoutOrderInput[]
    createMany?: TaskItemCreateManyOrderInputEnvelope
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
  }

  export type AllocationUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<AllocationCreateWithoutOrderInput, AllocationUncheckedCreateWithoutOrderInput> | AllocationCreateWithoutOrderInput[] | AllocationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutOrderInput | AllocationCreateOrConnectWithoutOrderInput[]
    createMany?: AllocationCreateManyOrderInputEnvelope
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type TaskItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<TaskItemCreateWithoutOrderInput, TaskItemUncheckedCreateWithoutOrderInput> | TaskItemCreateWithoutOrderInput[] | TaskItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutOrderInput | TaskItemCreateOrConnectWithoutOrderInput[]
    upsert?: TaskItemUpsertWithWhereUniqueWithoutOrderInput | TaskItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: TaskItemCreateManyOrderInputEnvelope
    set?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    disconnect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    delete?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    update?: TaskItemUpdateWithWhereUniqueWithoutOrderInput | TaskItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: TaskItemUpdateManyWithWhereWithoutOrderInput | TaskItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: TaskItemScalarWhereInput | TaskItemScalarWhereInput[]
  }

  export type AllocationUpdateManyWithoutOrderNestedInput = {
    create?: XOR<AllocationCreateWithoutOrderInput, AllocationUncheckedCreateWithoutOrderInput> | AllocationCreateWithoutOrderInput[] | AllocationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutOrderInput | AllocationCreateOrConnectWithoutOrderInput[]
    upsert?: AllocationUpsertWithWhereUniqueWithoutOrderInput | AllocationUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: AllocationCreateManyOrderInputEnvelope
    set?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    disconnect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    delete?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    update?: AllocationUpdateWithWhereUniqueWithoutOrderInput | AllocationUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: AllocationUpdateManyWithWhereWithoutOrderInput | AllocationUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: AllocationScalarWhereInput | AllocationScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type TaskItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<TaskItemCreateWithoutOrderInput, TaskItemUncheckedCreateWithoutOrderInput> | TaskItemCreateWithoutOrderInput[] | TaskItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutOrderInput | TaskItemCreateOrConnectWithoutOrderInput[]
    upsert?: TaskItemUpsertWithWhereUniqueWithoutOrderInput | TaskItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: TaskItemCreateManyOrderInputEnvelope
    set?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    disconnect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    delete?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    update?: TaskItemUpdateWithWhereUniqueWithoutOrderInput | TaskItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: TaskItemUpdateManyWithWhereWithoutOrderInput | TaskItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: TaskItemScalarWhereInput | TaskItemScalarWhereInput[]
  }

  export type AllocationUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<AllocationCreateWithoutOrderInput, AllocationUncheckedCreateWithoutOrderInput> | AllocationCreateWithoutOrderInput[] | AllocationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutOrderInput | AllocationCreateOrConnectWithoutOrderInput[]
    upsert?: AllocationUpsertWithWhereUniqueWithoutOrderInput | AllocationUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: AllocationCreateManyOrderInputEnvelope
    set?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    disconnect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    delete?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    update?: AllocationUpdateWithWhereUniqueWithoutOrderInput | AllocationUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: AllocationUpdateManyWithWhereWithoutOrderInput | AllocationUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: AllocationScalarWhereInput | AllocationScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductVariantCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductVariantCreateWithoutOrderItemsInput, ProductVariantUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutOrderItemsInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type TaskItemCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<TaskItemCreateWithoutOrderItemInput, TaskItemUncheckedCreateWithoutOrderItemInput> | TaskItemCreateWithoutOrderItemInput[] | TaskItemUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutOrderItemInput | TaskItemCreateOrConnectWithoutOrderItemInput[]
    createMany?: TaskItemCreateManyOrderItemInputEnvelope
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
  }

  export type AllocationCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<AllocationCreateWithoutOrderItemInput, AllocationUncheckedCreateWithoutOrderItemInput> | AllocationCreateWithoutOrderItemInput[] | AllocationUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutOrderItemInput | AllocationCreateOrConnectWithoutOrderItemInput[]
    createMany?: AllocationCreateManyOrderItemInputEnvelope
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
  }

  export type TaskItemUncheckedCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<TaskItemCreateWithoutOrderItemInput, TaskItemUncheckedCreateWithoutOrderItemInput> | TaskItemCreateWithoutOrderItemInput[] | TaskItemUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutOrderItemInput | TaskItemCreateOrConnectWithoutOrderItemInput[]
    createMany?: TaskItemCreateManyOrderItemInputEnvelope
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
  }

  export type AllocationUncheckedCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<AllocationCreateWithoutOrderItemInput, AllocationUncheckedCreateWithoutOrderItemInput> | AllocationCreateWithoutOrderItemInput[] | AllocationUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutOrderItemInput | AllocationCreateOrConnectWithoutOrderItemInput[]
    createMany?: AllocationCreateManyOrderItemInputEnvelope
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type ProductVariantUpdateOneWithoutOrderItemsNestedInput = {
    create?: XOR<ProductVariantCreateWithoutOrderItemsInput, ProductVariantUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductVariantUpsertWithoutOrderItemsInput
    disconnect?: ProductVariantWhereInput | boolean
    delete?: ProductVariantWhereInput | boolean
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<XOR<ProductVariantUpdateToOneWithWhereWithoutOrderItemsInput, ProductVariantUpdateWithoutOrderItemsInput>, ProductVariantUncheckedUpdateWithoutOrderItemsInput>
  }

  export type TaskItemUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<TaskItemCreateWithoutOrderItemInput, TaskItemUncheckedCreateWithoutOrderItemInput> | TaskItemCreateWithoutOrderItemInput[] | TaskItemUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutOrderItemInput | TaskItemCreateOrConnectWithoutOrderItemInput[]
    upsert?: TaskItemUpsertWithWhereUniqueWithoutOrderItemInput | TaskItemUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: TaskItemCreateManyOrderItemInputEnvelope
    set?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    disconnect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    delete?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    update?: TaskItemUpdateWithWhereUniqueWithoutOrderItemInput | TaskItemUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: TaskItemUpdateManyWithWhereWithoutOrderItemInput | TaskItemUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: TaskItemScalarWhereInput | TaskItemScalarWhereInput[]
  }

  export type AllocationUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<AllocationCreateWithoutOrderItemInput, AllocationUncheckedCreateWithoutOrderItemInput> | AllocationCreateWithoutOrderItemInput[] | AllocationUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutOrderItemInput | AllocationCreateOrConnectWithoutOrderItemInput[]
    upsert?: AllocationUpsertWithWhereUniqueWithoutOrderItemInput | AllocationUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: AllocationCreateManyOrderItemInputEnvelope
    set?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    disconnect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    delete?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    update?: AllocationUpdateWithWhereUniqueWithoutOrderItemInput | AllocationUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: AllocationUpdateManyWithWhereWithoutOrderItemInput | AllocationUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: AllocationScalarWhereInput | AllocationScalarWhereInput[]
  }

  export type TaskItemUncheckedUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<TaskItemCreateWithoutOrderItemInput, TaskItemUncheckedCreateWithoutOrderItemInput> | TaskItemCreateWithoutOrderItemInput[] | TaskItemUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutOrderItemInput | TaskItemCreateOrConnectWithoutOrderItemInput[]
    upsert?: TaskItemUpsertWithWhereUniqueWithoutOrderItemInput | TaskItemUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: TaskItemCreateManyOrderItemInputEnvelope
    set?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    disconnect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    delete?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    update?: TaskItemUpdateWithWhereUniqueWithoutOrderItemInput | TaskItemUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: TaskItemUpdateManyWithWhereWithoutOrderItemInput | TaskItemUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: TaskItemScalarWhereInput | TaskItemScalarWhereInput[]
  }

  export type AllocationUncheckedUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<AllocationCreateWithoutOrderItemInput, AllocationUncheckedCreateWithoutOrderItemInput> | AllocationCreateWithoutOrderItemInput[] | AllocationUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: AllocationCreateOrConnectWithoutOrderItemInput | AllocationCreateOrConnectWithoutOrderItemInput[]
    upsert?: AllocationUpsertWithWhereUniqueWithoutOrderItemInput | AllocationUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: AllocationCreateManyOrderItemInputEnvelope
    set?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    disconnect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    delete?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    connect?: AllocationWhereUniqueInput | AllocationWhereUniqueInput[]
    update?: AllocationUpdateWithWhereUniqueWithoutOrderItemInput | AllocationUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: AllocationUpdateManyWithWhereWithoutOrderItemInput | AllocationUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: AllocationScalarWhereInput | AllocationScalarWhereInput[]
  }

  export type WorkTaskCreateorderIdsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAssignedTasksInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput
    connect?: UserWhereUniqueInput
  }

  export type TaskItemCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskItemCreateWithoutTaskInput, TaskItemUncheckedCreateWithoutTaskInput> | TaskItemCreateWithoutTaskInput[] | TaskItemUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutTaskInput | TaskItemCreateOrConnectWithoutTaskInput[]
    createMany?: TaskItemCreateManyTaskInputEnvelope
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
  }

  export type TaskEventCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskEventCreateWithoutTaskInput, TaskEventUncheckedCreateWithoutTaskInput> | TaskEventCreateWithoutTaskInput[] | TaskEventUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskEventCreateOrConnectWithoutTaskInput | TaskEventCreateOrConnectWithoutTaskInput[]
    createMany?: TaskEventCreateManyTaskInputEnvelope
    connect?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
  }

  export type TaskItemUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskItemCreateWithoutTaskInput, TaskItemUncheckedCreateWithoutTaskInput> | TaskItemCreateWithoutTaskInput[] | TaskItemUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutTaskInput | TaskItemCreateOrConnectWithoutTaskInput[]
    createMany?: TaskItemCreateManyTaskInputEnvelope
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
  }

  export type TaskEventUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskEventCreateWithoutTaskInput, TaskEventUncheckedCreateWithoutTaskInput> | TaskEventCreateWithoutTaskInput[] | TaskEventUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskEventCreateOrConnectWithoutTaskInput | TaskEventCreateOrConnectWithoutTaskInput[]
    createMany?: TaskEventCreateManyTaskInputEnvelope
    connect?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
  }

  export type EnumWorkTaskTypeFieldUpdateOperationsInput = {
    set?: $Enums.WorkTaskType
  }

  export type EnumWorkTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkTaskStatus
  }

  export type NullableEnumWorkTaskBlockReasonFieldUpdateOperationsInput = {
    set?: $Enums.WorkTaskBlockReason | null
  }

  export type WorkTaskUpdateorderIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutAssignedTasksNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput
    upsert?: UserUpsertWithoutAssignedTasksInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedTasksInput, UserUpdateWithoutAssignedTasksInput>, UserUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type TaskItemUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskItemCreateWithoutTaskInput, TaskItemUncheckedCreateWithoutTaskInput> | TaskItemCreateWithoutTaskInput[] | TaskItemUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutTaskInput | TaskItemCreateOrConnectWithoutTaskInput[]
    upsert?: TaskItemUpsertWithWhereUniqueWithoutTaskInput | TaskItemUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskItemCreateManyTaskInputEnvelope
    set?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    disconnect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    delete?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    update?: TaskItemUpdateWithWhereUniqueWithoutTaskInput | TaskItemUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskItemUpdateManyWithWhereWithoutTaskInput | TaskItemUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskItemScalarWhereInput | TaskItemScalarWhereInput[]
  }

  export type TaskEventUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskEventCreateWithoutTaskInput, TaskEventUncheckedCreateWithoutTaskInput> | TaskEventCreateWithoutTaskInput[] | TaskEventUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskEventCreateOrConnectWithoutTaskInput | TaskEventCreateOrConnectWithoutTaskInput[]
    upsert?: TaskEventUpsertWithWhereUniqueWithoutTaskInput | TaskEventUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskEventCreateManyTaskInputEnvelope
    set?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    disconnect?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    delete?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    connect?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    update?: TaskEventUpdateWithWhereUniqueWithoutTaskInput | TaskEventUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskEventUpdateManyWithWhereWithoutTaskInput | TaskEventUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskEventScalarWhereInput | TaskEventScalarWhereInput[]
  }

  export type TaskItemUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskItemCreateWithoutTaskInput, TaskItemUncheckedCreateWithoutTaskInput> | TaskItemCreateWithoutTaskInput[] | TaskItemUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskItemCreateOrConnectWithoutTaskInput | TaskItemCreateOrConnectWithoutTaskInput[]
    upsert?: TaskItemUpsertWithWhereUniqueWithoutTaskInput | TaskItemUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskItemCreateManyTaskInputEnvelope
    set?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    disconnect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    delete?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    connect?: TaskItemWhereUniqueInput | TaskItemWhereUniqueInput[]
    update?: TaskItemUpdateWithWhereUniqueWithoutTaskInput | TaskItemUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskItemUpdateManyWithWhereWithoutTaskInput | TaskItemUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskItemScalarWhereInput | TaskItemScalarWhereInput[]
  }

  export type TaskEventUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskEventCreateWithoutTaskInput, TaskEventUncheckedCreateWithoutTaskInput> | TaskEventCreateWithoutTaskInput[] | TaskEventUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskEventCreateOrConnectWithoutTaskInput | TaskEventCreateOrConnectWithoutTaskInput[]
    upsert?: TaskEventUpsertWithWhereUniqueWithoutTaskInput | TaskEventUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskEventCreateManyTaskInputEnvelope
    set?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    disconnect?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    delete?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    connect?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    update?: TaskEventUpdateWithWhereUniqueWithoutTaskInput | TaskEventUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskEventUpdateManyWithWhereWithoutTaskInput | TaskEventUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskEventScalarWhereInput | TaskEventScalarWhereInput[]
  }

  export type WorkTaskCreateNestedOneWithoutTaskItemsInput = {
    create?: XOR<WorkTaskCreateWithoutTaskItemsInput, WorkTaskUncheckedCreateWithoutTaskItemsInput>
    connectOrCreate?: WorkTaskCreateOrConnectWithoutTaskItemsInput
    connect?: WorkTaskWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutTaskItemsInput = {
    create?: XOR<OrderCreateWithoutTaskItemsInput, OrderUncheckedCreateWithoutTaskItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutTaskItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderItemCreateNestedOneWithoutTaskItemsInput = {
    create?: XOR<OrderItemCreateWithoutTaskItemsInput, OrderItemUncheckedCreateWithoutTaskItemsInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutTaskItemsInput
    connect?: OrderItemWhereUniqueInput
  }

  export type ProductVariantCreateNestedOneWithoutTaskItemsInput = {
    create?: XOR<ProductVariantCreateWithoutTaskItemsInput, ProductVariantUncheckedCreateWithoutTaskItemsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutTaskItemsInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutTaskItemsInput = {
    create?: XOR<LocationCreateWithoutTaskItemsInput, LocationUncheckedCreateWithoutTaskItemsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutTaskItemsInput
    connect?: LocationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCompletedTaskItemsInput = {
    create?: XOR<UserCreateWithoutCompletedTaskItemsInput, UserUncheckedCreateWithoutCompletedTaskItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompletedTaskItemsInput
    connect?: UserWhereUniqueInput
  }

  export type AllocationCreateNestedOneWithoutTaskItemInput = {
    create?: XOR<AllocationCreateWithoutTaskItemInput, AllocationUncheckedCreateWithoutTaskItemInput>
    connectOrCreate?: AllocationCreateOrConnectWithoutTaskItemInput
    connect?: AllocationWhereUniqueInput
  }

  export type AllocationUncheckedCreateNestedOneWithoutTaskItemInput = {
    create?: XOR<AllocationCreateWithoutTaskItemInput, AllocationUncheckedCreateWithoutTaskItemInput>
    connectOrCreate?: AllocationCreateOrConnectWithoutTaskItemInput
    connect?: AllocationWhereUniqueInput
  }

  export type EnumWorkTaskItemStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkTaskItemStatus
  }

  export type WorkTaskUpdateOneRequiredWithoutTaskItemsNestedInput = {
    create?: XOR<WorkTaskCreateWithoutTaskItemsInput, WorkTaskUncheckedCreateWithoutTaskItemsInput>
    connectOrCreate?: WorkTaskCreateOrConnectWithoutTaskItemsInput
    upsert?: WorkTaskUpsertWithoutTaskItemsInput
    connect?: WorkTaskWhereUniqueInput
    update?: XOR<XOR<WorkTaskUpdateToOneWithWhereWithoutTaskItemsInput, WorkTaskUpdateWithoutTaskItemsInput>, WorkTaskUncheckedUpdateWithoutTaskItemsInput>
  }

  export type OrderUpdateOneRequiredWithoutTaskItemsNestedInput = {
    create?: XOR<OrderCreateWithoutTaskItemsInput, OrderUncheckedCreateWithoutTaskItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutTaskItemsInput
    upsert?: OrderUpsertWithoutTaskItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutTaskItemsInput, OrderUpdateWithoutTaskItemsInput>, OrderUncheckedUpdateWithoutTaskItemsInput>
  }

  export type OrderItemUpdateOneWithoutTaskItemsNestedInput = {
    create?: XOR<OrderItemCreateWithoutTaskItemsInput, OrderItemUncheckedCreateWithoutTaskItemsInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutTaskItemsInput
    upsert?: OrderItemUpsertWithoutTaskItemsInput
    disconnect?: OrderItemWhereInput | boolean
    delete?: OrderItemWhereInput | boolean
    connect?: OrderItemWhereUniqueInput
    update?: XOR<XOR<OrderItemUpdateToOneWithWhereWithoutTaskItemsInput, OrderItemUpdateWithoutTaskItemsInput>, OrderItemUncheckedUpdateWithoutTaskItemsInput>
  }

  export type ProductVariantUpdateOneWithoutTaskItemsNestedInput = {
    create?: XOR<ProductVariantCreateWithoutTaskItemsInput, ProductVariantUncheckedCreateWithoutTaskItemsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutTaskItemsInput
    upsert?: ProductVariantUpsertWithoutTaskItemsInput
    disconnect?: ProductVariantWhereInput | boolean
    delete?: ProductVariantWhereInput | boolean
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<XOR<ProductVariantUpdateToOneWithWhereWithoutTaskItemsInput, ProductVariantUpdateWithoutTaskItemsInput>, ProductVariantUncheckedUpdateWithoutTaskItemsInput>
  }

  export type LocationUpdateOneWithoutTaskItemsNestedInput = {
    create?: XOR<LocationCreateWithoutTaskItemsInput, LocationUncheckedCreateWithoutTaskItemsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutTaskItemsInput
    upsert?: LocationUpsertWithoutTaskItemsInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutTaskItemsInput, LocationUpdateWithoutTaskItemsInput>, LocationUncheckedUpdateWithoutTaskItemsInput>
  }

  export type UserUpdateOneWithoutCompletedTaskItemsNestedInput = {
    create?: XOR<UserCreateWithoutCompletedTaskItemsInput, UserUncheckedCreateWithoutCompletedTaskItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompletedTaskItemsInput
    upsert?: UserUpsertWithoutCompletedTaskItemsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCompletedTaskItemsInput, UserUpdateWithoutCompletedTaskItemsInput>, UserUncheckedUpdateWithoutCompletedTaskItemsInput>
  }

  export type AllocationUpdateOneWithoutTaskItemNestedInput = {
    create?: XOR<AllocationCreateWithoutTaskItemInput, AllocationUncheckedCreateWithoutTaskItemInput>
    connectOrCreate?: AllocationCreateOrConnectWithoutTaskItemInput
    upsert?: AllocationUpsertWithoutTaskItemInput
    disconnect?: AllocationWhereInput | boolean
    delete?: AllocationWhereInput | boolean
    connect?: AllocationWhereUniqueInput
    update?: XOR<XOR<AllocationUpdateToOneWithWhereWithoutTaskItemInput, AllocationUpdateWithoutTaskItemInput>, AllocationUncheckedUpdateWithoutTaskItemInput>
  }

  export type AllocationUncheckedUpdateOneWithoutTaskItemNestedInput = {
    create?: XOR<AllocationCreateWithoutTaskItemInput, AllocationUncheckedCreateWithoutTaskItemInput>
    connectOrCreate?: AllocationCreateOrConnectWithoutTaskItemInput
    upsert?: AllocationUpsertWithoutTaskItemInput
    disconnect?: AllocationWhereInput | boolean
    delete?: AllocationWhereInput | boolean
    connect?: AllocationWhereUniqueInput
    update?: XOR<XOR<AllocationUpdateToOneWithWhereWithoutTaskItemInput, AllocationUpdateWithoutTaskItemInput>, AllocationUncheckedUpdateWithoutTaskItemInput>
  }

  export type WorkTaskCreateNestedOneWithoutEventsInput = {
    create?: XOR<WorkTaskCreateWithoutEventsInput, WorkTaskUncheckedCreateWithoutEventsInput>
    connectOrCreate?: WorkTaskCreateOrConnectWithoutEventsInput
    connect?: WorkTaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTaskEventsInput = {
    create?: XOR<UserCreateWithoutTaskEventsInput, UserUncheckedCreateWithoutTaskEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskEventsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumWorkTaskEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.WorkTaskEventType
  }

  export type WorkTaskUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<WorkTaskCreateWithoutEventsInput, WorkTaskUncheckedCreateWithoutEventsInput>
    connectOrCreate?: WorkTaskCreateOrConnectWithoutEventsInput
    upsert?: WorkTaskUpsertWithoutEventsInput
    connect?: WorkTaskWhereUniqueInput
    update?: XOR<XOR<WorkTaskUpdateToOneWithWhereWithoutEventsInput, WorkTaskUpdateWithoutEventsInput>, WorkTaskUncheckedUpdateWithoutEventsInput>
  }

  export type UserUpdateOneWithoutTaskEventsNestedInput = {
    create?: XOR<UserCreateWithoutTaskEventsInput, UserUncheckedCreateWithoutTaskEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskEventsInput
    upsert?: UserUpsertWithoutTaskEventsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaskEventsInput, UserUpdateWithoutTaskEventsInput>, UserUncheckedUpdateWithoutTaskEventsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumLocationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLocationTypeFilter<$PrismaModel> | $Enums.LocationType
  }

  export type NestedEnumLocationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLocationTypeWithAggregatesFilter<$PrismaModel> | $Enums.LocationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLocationTypeFilter<$PrismaModel>
    _max?: NestedEnumLocationTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumInventoryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryStatus | EnumInventoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryStatusFilter<$PrismaModel> | $Enums.InventoryStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumInventoryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryStatus | EnumInventoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryStatusWithAggregatesFilter<$PrismaModel> | $Enums.InventoryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInventoryStatusFilter<$PrismaModel>
    _max?: NestedEnumInventoryStatusFilter<$PrismaModel>
  }

  export type NestedEnumAllocationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AllocationStatus | EnumAllocationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AllocationStatus[] | ListEnumAllocationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AllocationStatus[] | ListEnumAllocationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAllocationStatusFilter<$PrismaModel> | $Enums.AllocationStatus
  }

  export type NestedEnumAllocationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AllocationStatus | EnumAllocationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AllocationStatus[] | ListEnumAllocationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AllocationStatus[] | ListEnumAllocationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAllocationStatusWithAggregatesFilter<$PrismaModel> | $Enums.AllocationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAllocationStatusFilter<$PrismaModel>
    _max?: NestedEnumAllocationStatusFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumWorkTaskTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTaskType | EnumWorkTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkTaskType[] | ListEnumWorkTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkTaskType[] | ListEnumWorkTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTaskTypeFilter<$PrismaModel> | $Enums.WorkTaskType
  }

  export type NestedEnumWorkTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTaskStatus | EnumWorkTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkTaskStatus[] | ListEnumWorkTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkTaskStatus[] | ListEnumWorkTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTaskStatusFilter<$PrismaModel> | $Enums.WorkTaskStatus
  }

  export type NestedEnumWorkTaskBlockReasonNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTaskBlockReason | EnumWorkTaskBlockReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.WorkTaskBlockReason[] | ListEnumWorkTaskBlockReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WorkTaskBlockReason[] | ListEnumWorkTaskBlockReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWorkTaskBlockReasonNullableFilter<$PrismaModel> | $Enums.WorkTaskBlockReason | null
  }

  export type NestedEnumWorkTaskTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTaskType | EnumWorkTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkTaskType[] | ListEnumWorkTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkTaskType[] | ListEnumWorkTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTaskTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkTaskType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkTaskTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkTaskTypeFilter<$PrismaModel>
  }

  export type NestedEnumWorkTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTaskStatus | EnumWorkTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkTaskStatus[] | ListEnumWorkTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkTaskStatus[] | ListEnumWorkTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkTaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkTaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumWorkTaskBlockReasonNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTaskBlockReason | EnumWorkTaskBlockReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.WorkTaskBlockReason[] | ListEnumWorkTaskBlockReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WorkTaskBlockReason[] | ListEnumWorkTaskBlockReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWorkTaskBlockReasonNullableWithAggregatesFilter<$PrismaModel> | $Enums.WorkTaskBlockReason | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumWorkTaskBlockReasonNullableFilter<$PrismaModel>
    _max?: NestedEnumWorkTaskBlockReasonNullableFilter<$PrismaModel>
  }

  export type NestedEnumWorkTaskItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTaskItemStatus | EnumWorkTaskItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkTaskItemStatus[] | ListEnumWorkTaskItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkTaskItemStatus[] | ListEnumWorkTaskItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTaskItemStatusFilter<$PrismaModel> | $Enums.WorkTaskItemStatus
  }

  export type NestedEnumWorkTaskItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTaskItemStatus | EnumWorkTaskItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkTaskItemStatus[] | ListEnumWorkTaskItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkTaskItemStatus[] | ListEnumWorkTaskItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTaskItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkTaskItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkTaskItemStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkTaskItemStatusFilter<$PrismaModel>
  }

  export type NestedEnumWorkTaskEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTaskEventType | EnumWorkTaskEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkTaskEventType[] | ListEnumWorkTaskEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkTaskEventType[] | ListEnumWorkTaskEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTaskEventTypeFilter<$PrismaModel> | $Enums.WorkTaskEventType
  }

  export type NestedEnumWorkTaskEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTaskEventType | EnumWorkTaskEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkTaskEventType[] | ListEnumWorkTaskEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkTaskEventType[] | ListEnumWorkTaskEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTaskEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkTaskEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkTaskEventTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkTaskEventTypeFilter<$PrismaModel>
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateManyUserInputEnvelope = {
    data: PasswordResetTokenCreateManyUserInput | PasswordResetTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkTaskCreateWithoutAssignedUserInput = {
    id?: string
    taskNumber: string
    type: $Enums.WorkTaskType
    status?: $Enums.WorkTaskStatus
    priority?: number
    idempotencyKey?: string | null
    assignedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    blockReason?: $Enums.WorkTaskBlockReason | null
    blockedAt?: Date | string | null
    orderIds?: WorkTaskCreateorderIdsInput | string[]
    totalOrders: number
    completedOrders?: number
    totalItems: number
    completedItems?: number
    shortItems?: number
    skippedItems?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    taskItems?: TaskItemCreateNestedManyWithoutTaskInput
    events?: TaskEventCreateNestedManyWithoutTaskInput
  }

  export type WorkTaskUncheckedCreateWithoutAssignedUserInput = {
    id?: string
    taskNumber: string
    type: $Enums.WorkTaskType
    status?: $Enums.WorkTaskStatus
    priority?: number
    idempotencyKey?: string | null
    assignedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    blockReason?: $Enums.WorkTaskBlockReason | null
    blockedAt?: Date | string | null
    orderIds?: WorkTaskCreateorderIdsInput | string[]
    totalOrders: number
    completedOrders?: number
    totalItems: number
    completedItems?: number
    shortItems?: number
    skippedItems?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    taskItems?: TaskItemUncheckedCreateNestedManyWithoutTaskInput
    events?: TaskEventUncheckedCreateNestedManyWithoutTaskInput
  }

  export type WorkTaskCreateOrConnectWithoutAssignedUserInput = {
    where: WorkTaskWhereUniqueInput
    create: XOR<WorkTaskCreateWithoutAssignedUserInput, WorkTaskUncheckedCreateWithoutAssignedUserInput>
  }

  export type WorkTaskCreateManyAssignedUserInputEnvelope = {
    data: WorkTaskCreateManyAssignedUserInput | WorkTaskCreateManyAssignedUserInput[]
    skipDuplicates?: boolean
  }

  export type TaskEventCreateWithoutUserInput = {
    id?: string
    eventType: $Enums.WorkTaskEventType
    taskItemId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    task: WorkTaskCreateNestedOneWithoutEventsInput
  }

  export type TaskEventUncheckedCreateWithoutUserInput = {
    id?: string
    taskId: string
    eventType: $Enums.WorkTaskEventType
    taskItemId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TaskEventCreateOrConnectWithoutUserInput = {
    where: TaskEventWhereUniqueInput
    create: XOR<TaskEventCreateWithoutUserInput, TaskEventUncheckedCreateWithoutUserInput>
  }

  export type TaskEventCreateManyUserInputEnvelope = {
    data: TaskEventCreateManyUserInput | TaskEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaskItemCreateWithoutCompletedByUserInput = {
    id?: string
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    task: WorkTaskCreateNestedOneWithoutTaskItemsInput
    order: OrderCreateNestedOneWithoutTaskItemsInput
    orderItem?: OrderItemCreateNestedOneWithoutTaskItemsInput
    productVariant?: ProductVariantCreateNestedOneWithoutTaskItemsInput
    location?: LocationCreateNestedOneWithoutTaskItemsInput
    allocation?: AllocationCreateNestedOneWithoutTaskItemInput
  }

  export type TaskItemUncheckedCreateWithoutCompletedByUserInput = {
    id?: string
    taskId: string
    orderId: string
    orderItemId?: string | null
    productVariantId?: string | null
    locationId?: string | null
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    allocation?: AllocationUncheckedCreateNestedOneWithoutTaskItemInput
  }

  export type TaskItemCreateOrConnectWithoutCompletedByUserInput = {
    where: TaskItemWhereUniqueInput
    create: XOR<TaskItemCreateWithoutCompletedByUserInput, TaskItemUncheckedCreateWithoutCompletedByUserInput>
  }

  export type TaskItemCreateManyCompletedByUserInputEnvelope = {
    data: TaskItemCreateManyCompletedByUserInput | TaskItemCreateManyCompletedByUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    correlationId?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    correlationId?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
  }

  export type PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetTokenScalarWhereInput
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetTokenScalarWhereInput = {
    AND?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    OR?: PasswordResetTokenScalarWhereInput[]
    NOT?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type WorkTaskUpsertWithWhereUniqueWithoutAssignedUserInput = {
    where: WorkTaskWhereUniqueInput
    update: XOR<WorkTaskUpdateWithoutAssignedUserInput, WorkTaskUncheckedUpdateWithoutAssignedUserInput>
    create: XOR<WorkTaskCreateWithoutAssignedUserInput, WorkTaskUncheckedCreateWithoutAssignedUserInput>
  }

  export type WorkTaskUpdateWithWhereUniqueWithoutAssignedUserInput = {
    where: WorkTaskWhereUniqueInput
    data: XOR<WorkTaskUpdateWithoutAssignedUserInput, WorkTaskUncheckedUpdateWithoutAssignedUserInput>
  }

  export type WorkTaskUpdateManyWithWhereWithoutAssignedUserInput = {
    where: WorkTaskScalarWhereInput
    data: XOR<WorkTaskUpdateManyMutationInput, WorkTaskUncheckedUpdateManyWithoutAssignedUserInput>
  }

  export type WorkTaskScalarWhereInput = {
    AND?: WorkTaskScalarWhereInput | WorkTaskScalarWhereInput[]
    OR?: WorkTaskScalarWhereInput[]
    NOT?: WorkTaskScalarWhereInput | WorkTaskScalarWhereInput[]
    id?: StringFilter<"WorkTask"> | string
    taskNumber?: StringFilter<"WorkTask"> | string
    type?: EnumWorkTaskTypeFilter<"WorkTask"> | $Enums.WorkTaskType
    status?: EnumWorkTaskStatusFilter<"WorkTask"> | $Enums.WorkTaskStatus
    priority?: IntFilter<"WorkTask"> | number
    idempotencyKey?: StringNullableFilter<"WorkTask"> | string | null
    assignedTo?: StringNullableFilter<"WorkTask"> | string | null
    assignedAt?: DateTimeNullableFilter<"WorkTask"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"WorkTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"WorkTask"> | Date | string | null
    blockReason?: EnumWorkTaskBlockReasonNullableFilter<"WorkTask"> | $Enums.WorkTaskBlockReason | null
    blockedAt?: DateTimeNullableFilter<"WorkTask"> | Date | string | null
    orderIds?: StringNullableListFilter<"WorkTask">
    totalOrders?: IntFilter<"WorkTask"> | number
    completedOrders?: IntFilter<"WorkTask"> | number
    totalItems?: IntFilter<"WorkTask"> | number
    completedItems?: IntFilter<"WorkTask"> | number
    shortItems?: IntFilter<"WorkTask"> | number
    skippedItems?: IntFilter<"WorkTask"> | number
    notes?: StringNullableFilter<"WorkTask"> | string | null
    createdAt?: DateTimeFilter<"WorkTask"> | Date | string
    updatedAt?: DateTimeFilter<"WorkTask"> | Date | string
  }

  export type TaskEventUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskEventWhereUniqueInput
    update: XOR<TaskEventUpdateWithoutUserInput, TaskEventUncheckedUpdateWithoutUserInput>
    create: XOR<TaskEventCreateWithoutUserInput, TaskEventUncheckedCreateWithoutUserInput>
  }

  export type TaskEventUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskEventWhereUniqueInput
    data: XOR<TaskEventUpdateWithoutUserInput, TaskEventUncheckedUpdateWithoutUserInput>
  }

  export type TaskEventUpdateManyWithWhereWithoutUserInput = {
    where: TaskEventScalarWhereInput
    data: XOR<TaskEventUpdateManyMutationInput, TaskEventUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskEventScalarWhereInput = {
    AND?: TaskEventScalarWhereInput | TaskEventScalarWhereInput[]
    OR?: TaskEventScalarWhereInput[]
    NOT?: TaskEventScalarWhereInput | TaskEventScalarWhereInput[]
    id?: StringFilter<"TaskEvent"> | string
    taskId?: StringFilter<"TaskEvent"> | string
    eventType?: EnumWorkTaskEventTypeFilter<"TaskEvent"> | $Enums.WorkTaskEventType
    userId?: StringNullableFilter<"TaskEvent"> | string | null
    taskItemId?: StringNullableFilter<"TaskEvent"> | string | null
    data?: JsonNullableFilter<"TaskEvent">
    createdAt?: DateTimeFilter<"TaskEvent"> | Date | string
  }

  export type TaskItemUpsertWithWhereUniqueWithoutCompletedByUserInput = {
    where: TaskItemWhereUniqueInput
    update: XOR<TaskItemUpdateWithoutCompletedByUserInput, TaskItemUncheckedUpdateWithoutCompletedByUserInput>
    create: XOR<TaskItemCreateWithoutCompletedByUserInput, TaskItemUncheckedCreateWithoutCompletedByUserInput>
  }

  export type TaskItemUpdateWithWhereUniqueWithoutCompletedByUserInput = {
    where: TaskItemWhereUniqueInput
    data: XOR<TaskItemUpdateWithoutCompletedByUserInput, TaskItemUncheckedUpdateWithoutCompletedByUserInput>
  }

  export type TaskItemUpdateManyWithWhereWithoutCompletedByUserInput = {
    where: TaskItemScalarWhereInput
    data: XOR<TaskItemUpdateManyMutationInput, TaskItemUncheckedUpdateManyWithoutCompletedByUserInput>
  }

  export type TaskItemScalarWhereInput = {
    AND?: TaskItemScalarWhereInput | TaskItemScalarWhereInput[]
    OR?: TaskItemScalarWhereInput[]
    NOT?: TaskItemScalarWhereInput | TaskItemScalarWhereInput[]
    id?: StringFilter<"TaskItem"> | string
    taskId?: StringFilter<"TaskItem"> | string
    orderId?: StringFilter<"TaskItem"> | string
    orderItemId?: StringNullableFilter<"TaskItem"> | string | null
    productVariantId?: StringNullableFilter<"TaskItem"> | string | null
    locationId?: StringNullableFilter<"TaskItem"> | string | null
    allocationId?: StringNullableFilter<"TaskItem"> | string | null
    sequence?: IntFilter<"TaskItem"> | number
    quantityRequired?: IntFilter<"TaskItem"> | number
    quantityCompleted?: IntFilter<"TaskItem"> | number
    status?: EnumWorkTaskItemStatusFilter<"TaskItem"> | $Enums.WorkTaskItemStatus
    completedBy?: StringNullableFilter<"TaskItem"> | string | null
    completedAt?: DateTimeNullableFilter<"TaskItem"> | Date | string | null
    shortReason?: StringNullableFilter<"TaskItem"> | string | null
    locationScanned?: BoolFilter<"TaskItem"> | boolean
    itemScanned?: BoolFilter<"TaskItem"> | boolean
    createdAt?: DateTimeFilter<"TaskItem"> | Date | string
    updatedAt?: DateTimeFilter<"TaskItem"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    correlationId?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    role?: $Enums.UserRole
    active?: boolean
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    assignedTasks?: WorkTaskCreateNestedManyWithoutAssignedUserInput
    taskEvents?: TaskEventCreateNestedManyWithoutUserInput
    completedTaskItems?: TaskItemCreateNestedManyWithoutCompletedByUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    role?: $Enums.UserRole
    active?: boolean
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: WorkTaskUncheckedCreateNestedManyWithoutAssignedUserInput
    taskEvents?: TaskEventUncheckedCreateNestedManyWithoutUserInput
    completedTaskItems?: TaskItemUncheckedCreateNestedManyWithoutCompletedByUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    assignedTasks?: WorkTaskUpdateManyWithoutAssignedUserNestedInput
    taskEvents?: TaskEventUpdateManyWithoutUserNestedInput
    completedTaskItems?: TaskItemUpdateManyWithoutCompletedByUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: WorkTaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    taskEvents?: TaskEventUncheckedUpdateManyWithoutUserNestedInput
    completedTaskItems?: TaskItemUncheckedUpdateManyWithoutCompletedByUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPasswordResetTokensInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    role?: $Enums.UserRole
    active?: boolean
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    assignedTasks?: WorkTaskCreateNestedManyWithoutAssignedUserInput
    taskEvents?: TaskEventCreateNestedManyWithoutUserInput
    completedTaskItems?: TaskItemCreateNestedManyWithoutCompletedByUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordResetTokensInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    role?: $Enums.UserRole
    active?: boolean
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: WorkTaskUncheckedCreateNestedManyWithoutAssignedUserInput
    taskEvents?: TaskEventUncheckedCreateNestedManyWithoutUserInput
    completedTaskItems?: TaskItemUncheckedCreateNestedManyWithoutCompletedByUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordResetTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
  }

  export type UserUpsertWithoutPasswordResetTokensInput = {
    update: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    assignedTasks?: WorkTaskUpdateManyWithoutAssignedUserNestedInput
    taskEvents?: TaskEventUpdateManyWithoutUserNestedInput
    completedTaskItems?: TaskItemUpdateManyWithoutCompletedByUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: WorkTaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    taskEvents?: TaskEventUncheckedUpdateManyWithoutUserNestedInput
    completedTaskItems?: TaskItemUncheckedUpdateManyWithoutCompletedByUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductVariantCreateWithoutProductInput = {
    id?: string
    sku: string
    upc?: string | null
    barcode?: string | null
    name: string
    imageUrl?: string | null
    shopifyVariantId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    sellingPrice?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    trackLots?: boolean
    trackExpiry?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductVariantInput
    inventoryUnits?: InventoryUnitCreateNestedManyWithoutProductVariantInput
    taskItems?: TaskItemCreateNestedManyWithoutProductVariantInput
    allocations?: AllocationCreateNestedManyWithoutProductVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutProductInput = {
    id?: string
    sku: string
    upc?: string | null
    barcode?: string | null
    name: string
    imageUrl?: string | null
    shopifyVariantId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    sellingPrice?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    trackLots?: boolean
    trackExpiry?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductVariantInput
    inventoryUnits?: InventoryUnitUncheckedCreateNestedManyWithoutProductVariantInput
    taskItems?: TaskItemUncheckedCreateNestedManyWithoutProductVariantInput
    allocations?: AllocationUncheckedCreateNestedManyWithoutProductVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>
  }

  export type ProductVariantCreateManyProductInputEnvelope = {
    data: ProductVariantCreateManyProductInput | ProductVariantCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductVariantUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    update: XOR<ProductVariantUpdateWithoutProductInput, ProductVariantUncheckedUpdateWithoutProductInput>
    create: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>
  }

  export type ProductVariantUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    data: XOR<ProductVariantUpdateWithoutProductInput, ProductVariantUncheckedUpdateWithoutProductInput>
  }

  export type ProductVariantUpdateManyWithWhereWithoutProductInput = {
    where: ProductVariantScalarWhereInput
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductVariantScalarWhereInput = {
    AND?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
    OR?: ProductVariantScalarWhereInput[]
    NOT?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
    id?: StringFilter<"ProductVariant"> | string
    productId?: StringFilter<"ProductVariant"> | string
    sku?: StringFilter<"ProductVariant"> | string
    upc?: StringNullableFilter<"ProductVariant"> | string | null
    barcode?: StringNullableFilter<"ProductVariant"> | string | null
    name?: StringFilter<"ProductVariant"> | string
    imageUrl?: StringNullableFilter<"ProductVariant"> | string | null
    shopifyVariantId?: StringNullableFilter<"ProductVariant"> | string | null
    costPrice?: DecimalNullableFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string | null
    sellingPrice?: DecimalNullableFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string | null
    weight?: DecimalNullableFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string | null
    trackLots?: BoolFilter<"ProductVariant"> | boolean
    trackExpiry?: BoolFilter<"ProductVariant"> | boolean
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
  }

  export type ProductCreateWithoutVariantsInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    brand?: string | null
    category?: string | null
    shopifyProductId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUncheckedCreateWithoutVariantsInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    brand?: string | null
    category?: string | null
    shopifyProductId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateOrConnectWithoutVariantsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
  }

  export type OrderItemCreateWithoutProductVariantInput = {
    id?: string
    sku: string
    quantity: number
    quantityAllocated?: number
    quantityPicked?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    matched?: boolean
    matchError?: string | null
    shopifyLineItemId?: string | null
    shopifyFulfillmentOrderLineItemId?: string | null
    order: OrderCreateNestedOneWithoutItemsInput
    taskItems?: TaskItemCreateNestedManyWithoutOrderItemInput
    allocations?: AllocationCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutProductVariantInput = {
    id?: string
    orderId: string
    sku: string
    quantity: number
    quantityAllocated?: number
    quantityPicked?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    matched?: boolean
    matchError?: string | null
    shopifyLineItemId?: string | null
    shopifyFulfillmentOrderLineItemId?: string | null
    taskItems?: TaskItemUncheckedCreateNestedManyWithoutOrderItemInput
    allocations?: AllocationUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutProductVariantInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductVariantInput, OrderItemUncheckedCreateWithoutProductVariantInput>
  }

  export type OrderItemCreateManyProductVariantInputEnvelope = {
    data: OrderItemCreateManyProductVariantInput | OrderItemCreateManyProductVariantInput[]
    skipDuplicates?: boolean
  }

  export type InventoryUnitCreateWithoutProductVariantInput = {
    id?: string
    quantity?: number
    status?: $Enums.InventoryStatus
    lotNumber?: string | null
    expiryDate?: Date | string | null
    receivedAt?: Date | string
    receivedFrom?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutInventoryUnitsInput
    allocations?: AllocationCreateNestedManyWithoutInventoryUnitInput
  }

  export type InventoryUnitUncheckedCreateWithoutProductVariantInput = {
    id?: string
    locationId: string
    quantity?: number
    status?: $Enums.InventoryStatus
    lotNumber?: string | null
    expiryDate?: Date | string | null
    receivedAt?: Date | string
    receivedFrom?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    allocations?: AllocationUncheckedCreateNestedManyWithoutInventoryUnitInput
  }

  export type InventoryUnitCreateOrConnectWithoutProductVariantInput = {
    where: InventoryUnitWhereUniqueInput
    create: XOR<InventoryUnitCreateWithoutProductVariantInput, InventoryUnitUncheckedCreateWithoutProductVariantInput>
  }

  export type InventoryUnitCreateManyProductVariantInputEnvelope = {
    data: InventoryUnitCreateManyProductVariantInput | InventoryUnitCreateManyProductVariantInput[]
    skipDuplicates?: boolean
  }

  export type TaskItemCreateWithoutProductVariantInput = {
    id?: string
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    task: WorkTaskCreateNestedOneWithoutTaskItemsInput
    order: OrderCreateNestedOneWithoutTaskItemsInput
    orderItem?: OrderItemCreateNestedOneWithoutTaskItemsInput
    location?: LocationCreateNestedOneWithoutTaskItemsInput
    completedByUser?: UserCreateNestedOneWithoutCompletedTaskItemsInput
    allocation?: AllocationCreateNestedOneWithoutTaskItemInput
  }

  export type TaskItemUncheckedCreateWithoutProductVariantInput = {
    id?: string
    taskId: string
    orderId: string
    orderItemId?: string | null
    locationId?: string | null
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedBy?: string | null
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    allocation?: AllocationUncheckedCreateNestedOneWithoutTaskItemInput
  }

  export type TaskItemCreateOrConnectWithoutProductVariantInput = {
    where: TaskItemWhereUniqueInput
    create: XOR<TaskItemCreateWithoutProductVariantInput, TaskItemUncheckedCreateWithoutProductVariantInput>
  }

  export type TaskItemCreateManyProductVariantInputEnvelope = {
    data: TaskItemCreateManyProductVariantInput | TaskItemCreateManyProductVariantInput[]
    skipDuplicates?: boolean
  }

  export type AllocationCreateWithoutProductVariantInput = {
    id?: string
    quantity: number
    lotNumber?: string | null
    status?: $Enums.AllocationStatus
    allocatedAt?: Date | string
    releasedAt?: Date | string | null
    pickedAt?: Date | string | null
    inventoryUnit: InventoryUnitCreateNestedOneWithoutAllocationsInput
    order: OrderCreateNestedOneWithoutAllocationsInput
    orderItem?: OrderItemCreateNestedOneWithoutAllocationsInput
    location: LocationCreateNestedOneWithoutAllocationsInput
    taskItem?: TaskItemCreateNestedOneWithoutAllocationInput
  }

  export type AllocationUncheckedCreateWithoutProductVariantInput = {
    id?: string
    inventoryUnitId: string
    orderId: string
    orderItemId?: string | null
    locationId: string
    quantity: number
    lotNumber?: string | null
    status?: $Enums.AllocationStatus
    allocatedAt?: Date | string
    releasedAt?: Date | string | null
    pickedAt?: Date | string | null
    taskItemId?: string | null
  }

  export type AllocationCreateOrConnectWithoutProductVariantInput = {
    where: AllocationWhereUniqueInput
    create: XOR<AllocationCreateWithoutProductVariantInput, AllocationUncheckedCreateWithoutProductVariantInput>
  }

  export type AllocationCreateManyProductVariantInputEnvelope = {
    data: AllocationCreateManyProductVariantInput | AllocationCreateManyProductVariantInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutVariantsInput = {
    update: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutVariantsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type ProductUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyProductId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyProductId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductVariantInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductVariantInput, OrderItemUncheckedUpdateWithoutProductVariantInput>
    create: XOR<OrderItemCreateWithoutProductVariantInput, OrderItemUncheckedCreateWithoutProductVariantInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductVariantInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductVariantInput, OrderItemUncheckedUpdateWithoutProductVariantInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductVariantInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductVariantInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productVariantId?: StringNullableFilter<"OrderItem"> | string | null
    sku?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    quantityAllocated?: IntFilter<"OrderItem"> | number
    quantityPicked?: IntFilter<"OrderItem"> | number
    unitPrice?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalNullableFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    matched?: BoolFilter<"OrderItem"> | boolean
    matchError?: StringNullableFilter<"OrderItem"> | string | null
    shopifyLineItemId?: StringNullableFilter<"OrderItem"> | string | null
    shopifyFulfillmentOrderLineItemId?: StringNullableFilter<"OrderItem"> | string | null
  }

  export type InventoryUnitUpsertWithWhereUniqueWithoutProductVariantInput = {
    where: InventoryUnitWhereUniqueInput
    update: XOR<InventoryUnitUpdateWithoutProductVariantInput, InventoryUnitUncheckedUpdateWithoutProductVariantInput>
    create: XOR<InventoryUnitCreateWithoutProductVariantInput, InventoryUnitUncheckedCreateWithoutProductVariantInput>
  }

  export type InventoryUnitUpdateWithWhereUniqueWithoutProductVariantInput = {
    where: InventoryUnitWhereUniqueInput
    data: XOR<InventoryUnitUpdateWithoutProductVariantInput, InventoryUnitUncheckedUpdateWithoutProductVariantInput>
  }

  export type InventoryUnitUpdateManyWithWhereWithoutProductVariantInput = {
    where: InventoryUnitScalarWhereInput
    data: XOR<InventoryUnitUpdateManyMutationInput, InventoryUnitUncheckedUpdateManyWithoutProductVariantInput>
  }

  export type InventoryUnitScalarWhereInput = {
    AND?: InventoryUnitScalarWhereInput | InventoryUnitScalarWhereInput[]
    OR?: InventoryUnitScalarWhereInput[]
    NOT?: InventoryUnitScalarWhereInput | InventoryUnitScalarWhereInput[]
    id?: StringFilter<"InventoryUnit"> | string
    productVariantId?: StringFilter<"InventoryUnit"> | string
    locationId?: StringFilter<"InventoryUnit"> | string
    quantity?: IntFilter<"InventoryUnit"> | number
    status?: EnumInventoryStatusFilter<"InventoryUnit"> | $Enums.InventoryStatus
    lotNumber?: StringNullableFilter<"InventoryUnit"> | string | null
    expiryDate?: DateTimeNullableFilter<"InventoryUnit"> | Date | string | null
    receivedAt?: DateTimeFilter<"InventoryUnit"> | Date | string
    receivedFrom?: StringNullableFilter<"InventoryUnit"> | string | null
    unitCost?: DecimalNullableFilter<"InventoryUnit"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"InventoryUnit"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryUnit"> | Date | string
  }

  export type TaskItemUpsertWithWhereUniqueWithoutProductVariantInput = {
    where: TaskItemWhereUniqueInput
    update: XOR<TaskItemUpdateWithoutProductVariantInput, TaskItemUncheckedUpdateWithoutProductVariantInput>
    create: XOR<TaskItemCreateWithoutProductVariantInput, TaskItemUncheckedCreateWithoutProductVariantInput>
  }

  export type TaskItemUpdateWithWhereUniqueWithoutProductVariantInput = {
    where: TaskItemWhereUniqueInput
    data: XOR<TaskItemUpdateWithoutProductVariantInput, TaskItemUncheckedUpdateWithoutProductVariantInput>
  }

  export type TaskItemUpdateManyWithWhereWithoutProductVariantInput = {
    where: TaskItemScalarWhereInput
    data: XOR<TaskItemUpdateManyMutationInput, TaskItemUncheckedUpdateManyWithoutProductVariantInput>
  }

  export type AllocationUpsertWithWhereUniqueWithoutProductVariantInput = {
    where: AllocationWhereUniqueInput
    update: XOR<AllocationUpdateWithoutProductVariantInput, AllocationUncheckedUpdateWithoutProductVariantInput>
    create: XOR<AllocationCreateWithoutProductVariantInput, AllocationUncheckedCreateWithoutProductVariantInput>
  }

  export type AllocationUpdateWithWhereUniqueWithoutProductVariantInput = {
    where: AllocationWhereUniqueInput
    data: XOR<AllocationUpdateWithoutProductVariantInput, AllocationUncheckedUpdateWithoutProductVariantInput>
  }

  export type AllocationUpdateManyWithWhereWithoutProductVariantInput = {
    where: AllocationScalarWhereInput
    data: XOR<AllocationUpdateManyMutationInput, AllocationUncheckedUpdateManyWithoutProductVariantInput>
  }

  export type AllocationScalarWhereInput = {
    AND?: AllocationScalarWhereInput | AllocationScalarWhereInput[]
    OR?: AllocationScalarWhereInput[]
    NOT?: AllocationScalarWhereInput | AllocationScalarWhereInput[]
    id?: StringFilter<"Allocation"> | string
    inventoryUnitId?: StringFilter<"Allocation"> | string
    orderId?: StringFilter<"Allocation"> | string
    orderItemId?: StringNullableFilter<"Allocation"> | string | null
    productVariantId?: StringFilter<"Allocation"> | string
    locationId?: StringFilter<"Allocation"> | string
    quantity?: IntFilter<"Allocation"> | number
    lotNumber?: StringNullableFilter<"Allocation"> | string | null
    status?: EnumAllocationStatusFilter<"Allocation"> | $Enums.AllocationStatus
    allocatedAt?: DateTimeFilter<"Allocation"> | Date | string
    releasedAt?: DateTimeNullableFilter<"Allocation"> | Date | string | null
    pickedAt?: DateTimeNullableFilter<"Allocation"> | Date | string | null
    taskItemId?: StringNullableFilter<"Allocation"> | string | null
  }

  export type InventoryUnitCreateWithoutLocationInput = {
    id?: string
    quantity?: number
    status?: $Enums.InventoryStatus
    lotNumber?: string | null
    expiryDate?: Date | string | null
    receivedAt?: Date | string
    receivedFrom?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productVariant: ProductVariantCreateNestedOneWithoutInventoryUnitsInput
    allocations?: AllocationCreateNestedManyWithoutInventoryUnitInput
  }

  export type InventoryUnitUncheckedCreateWithoutLocationInput = {
    id?: string
    productVariantId: string
    quantity?: number
    status?: $Enums.InventoryStatus
    lotNumber?: string | null
    expiryDate?: Date | string | null
    receivedAt?: Date | string
    receivedFrom?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    allocations?: AllocationUncheckedCreateNestedManyWithoutInventoryUnitInput
  }

  export type InventoryUnitCreateOrConnectWithoutLocationInput = {
    where: InventoryUnitWhereUniqueInput
    create: XOR<InventoryUnitCreateWithoutLocationInput, InventoryUnitUncheckedCreateWithoutLocationInput>
  }

  export type InventoryUnitCreateManyLocationInputEnvelope = {
    data: InventoryUnitCreateManyLocationInput | InventoryUnitCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type TaskItemCreateWithoutLocationInput = {
    id?: string
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    task: WorkTaskCreateNestedOneWithoutTaskItemsInput
    order: OrderCreateNestedOneWithoutTaskItemsInput
    orderItem?: OrderItemCreateNestedOneWithoutTaskItemsInput
    productVariant?: ProductVariantCreateNestedOneWithoutTaskItemsInput
    completedByUser?: UserCreateNestedOneWithoutCompletedTaskItemsInput
    allocation?: AllocationCreateNestedOneWithoutTaskItemInput
  }

  export type TaskItemUncheckedCreateWithoutLocationInput = {
    id?: string
    taskId: string
    orderId: string
    orderItemId?: string | null
    productVariantId?: string | null
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedBy?: string | null
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    allocation?: AllocationUncheckedCreateNestedOneWithoutTaskItemInput
  }

  export type TaskItemCreateOrConnectWithoutLocationInput = {
    where: TaskItemWhereUniqueInput
    create: XOR<TaskItemCreateWithoutLocationInput, TaskItemUncheckedCreateWithoutLocationInput>
  }

  export type TaskItemCreateManyLocationInputEnvelope = {
    data: TaskItemCreateManyLocationInput | TaskItemCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type AllocationCreateWithoutLocationInput = {
    id?: string
    quantity: number
    lotNumber?: string | null
    status?: $Enums.AllocationStatus
    allocatedAt?: Date | string
    releasedAt?: Date | string | null
    pickedAt?: Date | string | null
    inventoryUnit: InventoryUnitCreateNestedOneWithoutAllocationsInput
    order: OrderCreateNestedOneWithoutAllocationsInput
    orderItem?: OrderItemCreateNestedOneWithoutAllocationsInput
    productVariant: ProductVariantCreateNestedOneWithoutAllocationsInput
    taskItem?: TaskItemCreateNestedOneWithoutAllocationInput
  }

  export type AllocationUncheckedCreateWithoutLocationInput = {
    id?: string
    inventoryUnitId: string
    orderId: string
    orderItemId?: string | null
    productVariantId: string
    quantity: number
    lotNumber?: string | null
    status?: $Enums.AllocationStatus
    allocatedAt?: Date | string
    releasedAt?: Date | string | null
    pickedAt?: Date | string | null
    taskItemId?: string | null
  }

  export type AllocationCreateOrConnectWithoutLocationInput = {
    where: AllocationWhereUniqueInput
    create: XOR<AllocationCreateWithoutLocationInput, AllocationUncheckedCreateWithoutLocationInput>
  }

  export type AllocationCreateManyLocationInputEnvelope = {
    data: AllocationCreateManyLocationInput | AllocationCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type InventoryUnitUpsertWithWhereUniqueWithoutLocationInput = {
    where: InventoryUnitWhereUniqueInput
    update: XOR<InventoryUnitUpdateWithoutLocationInput, InventoryUnitUncheckedUpdateWithoutLocationInput>
    create: XOR<InventoryUnitCreateWithoutLocationInput, InventoryUnitUncheckedCreateWithoutLocationInput>
  }

  export type InventoryUnitUpdateWithWhereUniqueWithoutLocationInput = {
    where: InventoryUnitWhereUniqueInput
    data: XOR<InventoryUnitUpdateWithoutLocationInput, InventoryUnitUncheckedUpdateWithoutLocationInput>
  }

  export type InventoryUnitUpdateManyWithWhereWithoutLocationInput = {
    where: InventoryUnitScalarWhereInput
    data: XOR<InventoryUnitUpdateManyMutationInput, InventoryUnitUncheckedUpdateManyWithoutLocationInput>
  }

  export type TaskItemUpsertWithWhereUniqueWithoutLocationInput = {
    where: TaskItemWhereUniqueInput
    update: XOR<TaskItemUpdateWithoutLocationInput, TaskItemUncheckedUpdateWithoutLocationInput>
    create: XOR<TaskItemCreateWithoutLocationInput, TaskItemUncheckedCreateWithoutLocationInput>
  }

  export type TaskItemUpdateWithWhereUniqueWithoutLocationInput = {
    where: TaskItemWhereUniqueInput
    data: XOR<TaskItemUpdateWithoutLocationInput, TaskItemUncheckedUpdateWithoutLocationInput>
  }

  export type TaskItemUpdateManyWithWhereWithoutLocationInput = {
    where: TaskItemScalarWhereInput
    data: XOR<TaskItemUpdateManyMutationInput, TaskItemUncheckedUpdateManyWithoutLocationInput>
  }

  export type AllocationUpsertWithWhereUniqueWithoutLocationInput = {
    where: AllocationWhereUniqueInput
    update: XOR<AllocationUpdateWithoutLocationInput, AllocationUncheckedUpdateWithoutLocationInput>
    create: XOR<AllocationCreateWithoutLocationInput, AllocationUncheckedCreateWithoutLocationInput>
  }

  export type AllocationUpdateWithWhereUniqueWithoutLocationInput = {
    where: AllocationWhereUniqueInput
    data: XOR<AllocationUpdateWithoutLocationInput, AllocationUncheckedUpdateWithoutLocationInput>
  }

  export type AllocationUpdateManyWithWhereWithoutLocationInput = {
    where: AllocationScalarWhereInput
    data: XOR<AllocationUpdateManyMutationInput, AllocationUncheckedUpdateManyWithoutLocationInput>
  }

  export type ProductVariantCreateWithoutInventoryUnitsInput = {
    id?: string
    sku: string
    upc?: string | null
    barcode?: string | null
    name: string
    imageUrl?: string | null
    shopifyVariantId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    sellingPrice?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    trackLots?: boolean
    trackExpiry?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductVariantInput
    taskItems?: TaskItemCreateNestedManyWithoutProductVariantInput
    allocations?: AllocationCreateNestedManyWithoutProductVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutInventoryUnitsInput = {
    id?: string
    productId: string
    sku: string
    upc?: string | null
    barcode?: string | null
    name: string
    imageUrl?: string | null
    shopifyVariantId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    sellingPrice?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    trackLots?: boolean
    trackExpiry?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductVariantInput
    taskItems?: TaskItemUncheckedCreateNestedManyWithoutProductVariantInput
    allocations?: AllocationUncheckedCreateNestedManyWithoutProductVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutInventoryUnitsInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutInventoryUnitsInput, ProductVariantUncheckedCreateWithoutInventoryUnitsInput>
  }

  export type LocationCreateWithoutInventoryUnitsInput = {
    id?: string
    name: string
    barcode?: string | null
    type?: $Enums.LocationType
    zone?: string | null
    aisle?: string | null
    rack?: string | null
    shelf?: string | null
    bin?: string | null
    pickSequence?: number | null
    isPickable?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    taskItems?: TaskItemCreateNestedManyWithoutLocationInput
    allocations?: AllocationCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutInventoryUnitsInput = {
    id?: string
    name: string
    barcode?: string | null
    type?: $Enums.LocationType
    zone?: string | null
    aisle?: string | null
    rack?: string | null
    shelf?: string | null
    bin?: string | null
    pickSequence?: number | null
    isPickable?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    taskItems?: TaskItemUncheckedCreateNestedManyWithoutLocationInput
    allocations?: AllocationUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutInventoryUnitsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutInventoryUnitsInput, LocationUncheckedCreateWithoutInventoryUnitsInput>
  }

  export type AllocationCreateWithoutInventoryUnitInput = {
    id?: string
    quantity: number
    lotNumber?: string | null
    status?: $Enums.AllocationStatus
    allocatedAt?: Date | string
    releasedAt?: Date | string | null
    pickedAt?: Date | string | null
    order: OrderCreateNestedOneWithoutAllocationsInput
    orderItem?: OrderItemCreateNestedOneWithoutAllocationsInput
    productVariant: ProductVariantCreateNestedOneWithoutAllocationsInput
    location: LocationCreateNestedOneWithoutAllocationsInput
    taskItem?: TaskItemCreateNestedOneWithoutAllocationInput
  }

  export type AllocationUncheckedCreateWithoutInventoryUnitInput = {
    id?: string
    orderId: string
    orderItemId?: string | null
    productVariantId: string
    locationId: string
    quantity: number
    lotNumber?: string | null
    status?: $Enums.AllocationStatus
    allocatedAt?: Date | string
    releasedAt?: Date | string | null
    pickedAt?: Date | string | null
    taskItemId?: string | null
  }

  export type AllocationCreateOrConnectWithoutInventoryUnitInput = {
    where: AllocationWhereUniqueInput
    create: XOR<AllocationCreateWithoutInventoryUnitInput, AllocationUncheckedCreateWithoutInventoryUnitInput>
  }

  export type AllocationCreateManyInventoryUnitInputEnvelope = {
    data: AllocationCreateManyInventoryUnitInput | AllocationCreateManyInventoryUnitInput[]
    skipDuplicates?: boolean
  }

  export type ProductVariantUpsertWithoutInventoryUnitsInput = {
    update: XOR<ProductVariantUpdateWithoutInventoryUnitsInput, ProductVariantUncheckedUpdateWithoutInventoryUnitsInput>
    create: XOR<ProductVariantCreateWithoutInventoryUnitsInput, ProductVariantUncheckedCreateWithoutInventoryUnitsInput>
    where?: ProductVariantWhereInput
  }

  export type ProductVariantUpdateToOneWithWhereWithoutInventoryUnitsInput = {
    where?: ProductVariantWhereInput
    data: XOR<ProductVariantUpdateWithoutInventoryUnitsInput, ProductVariantUncheckedUpdateWithoutInventoryUnitsInput>
  }

  export type ProductVariantUpdateWithoutInventoryUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trackLots?: BoolFieldUpdateOperationsInput | boolean
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductVariantNestedInput
    taskItems?: TaskItemUpdateManyWithoutProductVariantNestedInput
    allocations?: AllocationUpdateManyWithoutProductVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutInventoryUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trackLots?: BoolFieldUpdateOperationsInput | boolean
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductVariantNestedInput
    taskItems?: TaskItemUncheckedUpdateManyWithoutProductVariantNestedInput
    allocations?: AllocationUncheckedUpdateManyWithoutProductVariantNestedInput
  }

  export type LocationUpsertWithoutInventoryUnitsInput = {
    update: XOR<LocationUpdateWithoutInventoryUnitsInput, LocationUncheckedUpdateWithoutInventoryUnitsInput>
    create: XOR<LocationCreateWithoutInventoryUnitsInput, LocationUncheckedCreateWithoutInventoryUnitsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutInventoryUnitsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutInventoryUnitsInput, LocationUncheckedUpdateWithoutInventoryUnitsInput>
  }

  export type LocationUpdateWithoutInventoryUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    zone?: NullableStringFieldUpdateOperationsInput | string | null
    aisle?: NullableStringFieldUpdateOperationsInput | string | null
    rack?: NullableStringFieldUpdateOperationsInput | string | null
    shelf?: NullableStringFieldUpdateOperationsInput | string | null
    bin?: NullableStringFieldUpdateOperationsInput | string | null
    pickSequence?: NullableIntFieldUpdateOperationsInput | number | null
    isPickable?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskItems?: TaskItemUpdateManyWithoutLocationNestedInput
    allocations?: AllocationUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutInventoryUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    zone?: NullableStringFieldUpdateOperationsInput | string | null
    aisle?: NullableStringFieldUpdateOperationsInput | string | null
    rack?: NullableStringFieldUpdateOperationsInput | string | null
    shelf?: NullableStringFieldUpdateOperationsInput | string | null
    bin?: NullableStringFieldUpdateOperationsInput | string | null
    pickSequence?: NullableIntFieldUpdateOperationsInput | number | null
    isPickable?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskItems?: TaskItemUncheckedUpdateManyWithoutLocationNestedInput
    allocations?: AllocationUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type AllocationUpsertWithWhereUniqueWithoutInventoryUnitInput = {
    where: AllocationWhereUniqueInput
    update: XOR<AllocationUpdateWithoutInventoryUnitInput, AllocationUncheckedUpdateWithoutInventoryUnitInput>
    create: XOR<AllocationCreateWithoutInventoryUnitInput, AllocationUncheckedCreateWithoutInventoryUnitInput>
  }

  export type AllocationUpdateWithWhereUniqueWithoutInventoryUnitInput = {
    where: AllocationWhereUniqueInput
    data: XOR<AllocationUpdateWithoutInventoryUnitInput, AllocationUncheckedUpdateWithoutInventoryUnitInput>
  }

  export type AllocationUpdateManyWithWhereWithoutInventoryUnitInput = {
    where: AllocationScalarWhereInput
    data: XOR<AllocationUpdateManyMutationInput, AllocationUncheckedUpdateManyWithoutInventoryUnitInput>
  }

  export type InventoryUnitCreateWithoutAllocationsInput = {
    id?: string
    quantity?: number
    status?: $Enums.InventoryStatus
    lotNumber?: string | null
    expiryDate?: Date | string | null
    receivedAt?: Date | string
    receivedFrom?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productVariant: ProductVariantCreateNestedOneWithoutInventoryUnitsInput
    location: LocationCreateNestedOneWithoutInventoryUnitsInput
  }

  export type InventoryUnitUncheckedCreateWithoutAllocationsInput = {
    id?: string
    productVariantId: string
    locationId: string
    quantity?: number
    status?: $Enums.InventoryStatus
    lotNumber?: string | null
    expiryDate?: Date | string | null
    receivedAt?: Date | string
    receivedFrom?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUnitCreateOrConnectWithoutAllocationsInput = {
    where: InventoryUnitWhereUniqueInput
    create: XOR<InventoryUnitCreateWithoutAllocationsInput, InventoryUnitUncheckedCreateWithoutAllocationsInput>
  }

  export type OrderCreateWithoutAllocationsInput = {
    id?: string
    orderNumber: string
    shopifyOrderId?: string | null
    customerId?: string | null
    customerName: string
    customerEmail?: string | null
    shippingAddress: JsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shopifyLineItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    priority?: $Enums.Priority
    holdReason?: string | null
    holdAt?: Date | string | null
    holdBy?: string | null
    unmatchedItems?: number
    totalAmount: Decimal | DecimalJsLike | number | string
    warehouseId?: string | null
    trackingNumber?: string | null
    shippedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemCreateNestedManyWithoutOrderInput
    taskItems?: TaskItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutAllocationsInput = {
    id?: string
    orderNumber: string
    shopifyOrderId?: string | null
    customerId?: string | null
    customerName: string
    customerEmail?: string | null
    shippingAddress: JsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shopifyLineItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    priority?: $Enums.Priority
    holdReason?: string | null
    holdAt?: Date | string | null
    holdBy?: string | null
    unmatchedItems?: number
    totalAmount: Decimal | DecimalJsLike | number | string
    warehouseId?: string | null
    trackingNumber?: string | null
    shippedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    taskItems?: TaskItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutAllocationsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutAllocationsInput, OrderUncheckedCreateWithoutAllocationsInput>
  }

  export type OrderItemCreateWithoutAllocationsInput = {
    id?: string
    sku: string
    quantity: number
    quantityAllocated?: number
    quantityPicked?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    matched?: boolean
    matchError?: string | null
    shopifyLineItemId?: string | null
    shopifyFulfillmentOrderLineItemId?: string | null
    order: OrderCreateNestedOneWithoutItemsInput
    productVariant?: ProductVariantCreateNestedOneWithoutOrderItemsInput
    taskItems?: TaskItemCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutAllocationsInput = {
    id?: string
    orderId: string
    productVariantId?: string | null
    sku: string
    quantity: number
    quantityAllocated?: number
    quantityPicked?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    matched?: boolean
    matchError?: string | null
    shopifyLineItemId?: string | null
    shopifyFulfillmentOrderLineItemId?: string | null
    taskItems?: TaskItemUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutAllocationsInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutAllocationsInput, OrderItemUncheckedCreateWithoutAllocationsInput>
  }

  export type ProductVariantCreateWithoutAllocationsInput = {
    id?: string
    sku: string
    upc?: string | null
    barcode?: string | null
    name: string
    imageUrl?: string | null
    shopifyVariantId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    sellingPrice?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    trackLots?: boolean
    trackExpiry?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductVariantInput
    inventoryUnits?: InventoryUnitCreateNestedManyWithoutProductVariantInput
    taskItems?: TaskItemCreateNestedManyWithoutProductVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutAllocationsInput = {
    id?: string
    productId: string
    sku: string
    upc?: string | null
    barcode?: string | null
    name: string
    imageUrl?: string | null
    shopifyVariantId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    sellingPrice?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    trackLots?: boolean
    trackExpiry?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductVariantInput
    inventoryUnits?: InventoryUnitUncheckedCreateNestedManyWithoutProductVariantInput
    taskItems?: TaskItemUncheckedCreateNestedManyWithoutProductVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutAllocationsInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutAllocationsInput, ProductVariantUncheckedCreateWithoutAllocationsInput>
  }

  export type LocationCreateWithoutAllocationsInput = {
    id?: string
    name: string
    barcode?: string | null
    type?: $Enums.LocationType
    zone?: string | null
    aisle?: string | null
    rack?: string | null
    shelf?: string | null
    bin?: string | null
    pickSequence?: number | null
    isPickable?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryUnits?: InventoryUnitCreateNestedManyWithoutLocationInput
    taskItems?: TaskItemCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutAllocationsInput = {
    id?: string
    name: string
    barcode?: string | null
    type?: $Enums.LocationType
    zone?: string | null
    aisle?: string | null
    rack?: string | null
    shelf?: string | null
    bin?: string | null
    pickSequence?: number | null
    isPickable?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryUnits?: InventoryUnitUncheckedCreateNestedManyWithoutLocationInput
    taskItems?: TaskItemUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutAllocationsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutAllocationsInput, LocationUncheckedCreateWithoutAllocationsInput>
  }

  export type TaskItemCreateWithoutAllocationInput = {
    id?: string
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    task: WorkTaskCreateNestedOneWithoutTaskItemsInput
    order: OrderCreateNestedOneWithoutTaskItemsInput
    orderItem?: OrderItemCreateNestedOneWithoutTaskItemsInput
    productVariant?: ProductVariantCreateNestedOneWithoutTaskItemsInput
    location?: LocationCreateNestedOneWithoutTaskItemsInput
    completedByUser?: UserCreateNestedOneWithoutCompletedTaskItemsInput
  }

  export type TaskItemUncheckedCreateWithoutAllocationInput = {
    id?: string
    taskId: string
    orderId: string
    orderItemId?: string | null
    productVariantId?: string | null
    locationId?: string | null
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedBy?: string | null
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskItemCreateOrConnectWithoutAllocationInput = {
    where: TaskItemWhereUniqueInput
    create: XOR<TaskItemCreateWithoutAllocationInput, TaskItemUncheckedCreateWithoutAllocationInput>
  }

  export type InventoryUnitUpsertWithoutAllocationsInput = {
    update: XOR<InventoryUnitUpdateWithoutAllocationsInput, InventoryUnitUncheckedUpdateWithoutAllocationsInput>
    create: XOR<InventoryUnitCreateWithoutAllocationsInput, InventoryUnitUncheckedCreateWithoutAllocationsInput>
    where?: InventoryUnitWhereInput
  }

  export type InventoryUnitUpdateToOneWithWhereWithoutAllocationsInput = {
    where?: InventoryUnitWhereInput
    data: XOR<InventoryUnitUpdateWithoutAllocationsInput, InventoryUnitUncheckedUpdateWithoutAllocationsInput>
  }

  export type InventoryUnitUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productVariant?: ProductVariantUpdateOneRequiredWithoutInventoryUnitsNestedInput
    location?: LocationUpdateOneRequiredWithoutInventoryUnitsNestedInput
  }

  export type InventoryUnitUncheckedUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productVariantId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpsertWithoutAllocationsInput = {
    update: XOR<OrderUpdateWithoutAllocationsInput, OrderUncheckedUpdateWithoutAllocationsInput>
    create: XOR<OrderCreateWithoutAllocationsInput, OrderUncheckedCreateWithoutAllocationsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutAllocationsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutAllocationsInput, OrderUncheckedUpdateWithoutAllocationsInput>
  }

  export type OrderUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    shopifyOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: JsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shopifyLineItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    holdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    holdBy?: NullableStringFieldUpdateOperationsInput | string | null
    unmatchedItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    taskItems?: TaskItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    shopifyOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: JsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shopifyLineItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    holdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    holdBy?: NullableStringFieldUpdateOperationsInput | string | null
    unmatchedItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    taskItems?: TaskItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderItemUpsertWithoutAllocationsInput = {
    update: XOR<OrderItemUpdateWithoutAllocationsInput, OrderItemUncheckedUpdateWithoutAllocationsInput>
    create: XOR<OrderItemCreateWithoutAllocationsInput, OrderItemUncheckedCreateWithoutAllocationsInput>
    where?: OrderItemWhereInput
  }

  export type OrderItemUpdateToOneWithWhereWithoutAllocationsInput = {
    where?: OrderItemWhereInput
    data: XOR<OrderItemUpdateWithoutAllocationsInput, OrderItemUncheckedUpdateWithoutAllocationsInput>
  }

  export type OrderItemUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quantityAllocated?: IntFieldUpdateOperationsInput | number
    quantityPicked?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchError?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyFulfillmentOrderLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    productVariant?: ProductVariantUpdateOneWithoutOrderItemsNestedInput
    taskItems?: TaskItemUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quantityAllocated?: IntFieldUpdateOperationsInput | number
    quantityPicked?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchError?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyFulfillmentOrderLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    taskItems?: TaskItemUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type ProductVariantUpsertWithoutAllocationsInput = {
    update: XOR<ProductVariantUpdateWithoutAllocationsInput, ProductVariantUncheckedUpdateWithoutAllocationsInput>
    create: XOR<ProductVariantCreateWithoutAllocationsInput, ProductVariantUncheckedCreateWithoutAllocationsInput>
    where?: ProductVariantWhereInput
  }

  export type ProductVariantUpdateToOneWithWhereWithoutAllocationsInput = {
    where?: ProductVariantWhereInput
    data: XOR<ProductVariantUpdateWithoutAllocationsInput, ProductVariantUncheckedUpdateWithoutAllocationsInput>
  }

  export type ProductVariantUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trackLots?: BoolFieldUpdateOperationsInput | boolean
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductVariantNestedInput
    inventoryUnits?: InventoryUnitUpdateManyWithoutProductVariantNestedInput
    taskItems?: TaskItemUpdateManyWithoutProductVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trackLots?: BoolFieldUpdateOperationsInput | boolean
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductVariantNestedInput
    inventoryUnits?: InventoryUnitUncheckedUpdateManyWithoutProductVariantNestedInput
    taskItems?: TaskItemUncheckedUpdateManyWithoutProductVariantNestedInput
  }

  export type LocationUpsertWithoutAllocationsInput = {
    update: XOR<LocationUpdateWithoutAllocationsInput, LocationUncheckedUpdateWithoutAllocationsInput>
    create: XOR<LocationCreateWithoutAllocationsInput, LocationUncheckedCreateWithoutAllocationsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutAllocationsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutAllocationsInput, LocationUncheckedUpdateWithoutAllocationsInput>
  }

  export type LocationUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    zone?: NullableStringFieldUpdateOperationsInput | string | null
    aisle?: NullableStringFieldUpdateOperationsInput | string | null
    rack?: NullableStringFieldUpdateOperationsInput | string | null
    shelf?: NullableStringFieldUpdateOperationsInput | string | null
    bin?: NullableStringFieldUpdateOperationsInput | string | null
    pickSequence?: NullableIntFieldUpdateOperationsInput | number | null
    isPickable?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryUnits?: InventoryUnitUpdateManyWithoutLocationNestedInput
    taskItems?: TaskItemUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    zone?: NullableStringFieldUpdateOperationsInput | string | null
    aisle?: NullableStringFieldUpdateOperationsInput | string | null
    rack?: NullableStringFieldUpdateOperationsInput | string | null
    shelf?: NullableStringFieldUpdateOperationsInput | string | null
    bin?: NullableStringFieldUpdateOperationsInput | string | null
    pickSequence?: NullableIntFieldUpdateOperationsInput | number | null
    isPickable?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryUnits?: InventoryUnitUncheckedUpdateManyWithoutLocationNestedInput
    taskItems?: TaskItemUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type TaskItemUpsertWithoutAllocationInput = {
    update: XOR<TaskItemUpdateWithoutAllocationInput, TaskItemUncheckedUpdateWithoutAllocationInput>
    create: XOR<TaskItemCreateWithoutAllocationInput, TaskItemUncheckedCreateWithoutAllocationInput>
    where?: TaskItemWhereInput
  }

  export type TaskItemUpdateToOneWithWhereWithoutAllocationInput = {
    where?: TaskItemWhereInput
    data: XOR<TaskItemUpdateWithoutAllocationInput, TaskItemUncheckedUpdateWithoutAllocationInput>
  }

  export type TaskItemUpdateWithoutAllocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: WorkTaskUpdateOneRequiredWithoutTaskItemsNestedInput
    order?: OrderUpdateOneRequiredWithoutTaskItemsNestedInput
    orderItem?: OrderItemUpdateOneWithoutTaskItemsNestedInput
    productVariant?: ProductVariantUpdateOneWithoutTaskItemsNestedInput
    location?: LocationUpdateOneWithoutTaskItemsNestedInput
    completedByUser?: UserUpdateOneWithoutCompletedTaskItemsNestedInput
  }

  export type TaskItemUncheckedUpdateWithoutAllocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    sku: string
    quantity: number
    quantityAllocated?: number
    quantityPicked?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    matched?: boolean
    matchError?: string | null
    shopifyLineItemId?: string | null
    shopifyFulfillmentOrderLineItemId?: string | null
    productVariant?: ProductVariantCreateNestedOneWithoutOrderItemsInput
    taskItems?: TaskItemCreateNestedManyWithoutOrderItemInput
    allocations?: AllocationCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    productVariantId?: string | null
    sku: string
    quantity: number
    quantityAllocated?: number
    quantityPicked?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    matched?: boolean
    matchError?: string | null
    shopifyLineItemId?: string | null
    shopifyFulfillmentOrderLineItemId?: string | null
    taskItems?: TaskItemUncheckedCreateNestedManyWithoutOrderItemInput
    allocations?: AllocationUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type TaskItemCreateWithoutOrderInput = {
    id?: string
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    task: WorkTaskCreateNestedOneWithoutTaskItemsInput
    orderItem?: OrderItemCreateNestedOneWithoutTaskItemsInput
    productVariant?: ProductVariantCreateNestedOneWithoutTaskItemsInput
    location?: LocationCreateNestedOneWithoutTaskItemsInput
    completedByUser?: UserCreateNestedOneWithoutCompletedTaskItemsInput
    allocation?: AllocationCreateNestedOneWithoutTaskItemInput
  }

  export type TaskItemUncheckedCreateWithoutOrderInput = {
    id?: string
    taskId: string
    orderItemId?: string | null
    productVariantId?: string | null
    locationId?: string | null
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedBy?: string | null
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    allocation?: AllocationUncheckedCreateNestedOneWithoutTaskItemInput
  }

  export type TaskItemCreateOrConnectWithoutOrderInput = {
    where: TaskItemWhereUniqueInput
    create: XOR<TaskItemCreateWithoutOrderInput, TaskItemUncheckedCreateWithoutOrderInput>
  }

  export type TaskItemCreateManyOrderInputEnvelope = {
    data: TaskItemCreateManyOrderInput | TaskItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type AllocationCreateWithoutOrderInput = {
    id?: string
    quantity: number
    lotNumber?: string | null
    status?: $Enums.AllocationStatus
    allocatedAt?: Date | string
    releasedAt?: Date | string | null
    pickedAt?: Date | string | null
    inventoryUnit: InventoryUnitCreateNestedOneWithoutAllocationsInput
    orderItem?: OrderItemCreateNestedOneWithoutAllocationsInput
    productVariant: ProductVariantCreateNestedOneWithoutAllocationsInput
    location: LocationCreateNestedOneWithoutAllocationsInput
    taskItem?: TaskItemCreateNestedOneWithoutAllocationInput
  }

  export type AllocationUncheckedCreateWithoutOrderInput = {
    id?: string
    inventoryUnitId: string
    orderItemId?: string | null
    productVariantId: string
    locationId: string
    quantity: number
    lotNumber?: string | null
    status?: $Enums.AllocationStatus
    allocatedAt?: Date | string
    releasedAt?: Date | string | null
    pickedAt?: Date | string | null
    taskItemId?: string | null
  }

  export type AllocationCreateOrConnectWithoutOrderInput = {
    where: AllocationWhereUniqueInput
    create: XOR<AllocationCreateWithoutOrderInput, AllocationUncheckedCreateWithoutOrderInput>
  }

  export type AllocationCreateManyOrderInputEnvelope = {
    data: AllocationCreateManyOrderInput | AllocationCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type TaskItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: TaskItemWhereUniqueInput
    update: XOR<TaskItemUpdateWithoutOrderInput, TaskItemUncheckedUpdateWithoutOrderInput>
    create: XOR<TaskItemCreateWithoutOrderInput, TaskItemUncheckedCreateWithoutOrderInput>
  }

  export type TaskItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: TaskItemWhereUniqueInput
    data: XOR<TaskItemUpdateWithoutOrderInput, TaskItemUncheckedUpdateWithoutOrderInput>
  }

  export type TaskItemUpdateManyWithWhereWithoutOrderInput = {
    where: TaskItemScalarWhereInput
    data: XOR<TaskItemUpdateManyMutationInput, TaskItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type AllocationUpsertWithWhereUniqueWithoutOrderInput = {
    where: AllocationWhereUniqueInput
    update: XOR<AllocationUpdateWithoutOrderInput, AllocationUncheckedUpdateWithoutOrderInput>
    create: XOR<AllocationCreateWithoutOrderInput, AllocationUncheckedCreateWithoutOrderInput>
  }

  export type AllocationUpdateWithWhereUniqueWithoutOrderInput = {
    where: AllocationWhereUniqueInput
    data: XOR<AllocationUpdateWithoutOrderInput, AllocationUncheckedUpdateWithoutOrderInput>
  }

  export type AllocationUpdateManyWithWhereWithoutOrderInput = {
    where: AllocationScalarWhereInput
    data: XOR<AllocationUpdateManyMutationInput, AllocationUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    shopifyOrderId?: string | null
    customerId?: string | null
    customerName: string
    customerEmail?: string | null
    shippingAddress: JsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shopifyLineItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    priority?: $Enums.Priority
    holdReason?: string | null
    holdAt?: Date | string | null
    holdBy?: string | null
    unmatchedItems?: number
    totalAmount: Decimal | DecimalJsLike | number | string
    warehouseId?: string | null
    trackingNumber?: string | null
    shippedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    taskItems?: TaskItemCreateNestedManyWithoutOrderInput
    allocations?: AllocationCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    shopifyOrderId?: string | null
    customerId?: string | null
    customerName: string
    customerEmail?: string | null
    shippingAddress: JsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shopifyLineItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    priority?: $Enums.Priority
    holdReason?: string | null
    holdAt?: Date | string | null
    holdBy?: string | null
    unmatchedItems?: number
    totalAmount: Decimal | DecimalJsLike | number | string
    warehouseId?: string | null
    trackingNumber?: string | null
    shippedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    taskItems?: TaskItemUncheckedCreateNestedManyWithoutOrderInput
    allocations?: AllocationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type ProductVariantCreateWithoutOrderItemsInput = {
    id?: string
    sku: string
    upc?: string | null
    barcode?: string | null
    name: string
    imageUrl?: string | null
    shopifyVariantId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    sellingPrice?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    trackLots?: boolean
    trackExpiry?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    inventoryUnits?: InventoryUnitCreateNestedManyWithoutProductVariantInput
    taskItems?: TaskItemCreateNestedManyWithoutProductVariantInput
    allocations?: AllocationCreateNestedManyWithoutProductVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    productId: string
    sku: string
    upc?: string | null
    barcode?: string | null
    name: string
    imageUrl?: string | null
    shopifyVariantId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    sellingPrice?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    trackLots?: boolean
    trackExpiry?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryUnits?: InventoryUnitUncheckedCreateNestedManyWithoutProductVariantInput
    taskItems?: TaskItemUncheckedCreateNestedManyWithoutProductVariantInput
    allocations?: AllocationUncheckedCreateNestedManyWithoutProductVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutOrderItemsInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutOrderItemsInput, ProductVariantUncheckedCreateWithoutOrderItemsInput>
  }

  export type TaskItemCreateWithoutOrderItemInput = {
    id?: string
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    task: WorkTaskCreateNestedOneWithoutTaskItemsInput
    order: OrderCreateNestedOneWithoutTaskItemsInput
    productVariant?: ProductVariantCreateNestedOneWithoutTaskItemsInput
    location?: LocationCreateNestedOneWithoutTaskItemsInput
    completedByUser?: UserCreateNestedOneWithoutCompletedTaskItemsInput
    allocation?: AllocationCreateNestedOneWithoutTaskItemInput
  }

  export type TaskItemUncheckedCreateWithoutOrderItemInput = {
    id?: string
    taskId: string
    orderId: string
    productVariantId?: string | null
    locationId?: string | null
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedBy?: string | null
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    allocation?: AllocationUncheckedCreateNestedOneWithoutTaskItemInput
  }

  export type TaskItemCreateOrConnectWithoutOrderItemInput = {
    where: TaskItemWhereUniqueInput
    create: XOR<TaskItemCreateWithoutOrderItemInput, TaskItemUncheckedCreateWithoutOrderItemInput>
  }

  export type TaskItemCreateManyOrderItemInputEnvelope = {
    data: TaskItemCreateManyOrderItemInput | TaskItemCreateManyOrderItemInput[]
    skipDuplicates?: boolean
  }

  export type AllocationCreateWithoutOrderItemInput = {
    id?: string
    quantity: number
    lotNumber?: string | null
    status?: $Enums.AllocationStatus
    allocatedAt?: Date | string
    releasedAt?: Date | string | null
    pickedAt?: Date | string | null
    inventoryUnit: InventoryUnitCreateNestedOneWithoutAllocationsInput
    order: OrderCreateNestedOneWithoutAllocationsInput
    productVariant: ProductVariantCreateNestedOneWithoutAllocationsInput
    location: LocationCreateNestedOneWithoutAllocationsInput
    taskItem?: TaskItemCreateNestedOneWithoutAllocationInput
  }

  export type AllocationUncheckedCreateWithoutOrderItemInput = {
    id?: string
    inventoryUnitId: string
    orderId: string
    productVariantId: string
    locationId: string
    quantity: number
    lotNumber?: string | null
    status?: $Enums.AllocationStatus
    allocatedAt?: Date | string
    releasedAt?: Date | string | null
    pickedAt?: Date | string | null
    taskItemId?: string | null
  }

  export type AllocationCreateOrConnectWithoutOrderItemInput = {
    where: AllocationWhereUniqueInput
    create: XOR<AllocationCreateWithoutOrderItemInput, AllocationUncheckedCreateWithoutOrderItemInput>
  }

  export type AllocationCreateManyOrderItemInputEnvelope = {
    data: AllocationCreateManyOrderItemInput | AllocationCreateManyOrderItemInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    shopifyOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: JsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shopifyLineItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    holdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    holdBy?: NullableStringFieldUpdateOperationsInput | string | null
    unmatchedItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskItems?: TaskItemUpdateManyWithoutOrderNestedInput
    allocations?: AllocationUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    shopifyOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: JsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shopifyLineItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    holdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    holdBy?: NullableStringFieldUpdateOperationsInput | string | null
    unmatchedItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskItems?: TaskItemUncheckedUpdateManyWithoutOrderNestedInput
    allocations?: AllocationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProductVariantUpsertWithoutOrderItemsInput = {
    update: XOR<ProductVariantUpdateWithoutOrderItemsInput, ProductVariantUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductVariantCreateWithoutOrderItemsInput, ProductVariantUncheckedCreateWithoutOrderItemsInput>
    where?: ProductVariantWhereInput
  }

  export type ProductVariantUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductVariantWhereInput
    data: XOR<ProductVariantUpdateWithoutOrderItemsInput, ProductVariantUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductVariantUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trackLots?: BoolFieldUpdateOperationsInput | boolean
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    inventoryUnits?: InventoryUnitUpdateManyWithoutProductVariantNestedInput
    taskItems?: TaskItemUpdateManyWithoutProductVariantNestedInput
    allocations?: AllocationUpdateManyWithoutProductVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trackLots?: BoolFieldUpdateOperationsInput | boolean
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryUnits?: InventoryUnitUncheckedUpdateManyWithoutProductVariantNestedInput
    taskItems?: TaskItemUncheckedUpdateManyWithoutProductVariantNestedInput
    allocations?: AllocationUncheckedUpdateManyWithoutProductVariantNestedInput
  }

  export type TaskItemUpsertWithWhereUniqueWithoutOrderItemInput = {
    where: TaskItemWhereUniqueInput
    update: XOR<TaskItemUpdateWithoutOrderItemInput, TaskItemUncheckedUpdateWithoutOrderItemInput>
    create: XOR<TaskItemCreateWithoutOrderItemInput, TaskItemUncheckedCreateWithoutOrderItemInput>
  }

  export type TaskItemUpdateWithWhereUniqueWithoutOrderItemInput = {
    where: TaskItemWhereUniqueInput
    data: XOR<TaskItemUpdateWithoutOrderItemInput, TaskItemUncheckedUpdateWithoutOrderItemInput>
  }

  export type TaskItemUpdateManyWithWhereWithoutOrderItemInput = {
    where: TaskItemScalarWhereInput
    data: XOR<TaskItemUpdateManyMutationInput, TaskItemUncheckedUpdateManyWithoutOrderItemInput>
  }

  export type AllocationUpsertWithWhereUniqueWithoutOrderItemInput = {
    where: AllocationWhereUniqueInput
    update: XOR<AllocationUpdateWithoutOrderItemInput, AllocationUncheckedUpdateWithoutOrderItemInput>
    create: XOR<AllocationCreateWithoutOrderItemInput, AllocationUncheckedCreateWithoutOrderItemInput>
  }

  export type AllocationUpdateWithWhereUniqueWithoutOrderItemInput = {
    where: AllocationWhereUniqueInput
    data: XOR<AllocationUpdateWithoutOrderItemInput, AllocationUncheckedUpdateWithoutOrderItemInput>
  }

  export type AllocationUpdateManyWithWhereWithoutOrderItemInput = {
    where: AllocationScalarWhereInput
    data: XOR<AllocationUpdateManyMutationInput, AllocationUncheckedUpdateManyWithoutOrderItemInput>
  }

  export type UserCreateWithoutAssignedTasksInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    role?: $Enums.UserRole
    active?: boolean
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    taskEvents?: TaskEventCreateNestedManyWithoutUserInput
    completedTaskItems?: TaskItemCreateNestedManyWithoutCompletedByUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedTasksInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    role?: $Enums.UserRole
    active?: boolean
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    taskEvents?: TaskEventUncheckedCreateNestedManyWithoutUserInput
    completedTaskItems?: TaskItemUncheckedCreateNestedManyWithoutCompletedByUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
  }

  export type TaskItemCreateWithoutTaskInput = {
    id?: string
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutTaskItemsInput
    orderItem?: OrderItemCreateNestedOneWithoutTaskItemsInput
    productVariant?: ProductVariantCreateNestedOneWithoutTaskItemsInput
    location?: LocationCreateNestedOneWithoutTaskItemsInput
    completedByUser?: UserCreateNestedOneWithoutCompletedTaskItemsInput
    allocation?: AllocationCreateNestedOneWithoutTaskItemInput
  }

  export type TaskItemUncheckedCreateWithoutTaskInput = {
    id?: string
    orderId: string
    orderItemId?: string | null
    productVariantId?: string | null
    locationId?: string | null
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedBy?: string | null
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    allocation?: AllocationUncheckedCreateNestedOneWithoutTaskItemInput
  }

  export type TaskItemCreateOrConnectWithoutTaskInput = {
    where: TaskItemWhereUniqueInput
    create: XOR<TaskItemCreateWithoutTaskInput, TaskItemUncheckedCreateWithoutTaskInput>
  }

  export type TaskItemCreateManyTaskInputEnvelope = {
    data: TaskItemCreateManyTaskInput | TaskItemCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskEventCreateWithoutTaskInput = {
    id?: string
    eventType: $Enums.WorkTaskEventType
    taskItemId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutTaskEventsInput
  }

  export type TaskEventUncheckedCreateWithoutTaskInput = {
    id?: string
    eventType: $Enums.WorkTaskEventType
    userId?: string | null
    taskItemId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TaskEventCreateOrConnectWithoutTaskInput = {
    where: TaskEventWhereUniqueInput
    create: XOR<TaskEventCreateWithoutTaskInput, TaskEventUncheckedCreateWithoutTaskInput>
  }

  export type TaskEventCreateManyTaskInputEnvelope = {
    data: TaskEventCreateManyTaskInput | TaskEventCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAssignedTasksInput = {
    update: XOR<UserUpdateWithoutAssignedTasksInput, UserUncheckedUpdateWithoutAssignedTasksInput>
    create: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedTasksInput, UserUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type UserUpdateWithoutAssignedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    taskEvents?: TaskEventUpdateManyWithoutUserNestedInput
    completedTaskItems?: TaskItemUpdateManyWithoutCompletedByUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    taskEvents?: TaskEventUncheckedUpdateManyWithoutUserNestedInput
    completedTaskItems?: TaskItemUncheckedUpdateManyWithoutCompletedByUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TaskItemUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskItemWhereUniqueInput
    update: XOR<TaskItemUpdateWithoutTaskInput, TaskItemUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskItemCreateWithoutTaskInput, TaskItemUncheckedCreateWithoutTaskInput>
  }

  export type TaskItemUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskItemWhereUniqueInput
    data: XOR<TaskItemUpdateWithoutTaskInput, TaskItemUncheckedUpdateWithoutTaskInput>
  }

  export type TaskItemUpdateManyWithWhereWithoutTaskInput = {
    where: TaskItemScalarWhereInput
    data: XOR<TaskItemUpdateManyMutationInput, TaskItemUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskEventUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskEventWhereUniqueInput
    update: XOR<TaskEventUpdateWithoutTaskInput, TaskEventUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskEventCreateWithoutTaskInput, TaskEventUncheckedCreateWithoutTaskInput>
  }

  export type TaskEventUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskEventWhereUniqueInput
    data: XOR<TaskEventUpdateWithoutTaskInput, TaskEventUncheckedUpdateWithoutTaskInput>
  }

  export type TaskEventUpdateManyWithWhereWithoutTaskInput = {
    where: TaskEventScalarWhereInput
    data: XOR<TaskEventUpdateManyMutationInput, TaskEventUncheckedUpdateManyWithoutTaskInput>
  }

  export type WorkTaskCreateWithoutTaskItemsInput = {
    id?: string
    taskNumber: string
    type: $Enums.WorkTaskType
    status?: $Enums.WorkTaskStatus
    priority?: number
    idempotencyKey?: string | null
    assignedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    blockReason?: $Enums.WorkTaskBlockReason | null
    blockedAt?: Date | string | null
    orderIds?: WorkTaskCreateorderIdsInput | string[]
    totalOrders: number
    completedOrders?: number
    totalItems: number
    completedItems?: number
    shortItems?: number
    skippedItems?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedUser?: UserCreateNestedOneWithoutAssignedTasksInput
    events?: TaskEventCreateNestedManyWithoutTaskInput
  }

  export type WorkTaskUncheckedCreateWithoutTaskItemsInput = {
    id?: string
    taskNumber: string
    type: $Enums.WorkTaskType
    status?: $Enums.WorkTaskStatus
    priority?: number
    idempotencyKey?: string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    blockReason?: $Enums.WorkTaskBlockReason | null
    blockedAt?: Date | string | null
    orderIds?: WorkTaskCreateorderIdsInput | string[]
    totalOrders: number
    completedOrders?: number
    totalItems: number
    completedItems?: number
    shortItems?: number
    skippedItems?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: TaskEventUncheckedCreateNestedManyWithoutTaskInput
  }

  export type WorkTaskCreateOrConnectWithoutTaskItemsInput = {
    where: WorkTaskWhereUniqueInput
    create: XOR<WorkTaskCreateWithoutTaskItemsInput, WorkTaskUncheckedCreateWithoutTaskItemsInput>
  }

  export type OrderCreateWithoutTaskItemsInput = {
    id?: string
    orderNumber: string
    shopifyOrderId?: string | null
    customerId?: string | null
    customerName: string
    customerEmail?: string | null
    shippingAddress: JsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shopifyLineItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    priority?: $Enums.Priority
    holdReason?: string | null
    holdAt?: Date | string | null
    holdBy?: string | null
    unmatchedItems?: number
    totalAmount: Decimal | DecimalJsLike | number | string
    warehouseId?: string | null
    trackingNumber?: string | null
    shippedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemCreateNestedManyWithoutOrderInput
    allocations?: AllocationCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutTaskItemsInput = {
    id?: string
    orderNumber: string
    shopifyOrderId?: string | null
    customerId?: string | null
    customerName: string
    customerEmail?: string | null
    shippingAddress: JsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shopifyLineItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    priority?: $Enums.Priority
    holdReason?: string | null
    holdAt?: Date | string | null
    holdBy?: string | null
    unmatchedItems?: number
    totalAmount: Decimal | DecimalJsLike | number | string
    warehouseId?: string | null
    trackingNumber?: string | null
    shippedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    allocations?: AllocationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutTaskItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutTaskItemsInput, OrderUncheckedCreateWithoutTaskItemsInput>
  }

  export type OrderItemCreateWithoutTaskItemsInput = {
    id?: string
    sku: string
    quantity: number
    quantityAllocated?: number
    quantityPicked?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    matched?: boolean
    matchError?: string | null
    shopifyLineItemId?: string | null
    shopifyFulfillmentOrderLineItemId?: string | null
    order: OrderCreateNestedOneWithoutItemsInput
    productVariant?: ProductVariantCreateNestedOneWithoutOrderItemsInput
    allocations?: AllocationCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutTaskItemsInput = {
    id?: string
    orderId: string
    productVariantId?: string | null
    sku: string
    quantity: number
    quantityAllocated?: number
    quantityPicked?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    matched?: boolean
    matchError?: string | null
    shopifyLineItemId?: string | null
    shopifyFulfillmentOrderLineItemId?: string | null
    allocations?: AllocationUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutTaskItemsInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutTaskItemsInput, OrderItemUncheckedCreateWithoutTaskItemsInput>
  }

  export type ProductVariantCreateWithoutTaskItemsInput = {
    id?: string
    sku: string
    upc?: string | null
    barcode?: string | null
    name: string
    imageUrl?: string | null
    shopifyVariantId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    sellingPrice?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    trackLots?: boolean
    trackExpiry?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductVariantInput
    inventoryUnits?: InventoryUnitCreateNestedManyWithoutProductVariantInput
    allocations?: AllocationCreateNestedManyWithoutProductVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutTaskItemsInput = {
    id?: string
    productId: string
    sku: string
    upc?: string | null
    barcode?: string | null
    name: string
    imageUrl?: string | null
    shopifyVariantId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    sellingPrice?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    trackLots?: boolean
    trackExpiry?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductVariantInput
    inventoryUnits?: InventoryUnitUncheckedCreateNestedManyWithoutProductVariantInput
    allocations?: AllocationUncheckedCreateNestedManyWithoutProductVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutTaskItemsInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutTaskItemsInput, ProductVariantUncheckedCreateWithoutTaskItemsInput>
  }

  export type LocationCreateWithoutTaskItemsInput = {
    id?: string
    name: string
    barcode?: string | null
    type?: $Enums.LocationType
    zone?: string | null
    aisle?: string | null
    rack?: string | null
    shelf?: string | null
    bin?: string | null
    pickSequence?: number | null
    isPickable?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryUnits?: InventoryUnitCreateNestedManyWithoutLocationInput
    allocations?: AllocationCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutTaskItemsInput = {
    id?: string
    name: string
    barcode?: string | null
    type?: $Enums.LocationType
    zone?: string | null
    aisle?: string | null
    rack?: string | null
    shelf?: string | null
    bin?: string | null
    pickSequence?: number | null
    isPickable?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryUnits?: InventoryUnitUncheckedCreateNestedManyWithoutLocationInput
    allocations?: AllocationUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutTaskItemsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutTaskItemsInput, LocationUncheckedCreateWithoutTaskItemsInput>
  }

  export type UserCreateWithoutCompletedTaskItemsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    role?: $Enums.UserRole
    active?: boolean
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    assignedTasks?: WorkTaskCreateNestedManyWithoutAssignedUserInput
    taskEvents?: TaskEventCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompletedTaskItemsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    role?: $Enums.UserRole
    active?: boolean
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: WorkTaskUncheckedCreateNestedManyWithoutAssignedUserInput
    taskEvents?: TaskEventUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompletedTaskItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompletedTaskItemsInput, UserUncheckedCreateWithoutCompletedTaskItemsInput>
  }

  export type AllocationCreateWithoutTaskItemInput = {
    id?: string
    quantity: number
    lotNumber?: string | null
    status?: $Enums.AllocationStatus
    allocatedAt?: Date | string
    releasedAt?: Date | string | null
    pickedAt?: Date | string | null
    inventoryUnit: InventoryUnitCreateNestedOneWithoutAllocationsInput
    order: OrderCreateNestedOneWithoutAllocationsInput
    orderItem?: OrderItemCreateNestedOneWithoutAllocationsInput
    productVariant: ProductVariantCreateNestedOneWithoutAllocationsInput
    location: LocationCreateNestedOneWithoutAllocationsInput
  }

  export type AllocationUncheckedCreateWithoutTaskItemInput = {
    id?: string
    inventoryUnitId: string
    orderId: string
    orderItemId?: string | null
    productVariantId: string
    locationId: string
    quantity: number
    lotNumber?: string | null
    status?: $Enums.AllocationStatus
    allocatedAt?: Date | string
    releasedAt?: Date | string | null
    pickedAt?: Date | string | null
  }

  export type AllocationCreateOrConnectWithoutTaskItemInput = {
    where: AllocationWhereUniqueInput
    create: XOR<AllocationCreateWithoutTaskItemInput, AllocationUncheckedCreateWithoutTaskItemInput>
  }

  export type WorkTaskUpsertWithoutTaskItemsInput = {
    update: XOR<WorkTaskUpdateWithoutTaskItemsInput, WorkTaskUncheckedUpdateWithoutTaskItemsInput>
    create: XOR<WorkTaskCreateWithoutTaskItemsInput, WorkTaskUncheckedCreateWithoutTaskItemsInput>
    where?: WorkTaskWhereInput
  }

  export type WorkTaskUpdateToOneWithWhereWithoutTaskItemsInput = {
    where?: WorkTaskWhereInput
    data: XOR<WorkTaskUpdateWithoutTaskItemsInput, WorkTaskUncheckedUpdateWithoutTaskItemsInput>
  }

  export type WorkTaskUpdateWithoutTaskItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkTaskTypeFieldUpdateOperationsInput | $Enums.WorkTaskType
    status?: EnumWorkTaskStatusFieldUpdateOperationsInput | $Enums.WorkTaskStatus
    priority?: IntFieldUpdateOperationsInput | number
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockReason?: NullableEnumWorkTaskBlockReasonFieldUpdateOperationsInput | $Enums.WorkTaskBlockReason | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderIds?: WorkTaskUpdateorderIdsInput | string[]
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    totalItems?: IntFieldUpdateOperationsInput | number
    completedItems?: IntFieldUpdateOperationsInput | number
    shortItems?: IntFieldUpdateOperationsInput | number
    skippedItems?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedUser?: UserUpdateOneWithoutAssignedTasksNestedInput
    events?: TaskEventUpdateManyWithoutTaskNestedInput
  }

  export type WorkTaskUncheckedUpdateWithoutTaskItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkTaskTypeFieldUpdateOperationsInput | $Enums.WorkTaskType
    status?: EnumWorkTaskStatusFieldUpdateOperationsInput | $Enums.WorkTaskStatus
    priority?: IntFieldUpdateOperationsInput | number
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockReason?: NullableEnumWorkTaskBlockReasonFieldUpdateOperationsInput | $Enums.WorkTaskBlockReason | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderIds?: WorkTaskUpdateorderIdsInput | string[]
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    totalItems?: IntFieldUpdateOperationsInput | number
    completedItems?: IntFieldUpdateOperationsInput | number
    shortItems?: IntFieldUpdateOperationsInput | number
    skippedItems?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: TaskEventUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type OrderUpsertWithoutTaskItemsInput = {
    update: XOR<OrderUpdateWithoutTaskItemsInput, OrderUncheckedUpdateWithoutTaskItemsInput>
    create: XOR<OrderCreateWithoutTaskItemsInput, OrderUncheckedCreateWithoutTaskItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutTaskItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutTaskItemsInput, OrderUncheckedUpdateWithoutTaskItemsInput>
  }

  export type OrderUpdateWithoutTaskItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    shopifyOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: JsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shopifyLineItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    holdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    holdBy?: NullableStringFieldUpdateOperationsInput | string | null
    unmatchedItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    allocations?: AllocationUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutTaskItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    shopifyOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: JsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shopifyLineItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    holdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    holdBy?: NullableStringFieldUpdateOperationsInput | string | null
    unmatchedItems?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    allocations?: AllocationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderItemUpsertWithoutTaskItemsInput = {
    update: XOR<OrderItemUpdateWithoutTaskItemsInput, OrderItemUncheckedUpdateWithoutTaskItemsInput>
    create: XOR<OrderItemCreateWithoutTaskItemsInput, OrderItemUncheckedCreateWithoutTaskItemsInput>
    where?: OrderItemWhereInput
  }

  export type OrderItemUpdateToOneWithWhereWithoutTaskItemsInput = {
    where?: OrderItemWhereInput
    data: XOR<OrderItemUpdateWithoutTaskItemsInput, OrderItemUncheckedUpdateWithoutTaskItemsInput>
  }

  export type OrderItemUpdateWithoutTaskItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quantityAllocated?: IntFieldUpdateOperationsInput | number
    quantityPicked?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchError?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyFulfillmentOrderLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    productVariant?: ProductVariantUpdateOneWithoutOrderItemsNestedInput
    allocations?: AllocationUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutTaskItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quantityAllocated?: IntFieldUpdateOperationsInput | number
    quantityPicked?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchError?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyFulfillmentOrderLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    allocations?: AllocationUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type ProductVariantUpsertWithoutTaskItemsInput = {
    update: XOR<ProductVariantUpdateWithoutTaskItemsInput, ProductVariantUncheckedUpdateWithoutTaskItemsInput>
    create: XOR<ProductVariantCreateWithoutTaskItemsInput, ProductVariantUncheckedCreateWithoutTaskItemsInput>
    where?: ProductVariantWhereInput
  }

  export type ProductVariantUpdateToOneWithWhereWithoutTaskItemsInput = {
    where?: ProductVariantWhereInput
    data: XOR<ProductVariantUpdateWithoutTaskItemsInput, ProductVariantUncheckedUpdateWithoutTaskItemsInput>
  }

  export type ProductVariantUpdateWithoutTaskItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trackLots?: BoolFieldUpdateOperationsInput | boolean
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductVariantNestedInput
    inventoryUnits?: InventoryUnitUpdateManyWithoutProductVariantNestedInput
    allocations?: AllocationUpdateManyWithoutProductVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutTaskItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trackLots?: BoolFieldUpdateOperationsInput | boolean
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductVariantNestedInput
    inventoryUnits?: InventoryUnitUncheckedUpdateManyWithoutProductVariantNestedInput
    allocations?: AllocationUncheckedUpdateManyWithoutProductVariantNestedInput
  }

  export type LocationUpsertWithoutTaskItemsInput = {
    update: XOR<LocationUpdateWithoutTaskItemsInput, LocationUncheckedUpdateWithoutTaskItemsInput>
    create: XOR<LocationCreateWithoutTaskItemsInput, LocationUncheckedCreateWithoutTaskItemsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutTaskItemsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutTaskItemsInput, LocationUncheckedUpdateWithoutTaskItemsInput>
  }

  export type LocationUpdateWithoutTaskItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    zone?: NullableStringFieldUpdateOperationsInput | string | null
    aisle?: NullableStringFieldUpdateOperationsInput | string | null
    rack?: NullableStringFieldUpdateOperationsInput | string | null
    shelf?: NullableStringFieldUpdateOperationsInput | string | null
    bin?: NullableStringFieldUpdateOperationsInput | string | null
    pickSequence?: NullableIntFieldUpdateOperationsInput | number | null
    isPickable?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryUnits?: InventoryUnitUpdateManyWithoutLocationNestedInput
    allocations?: AllocationUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutTaskItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    zone?: NullableStringFieldUpdateOperationsInput | string | null
    aisle?: NullableStringFieldUpdateOperationsInput | string | null
    rack?: NullableStringFieldUpdateOperationsInput | string | null
    shelf?: NullableStringFieldUpdateOperationsInput | string | null
    bin?: NullableStringFieldUpdateOperationsInput | string | null
    pickSequence?: NullableIntFieldUpdateOperationsInput | number | null
    isPickable?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryUnits?: InventoryUnitUncheckedUpdateManyWithoutLocationNestedInput
    allocations?: AllocationUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type UserUpsertWithoutCompletedTaskItemsInput = {
    update: XOR<UserUpdateWithoutCompletedTaskItemsInput, UserUncheckedUpdateWithoutCompletedTaskItemsInput>
    create: XOR<UserCreateWithoutCompletedTaskItemsInput, UserUncheckedCreateWithoutCompletedTaskItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCompletedTaskItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCompletedTaskItemsInput, UserUncheckedUpdateWithoutCompletedTaskItemsInput>
  }

  export type UserUpdateWithoutCompletedTaskItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    assignedTasks?: WorkTaskUpdateManyWithoutAssignedUserNestedInput
    taskEvents?: TaskEventUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompletedTaskItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: WorkTaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    taskEvents?: TaskEventUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AllocationUpsertWithoutTaskItemInput = {
    update: XOR<AllocationUpdateWithoutTaskItemInput, AllocationUncheckedUpdateWithoutTaskItemInput>
    create: XOR<AllocationCreateWithoutTaskItemInput, AllocationUncheckedCreateWithoutTaskItemInput>
    where?: AllocationWhereInput
  }

  export type AllocationUpdateToOneWithWhereWithoutTaskItemInput = {
    where?: AllocationWhereInput
    data: XOR<AllocationUpdateWithoutTaskItemInput, AllocationUncheckedUpdateWithoutTaskItemInput>
  }

  export type AllocationUpdateWithoutTaskItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAllocationStatusFieldUpdateOperationsInput | $Enums.AllocationStatus
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryUnit?: InventoryUnitUpdateOneRequiredWithoutAllocationsNestedInput
    order?: OrderUpdateOneRequiredWithoutAllocationsNestedInput
    orderItem?: OrderItemUpdateOneWithoutAllocationsNestedInput
    productVariant?: ProductVariantUpdateOneRequiredWithoutAllocationsNestedInput
    location?: LocationUpdateOneRequiredWithoutAllocationsNestedInput
  }

  export type AllocationUncheckedUpdateWithoutTaskItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryUnitId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAllocationStatusFieldUpdateOperationsInput | $Enums.AllocationStatus
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkTaskCreateWithoutEventsInput = {
    id?: string
    taskNumber: string
    type: $Enums.WorkTaskType
    status?: $Enums.WorkTaskStatus
    priority?: number
    idempotencyKey?: string | null
    assignedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    blockReason?: $Enums.WorkTaskBlockReason | null
    blockedAt?: Date | string | null
    orderIds?: WorkTaskCreateorderIdsInput | string[]
    totalOrders: number
    completedOrders?: number
    totalItems: number
    completedItems?: number
    shortItems?: number
    skippedItems?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedUser?: UserCreateNestedOneWithoutAssignedTasksInput
    taskItems?: TaskItemCreateNestedManyWithoutTaskInput
  }

  export type WorkTaskUncheckedCreateWithoutEventsInput = {
    id?: string
    taskNumber: string
    type: $Enums.WorkTaskType
    status?: $Enums.WorkTaskStatus
    priority?: number
    idempotencyKey?: string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    blockReason?: $Enums.WorkTaskBlockReason | null
    blockedAt?: Date | string | null
    orderIds?: WorkTaskCreateorderIdsInput | string[]
    totalOrders: number
    completedOrders?: number
    totalItems: number
    completedItems?: number
    shortItems?: number
    skippedItems?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    taskItems?: TaskItemUncheckedCreateNestedManyWithoutTaskInput
  }

  export type WorkTaskCreateOrConnectWithoutEventsInput = {
    where: WorkTaskWhereUniqueInput
    create: XOR<WorkTaskCreateWithoutEventsInput, WorkTaskUncheckedCreateWithoutEventsInput>
  }

  export type UserCreateWithoutTaskEventsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    role?: $Enums.UserRole
    active?: boolean
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    assignedTasks?: WorkTaskCreateNestedManyWithoutAssignedUserInput
    completedTaskItems?: TaskItemCreateNestedManyWithoutCompletedByUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTaskEventsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    role?: $Enums.UserRole
    active?: boolean
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: WorkTaskUncheckedCreateNestedManyWithoutAssignedUserInput
    completedTaskItems?: TaskItemUncheckedCreateNestedManyWithoutCompletedByUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTaskEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaskEventsInput, UserUncheckedCreateWithoutTaskEventsInput>
  }

  export type WorkTaskUpsertWithoutEventsInput = {
    update: XOR<WorkTaskUpdateWithoutEventsInput, WorkTaskUncheckedUpdateWithoutEventsInput>
    create: XOR<WorkTaskCreateWithoutEventsInput, WorkTaskUncheckedCreateWithoutEventsInput>
    where?: WorkTaskWhereInput
  }

  export type WorkTaskUpdateToOneWithWhereWithoutEventsInput = {
    where?: WorkTaskWhereInput
    data: XOR<WorkTaskUpdateWithoutEventsInput, WorkTaskUncheckedUpdateWithoutEventsInput>
  }

  export type WorkTaskUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkTaskTypeFieldUpdateOperationsInput | $Enums.WorkTaskType
    status?: EnumWorkTaskStatusFieldUpdateOperationsInput | $Enums.WorkTaskStatus
    priority?: IntFieldUpdateOperationsInput | number
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockReason?: NullableEnumWorkTaskBlockReasonFieldUpdateOperationsInput | $Enums.WorkTaskBlockReason | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderIds?: WorkTaskUpdateorderIdsInput | string[]
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    totalItems?: IntFieldUpdateOperationsInput | number
    completedItems?: IntFieldUpdateOperationsInput | number
    shortItems?: IntFieldUpdateOperationsInput | number
    skippedItems?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedUser?: UserUpdateOneWithoutAssignedTasksNestedInput
    taskItems?: TaskItemUpdateManyWithoutTaskNestedInput
  }

  export type WorkTaskUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkTaskTypeFieldUpdateOperationsInput | $Enums.WorkTaskType
    status?: EnumWorkTaskStatusFieldUpdateOperationsInput | $Enums.WorkTaskStatus
    priority?: IntFieldUpdateOperationsInput | number
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockReason?: NullableEnumWorkTaskBlockReasonFieldUpdateOperationsInput | $Enums.WorkTaskBlockReason | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderIds?: WorkTaskUpdateorderIdsInput | string[]
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    totalItems?: IntFieldUpdateOperationsInput | number
    completedItems?: IntFieldUpdateOperationsInput | number
    shortItems?: IntFieldUpdateOperationsInput | number
    skippedItems?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskItems?: TaskItemUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserUpsertWithoutTaskEventsInput = {
    update: XOR<UserUpdateWithoutTaskEventsInput, UserUncheckedUpdateWithoutTaskEventsInput>
    create: XOR<UserCreateWithoutTaskEventsInput, UserUncheckedCreateWithoutTaskEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaskEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaskEventsInput, UserUncheckedUpdateWithoutTaskEventsInput>
  }

  export type UserUpdateWithoutTaskEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    assignedTasks?: WorkTaskUpdateManyWithoutAssignedUserNestedInput
    completedTaskItems?: TaskItemUpdateManyWithoutCompletedByUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTaskEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: WorkTaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    completedTaskItems?: TaskItemUncheckedUpdateManyWithoutCompletedByUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    role?: $Enums.UserRole
    active?: boolean
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    assignedTasks?: WorkTaskCreateNestedManyWithoutAssignedUserInput
    taskEvents?: TaskEventCreateNestedManyWithoutUserInput
    completedTaskItems?: TaskItemCreateNestedManyWithoutCompletedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    role?: $Enums.UserRole
    active?: boolean
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: WorkTaskUncheckedCreateNestedManyWithoutAssignedUserInput
    taskEvents?: TaskEventUncheckedCreateNestedManyWithoutUserInput
    completedTaskItems?: TaskItemUncheckedCreateNestedManyWithoutCompletedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    assignedTasks?: WorkTaskUpdateManyWithoutAssignedUserNestedInput
    taskEvents?: TaskEventUpdateManyWithoutUserNestedInput
    completedTaskItems?: TaskItemUpdateManyWithoutCompletedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: WorkTaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    taskEvents?: TaskEventUncheckedUpdateManyWithoutUserNestedInput
    completedTaskItems?: TaskItemUncheckedUpdateManyWithoutCompletedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    role?: $Enums.UserRole
    active?: boolean
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    assignedTasks?: WorkTaskCreateNestedManyWithoutAssignedUserInput
    taskEvents?: TaskEventCreateNestedManyWithoutUserInput
    completedTaskItems?: TaskItemCreateNestedManyWithoutCompletedByUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    role?: $Enums.UserRole
    active?: boolean
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: WorkTaskUncheckedCreateNestedManyWithoutAssignedUserInput
    taskEvents?: TaskEventUncheckedCreateNestedManyWithoutUserInput
    completedTaskItems?: TaskItemUncheckedCreateNestedManyWithoutCompletedByUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    assignedTasks?: WorkTaskUpdateManyWithoutAssignedUserNestedInput
    taskEvents?: TaskEventUpdateManyWithoutUserNestedInput
    completedTaskItems?: TaskItemUpdateManyWithoutCompletedByUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: WorkTaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    taskEvents?: TaskEventUncheckedUpdateManyWithoutUserNestedInput
    completedTaskItems?: TaskItemUncheckedUpdateManyWithoutCompletedByUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type PasswordResetTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type WorkTaskCreateManyAssignedUserInput = {
    id?: string
    taskNumber: string
    type: $Enums.WorkTaskType
    status?: $Enums.WorkTaskStatus
    priority?: number
    idempotencyKey?: string | null
    assignedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    blockReason?: $Enums.WorkTaskBlockReason | null
    blockedAt?: Date | string | null
    orderIds?: WorkTaskCreateorderIdsInput | string[]
    totalOrders: number
    completedOrders?: number
    totalItems: number
    completedItems?: number
    shortItems?: number
    skippedItems?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskEventCreateManyUserInput = {
    id?: string
    taskId: string
    eventType: $Enums.WorkTaskEventType
    taskItemId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TaskItemCreateManyCompletedByUserInput = {
    id?: string
    taskId: string
    orderId: string
    orderItemId?: string | null
    productVariantId?: string | null
    locationId?: string | null
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    correlationId?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkTaskUpdateWithoutAssignedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkTaskTypeFieldUpdateOperationsInput | $Enums.WorkTaskType
    status?: EnumWorkTaskStatusFieldUpdateOperationsInput | $Enums.WorkTaskStatus
    priority?: IntFieldUpdateOperationsInput | number
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockReason?: NullableEnumWorkTaskBlockReasonFieldUpdateOperationsInput | $Enums.WorkTaskBlockReason | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderIds?: WorkTaskUpdateorderIdsInput | string[]
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    totalItems?: IntFieldUpdateOperationsInput | number
    completedItems?: IntFieldUpdateOperationsInput | number
    shortItems?: IntFieldUpdateOperationsInput | number
    skippedItems?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskItems?: TaskItemUpdateManyWithoutTaskNestedInput
    events?: TaskEventUpdateManyWithoutTaskNestedInput
  }

  export type WorkTaskUncheckedUpdateWithoutAssignedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkTaskTypeFieldUpdateOperationsInput | $Enums.WorkTaskType
    status?: EnumWorkTaskStatusFieldUpdateOperationsInput | $Enums.WorkTaskStatus
    priority?: IntFieldUpdateOperationsInput | number
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockReason?: NullableEnumWorkTaskBlockReasonFieldUpdateOperationsInput | $Enums.WorkTaskBlockReason | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderIds?: WorkTaskUpdateorderIdsInput | string[]
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    totalItems?: IntFieldUpdateOperationsInput | number
    completedItems?: IntFieldUpdateOperationsInput | number
    shortItems?: IntFieldUpdateOperationsInput | number
    skippedItems?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskItems?: TaskItemUncheckedUpdateManyWithoutTaskNestedInput
    events?: TaskEventUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type WorkTaskUncheckedUpdateManyWithoutAssignedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkTaskTypeFieldUpdateOperationsInput | $Enums.WorkTaskType
    status?: EnumWorkTaskStatusFieldUpdateOperationsInput | $Enums.WorkTaskStatus
    priority?: IntFieldUpdateOperationsInput | number
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockReason?: NullableEnumWorkTaskBlockReasonFieldUpdateOperationsInput | $Enums.WorkTaskBlockReason | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderIds?: WorkTaskUpdateorderIdsInput | string[]
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    totalItems?: IntFieldUpdateOperationsInput | number
    completedItems?: IntFieldUpdateOperationsInput | number
    shortItems?: IntFieldUpdateOperationsInput | number
    skippedItems?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWorkTaskEventTypeFieldUpdateOperationsInput | $Enums.WorkTaskEventType
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: WorkTaskUpdateOneRequiredWithoutEventsNestedInput
  }

  export type TaskEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWorkTaskEventTypeFieldUpdateOperationsInput | $Enums.WorkTaskEventType
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWorkTaskEventTypeFieldUpdateOperationsInput | $Enums.WorkTaskEventType
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskItemUpdateWithoutCompletedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: WorkTaskUpdateOneRequiredWithoutTaskItemsNestedInput
    order?: OrderUpdateOneRequiredWithoutTaskItemsNestedInput
    orderItem?: OrderItemUpdateOneWithoutTaskItemsNestedInput
    productVariant?: ProductVariantUpdateOneWithoutTaskItemsNestedInput
    location?: LocationUpdateOneWithoutTaskItemsNestedInput
    allocation?: AllocationUpdateOneWithoutTaskItemNestedInput
  }

  export type TaskItemUncheckedUpdateWithoutCompletedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocation?: AllocationUncheckedUpdateOneWithoutTaskItemNestedInput
  }

  export type TaskItemUncheckedUpdateManyWithoutCompletedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    correlationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    correlationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    correlationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantCreateManyProductInput = {
    id?: string
    sku: string
    upc?: string | null
    barcode?: string | null
    name: string
    imageUrl?: string | null
    shopifyVariantId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    sellingPrice?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    trackLots?: boolean
    trackExpiry?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trackLots?: BoolFieldUpdateOperationsInput | boolean
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductVariantNestedInput
    inventoryUnits?: InventoryUnitUpdateManyWithoutProductVariantNestedInput
    taskItems?: TaskItemUpdateManyWithoutProductVariantNestedInput
    allocations?: AllocationUpdateManyWithoutProductVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trackLots?: BoolFieldUpdateOperationsInput | boolean
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductVariantNestedInput
    inventoryUnits?: InventoryUnitUncheckedUpdateManyWithoutProductVariantNestedInput
    taskItems?: TaskItemUncheckedUpdateManyWithoutProductVariantNestedInput
    allocations?: AllocationUncheckedUpdateManyWithoutProductVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trackLots?: BoolFieldUpdateOperationsInput | boolean
    trackExpiry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyProductVariantInput = {
    id?: string
    orderId: string
    sku: string
    quantity: number
    quantityAllocated?: number
    quantityPicked?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    matched?: boolean
    matchError?: string | null
    shopifyLineItemId?: string | null
    shopifyFulfillmentOrderLineItemId?: string | null
  }

  export type InventoryUnitCreateManyProductVariantInput = {
    id?: string
    locationId: string
    quantity?: number
    status?: $Enums.InventoryStatus
    lotNumber?: string | null
    expiryDate?: Date | string | null
    receivedAt?: Date | string
    receivedFrom?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskItemCreateManyProductVariantInput = {
    id?: string
    taskId: string
    orderId: string
    orderItemId?: string | null
    locationId?: string | null
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedBy?: string | null
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AllocationCreateManyProductVariantInput = {
    id?: string
    inventoryUnitId: string
    orderId: string
    orderItemId?: string | null
    locationId: string
    quantity: number
    lotNumber?: string | null
    status?: $Enums.AllocationStatus
    allocatedAt?: Date | string
    releasedAt?: Date | string | null
    pickedAt?: Date | string | null
    taskItemId?: string | null
  }

  export type OrderItemUpdateWithoutProductVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quantityAllocated?: IntFieldUpdateOperationsInput | number
    quantityPicked?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchError?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyFulfillmentOrderLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    taskItems?: TaskItemUpdateManyWithoutOrderItemNestedInput
    allocations?: AllocationUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quantityAllocated?: IntFieldUpdateOperationsInput | number
    quantityPicked?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchError?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyFulfillmentOrderLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    taskItems?: TaskItemUncheckedUpdateManyWithoutOrderItemNestedInput
    allocations?: AllocationUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutProductVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quantityAllocated?: IntFieldUpdateOperationsInput | number
    quantityPicked?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchError?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyFulfillmentOrderLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryUnitUpdateWithoutProductVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutInventoryUnitsNestedInput
    allocations?: AllocationUpdateManyWithoutInventoryUnitNestedInput
  }

  export type InventoryUnitUncheckedUpdateWithoutProductVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: AllocationUncheckedUpdateManyWithoutInventoryUnitNestedInput
  }

  export type InventoryUnitUncheckedUpdateManyWithoutProductVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskItemUpdateWithoutProductVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: WorkTaskUpdateOneRequiredWithoutTaskItemsNestedInput
    order?: OrderUpdateOneRequiredWithoutTaskItemsNestedInput
    orderItem?: OrderItemUpdateOneWithoutTaskItemsNestedInput
    location?: LocationUpdateOneWithoutTaskItemsNestedInput
    completedByUser?: UserUpdateOneWithoutCompletedTaskItemsNestedInput
    allocation?: AllocationUpdateOneWithoutTaskItemNestedInput
  }

  export type TaskItemUncheckedUpdateWithoutProductVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocation?: AllocationUncheckedUpdateOneWithoutTaskItemNestedInput
  }

  export type TaskItemUncheckedUpdateManyWithoutProductVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllocationUpdateWithoutProductVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAllocationStatusFieldUpdateOperationsInput | $Enums.AllocationStatus
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryUnit?: InventoryUnitUpdateOneRequiredWithoutAllocationsNestedInput
    order?: OrderUpdateOneRequiredWithoutAllocationsNestedInput
    orderItem?: OrderItemUpdateOneWithoutAllocationsNestedInput
    location?: LocationUpdateOneRequiredWithoutAllocationsNestedInput
    taskItem?: TaskItemUpdateOneWithoutAllocationNestedInput
  }

  export type AllocationUncheckedUpdateWithoutProductVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryUnitId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAllocationStatusFieldUpdateOperationsInput | $Enums.AllocationStatus
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AllocationUncheckedUpdateManyWithoutProductVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryUnitId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAllocationStatusFieldUpdateOperationsInput | $Enums.AllocationStatus
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryUnitCreateManyLocationInput = {
    id?: string
    productVariantId: string
    quantity?: number
    status?: $Enums.InventoryStatus
    lotNumber?: string | null
    expiryDate?: Date | string | null
    receivedAt?: Date | string
    receivedFrom?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskItemCreateManyLocationInput = {
    id?: string
    taskId: string
    orderId: string
    orderItemId?: string | null
    productVariantId?: string | null
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedBy?: string | null
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AllocationCreateManyLocationInput = {
    id?: string
    inventoryUnitId: string
    orderId: string
    orderItemId?: string | null
    productVariantId: string
    quantity: number
    lotNumber?: string | null
    status?: $Enums.AllocationStatus
    allocatedAt?: Date | string
    releasedAt?: Date | string | null
    pickedAt?: Date | string | null
    taskItemId?: string | null
  }

  export type InventoryUnitUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productVariant?: ProductVariantUpdateOneRequiredWithoutInventoryUnitsNestedInput
    allocations?: AllocationUpdateManyWithoutInventoryUnitNestedInput
  }

  export type InventoryUnitUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    productVariantId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: AllocationUncheckedUpdateManyWithoutInventoryUnitNestedInput
  }

  export type InventoryUnitUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    productVariantId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskItemUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: WorkTaskUpdateOneRequiredWithoutTaskItemsNestedInput
    order?: OrderUpdateOneRequiredWithoutTaskItemsNestedInput
    orderItem?: OrderItemUpdateOneWithoutTaskItemsNestedInput
    productVariant?: ProductVariantUpdateOneWithoutTaskItemsNestedInput
    completedByUser?: UserUpdateOneWithoutCompletedTaskItemsNestedInput
    allocation?: AllocationUpdateOneWithoutTaskItemNestedInput
  }

  export type TaskItemUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocation?: AllocationUncheckedUpdateOneWithoutTaskItemNestedInput
  }

  export type TaskItemUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllocationUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAllocationStatusFieldUpdateOperationsInput | $Enums.AllocationStatus
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryUnit?: InventoryUnitUpdateOneRequiredWithoutAllocationsNestedInput
    order?: OrderUpdateOneRequiredWithoutAllocationsNestedInput
    orderItem?: OrderItemUpdateOneWithoutAllocationsNestedInput
    productVariant?: ProductVariantUpdateOneRequiredWithoutAllocationsNestedInput
    taskItem?: TaskItemUpdateOneWithoutAllocationNestedInput
  }

  export type AllocationUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryUnitId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAllocationStatusFieldUpdateOperationsInput | $Enums.AllocationStatus
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AllocationUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryUnitId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAllocationStatusFieldUpdateOperationsInput | $Enums.AllocationStatus
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AllocationCreateManyInventoryUnitInput = {
    id?: string
    orderId: string
    orderItemId?: string | null
    productVariantId: string
    locationId: string
    quantity: number
    lotNumber?: string | null
    status?: $Enums.AllocationStatus
    allocatedAt?: Date | string
    releasedAt?: Date | string | null
    pickedAt?: Date | string | null
    taskItemId?: string | null
  }

  export type AllocationUpdateWithoutInventoryUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAllocationStatusFieldUpdateOperationsInput | $Enums.AllocationStatus
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneRequiredWithoutAllocationsNestedInput
    orderItem?: OrderItemUpdateOneWithoutAllocationsNestedInput
    productVariant?: ProductVariantUpdateOneRequiredWithoutAllocationsNestedInput
    location?: LocationUpdateOneRequiredWithoutAllocationsNestedInput
    taskItem?: TaskItemUpdateOneWithoutAllocationNestedInput
  }

  export type AllocationUncheckedUpdateWithoutInventoryUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAllocationStatusFieldUpdateOperationsInput | $Enums.AllocationStatus
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AllocationUncheckedUpdateManyWithoutInventoryUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAllocationStatusFieldUpdateOperationsInput | $Enums.AllocationStatus
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    productVariantId?: string | null
    sku: string
    quantity: number
    quantityAllocated?: number
    quantityPicked?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    matched?: boolean
    matchError?: string | null
    shopifyLineItemId?: string | null
    shopifyFulfillmentOrderLineItemId?: string | null
  }

  export type TaskItemCreateManyOrderInput = {
    id?: string
    taskId: string
    orderItemId?: string | null
    productVariantId?: string | null
    locationId?: string | null
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedBy?: string | null
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AllocationCreateManyOrderInput = {
    id?: string
    inventoryUnitId: string
    orderItemId?: string | null
    productVariantId: string
    locationId: string
    quantity: number
    lotNumber?: string | null
    status?: $Enums.AllocationStatus
    allocatedAt?: Date | string
    releasedAt?: Date | string | null
    pickedAt?: Date | string | null
    taskItemId?: string | null
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quantityAllocated?: IntFieldUpdateOperationsInput | number
    quantityPicked?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchError?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyFulfillmentOrderLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariant?: ProductVariantUpdateOneWithoutOrderItemsNestedInput
    taskItems?: TaskItemUpdateManyWithoutOrderItemNestedInput
    allocations?: AllocationUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quantityAllocated?: IntFieldUpdateOperationsInput | number
    quantityPicked?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchError?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyFulfillmentOrderLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    taskItems?: TaskItemUncheckedUpdateManyWithoutOrderItemNestedInput
    allocations?: AllocationUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quantityAllocated?: IntFieldUpdateOperationsInput | number
    quantityPicked?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matched?: BoolFieldUpdateOperationsInput | boolean
    matchError?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyFulfillmentOrderLineItemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: WorkTaskUpdateOneRequiredWithoutTaskItemsNestedInput
    orderItem?: OrderItemUpdateOneWithoutTaskItemsNestedInput
    productVariant?: ProductVariantUpdateOneWithoutTaskItemsNestedInput
    location?: LocationUpdateOneWithoutTaskItemsNestedInput
    completedByUser?: UserUpdateOneWithoutCompletedTaskItemsNestedInput
    allocation?: AllocationUpdateOneWithoutTaskItemNestedInput
  }

  export type TaskItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocation?: AllocationUncheckedUpdateOneWithoutTaskItemNestedInput
  }

  export type TaskItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllocationUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAllocationStatusFieldUpdateOperationsInput | $Enums.AllocationStatus
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryUnit?: InventoryUnitUpdateOneRequiredWithoutAllocationsNestedInput
    orderItem?: OrderItemUpdateOneWithoutAllocationsNestedInput
    productVariant?: ProductVariantUpdateOneRequiredWithoutAllocationsNestedInput
    location?: LocationUpdateOneRequiredWithoutAllocationsNestedInput
    taskItem?: TaskItemUpdateOneWithoutAllocationNestedInput
  }

  export type AllocationUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryUnitId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAllocationStatusFieldUpdateOperationsInput | $Enums.AllocationStatus
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AllocationUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryUnitId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAllocationStatusFieldUpdateOperationsInput | $Enums.AllocationStatus
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskItemCreateManyOrderItemInput = {
    id?: string
    taskId: string
    orderId: string
    productVariantId?: string | null
    locationId?: string | null
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedBy?: string | null
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AllocationCreateManyOrderItemInput = {
    id?: string
    inventoryUnitId: string
    orderId: string
    productVariantId: string
    locationId: string
    quantity: number
    lotNumber?: string | null
    status?: $Enums.AllocationStatus
    allocatedAt?: Date | string
    releasedAt?: Date | string | null
    pickedAt?: Date | string | null
    taskItemId?: string | null
  }

  export type TaskItemUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: WorkTaskUpdateOneRequiredWithoutTaskItemsNestedInput
    order?: OrderUpdateOneRequiredWithoutTaskItemsNestedInput
    productVariant?: ProductVariantUpdateOneWithoutTaskItemsNestedInput
    location?: LocationUpdateOneWithoutTaskItemsNestedInput
    completedByUser?: UserUpdateOneWithoutCompletedTaskItemsNestedInput
    allocation?: AllocationUpdateOneWithoutTaskItemNestedInput
  }

  export type TaskItemUncheckedUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocation?: AllocationUncheckedUpdateOneWithoutTaskItemNestedInput
  }

  export type TaskItemUncheckedUpdateManyWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllocationUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAllocationStatusFieldUpdateOperationsInput | $Enums.AllocationStatus
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryUnit?: InventoryUnitUpdateOneRequiredWithoutAllocationsNestedInput
    order?: OrderUpdateOneRequiredWithoutAllocationsNestedInput
    productVariant?: ProductVariantUpdateOneRequiredWithoutAllocationsNestedInput
    location?: LocationUpdateOneRequiredWithoutAllocationsNestedInput
    taskItem?: TaskItemUpdateOneWithoutAllocationNestedInput
  }

  export type AllocationUncheckedUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryUnitId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productVariantId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAllocationStatusFieldUpdateOperationsInput | $Enums.AllocationStatus
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AllocationUncheckedUpdateManyWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryUnitId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productVariantId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAllocationStatusFieldUpdateOperationsInput | $Enums.AllocationStatus
    allocatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskItemCreateManyTaskInput = {
    id?: string
    orderId: string
    orderItemId?: string | null
    productVariantId?: string | null
    locationId?: string | null
    allocationId?: string | null
    sequence: number
    quantityRequired: number
    quantityCompleted?: number
    status?: $Enums.WorkTaskItemStatus
    completedBy?: string | null
    completedAt?: Date | string | null
    shortReason?: string | null
    locationScanned?: boolean
    itemScanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskEventCreateManyTaskInput = {
    id?: string
    eventType: $Enums.WorkTaskEventType
    userId?: string | null
    taskItemId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TaskItemUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutTaskItemsNestedInput
    orderItem?: OrderItemUpdateOneWithoutTaskItemsNestedInput
    productVariant?: ProductVariantUpdateOneWithoutTaskItemsNestedInput
    location?: LocationUpdateOneWithoutTaskItemsNestedInput
    completedByUser?: UserUpdateOneWithoutCompletedTaskItemsNestedInput
    allocation?: AllocationUpdateOneWithoutTaskItemNestedInput
  }

  export type TaskItemUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocation?: AllocationUncheckedUpdateOneWithoutTaskItemNestedInput
  }

  export type TaskItemUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    allocationId?: NullableStringFieldUpdateOperationsInput | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    quantityRequired?: IntFieldUpdateOperationsInput | number
    quantityCompleted?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkTaskItemStatusFieldUpdateOperationsInput | $Enums.WorkTaskItemStatus
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortReason?: NullableStringFieldUpdateOperationsInput | string | null
    locationScanned?: BoolFieldUpdateOperationsInput | boolean
    itemScanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskEventUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWorkTaskEventTypeFieldUpdateOperationsInput | $Enums.WorkTaskEventType
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTaskEventsNestedInput
  }

  export type TaskEventUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWorkTaskEventTypeFieldUpdateOperationsInput | $Enums.WorkTaskEventType
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskEventUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumWorkTaskEventTypeFieldUpdateOperationsInput | $Enums.WorkTaskEventType
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    taskItemId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}